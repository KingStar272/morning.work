<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[早起搬砖 morning.work]]></title><description><![CDATA[早起搬砖 morning.work]]></description><link>http://morning.work</link><generator>RSS for Node</generator><lastBuildDate>Sun, 20 Nov 2016 15:22:22 GMT</lastBuildDate><atom:link href="http://morning.work/rss.xml" rel="self" type="application/rss+xml"/><language><![CDATA[zh-CN,en]]></language><ttl>60</ttl><item><title><![CDATA[如何打造一款属于自己的 Visual Studio Code 颜色主题]]></title><description><![CDATA[<h2><a id="_3"></a>前言</h2>
<p><a href="https://code.visualstudio.com">Visual Studio Code</a> 是我在最近一年中最喜欢的一款编辑器，微软每一次的更新都会给大家带来惊喜，更是令人愈加喜欢。之前一直使用内置的颜色主题<code>Light+</code>和<code>Dark+</code>，但近来突然觉得前者颜色区分度不高，一眼看上去就密密麻麻的一对代码，而后者则是被选中的文本背景色太浅，跟编辑器的背景颜色很相似，很难区分出来，于是萌生了要制作一款自己的颜色主题的想法。经过几天的研究，终于捣鼓出来了<a href="https://github.com/leizongmin/lei-theme-vscode">Lei Theme</a>系列颜色主题。</p>
<p>先来看看其中两款主题的效果：</p>
<p><img src="https://github.com/leizongmin/lei-theme-vscode/raw/master/screen/lei-light.png" alt="lei-light"></p>
<p><img src="https://github.com/leizongmin/lei-theme-vscode/raw/master/screen/lei-dark-blue.png" alt="lei-dark-blue"></p>
<p>一般来说，我们并不需要重头来制作一款颜色主题，首先需要选择一款自己最喜欢的颜色主题（或者说先找一款与自己的想法最相似的颜色主题），然后在此基础上进行些许调整即可。另外如果想将颜色主题发布到微软的 Visual Studio Code 扩展商店上，还需要注册一个微软开发者账号，并通过<a href="https://www.npmjs.com/package/vsce">vsce</a>工具来发布出去，下文会对此进行详细说明。</p>
<h2><a id="tmTheme__16"></a>tmTheme 格式的颜色主题</h2>
<p>TextMate 曾是多年前最流行的代码编辑器之一，其颜色主题的文件后缀为<code>.tmTheme</code>，在本文中我们将其简称为<code>tmTheme</code>格式。Visual Studio Studio 的颜色主题采用的是标准的 TextMate 主题格式，我们可以参考这篇文章<a href="http://www.apeth.com/nonblog/stories/textmatebundle.html">Writing a TextMate Grammar: Some Lessons Learned</a>，大概可以理解为这样：<strong>编辑器对代码进行解析后，会为每个元素指定一个<code>scope</code>，这个<code>scope</code>即表明此元素是一个关键字还是一个常量，又或者是一个标点符号，通过<code>tmTheme</code>格式的文件来定义相应<code>scope</code>的文字样式。</strong></p>
<p>根据该文章可知道以下是常见的<code>scope</code>列表：</p>
<pre><code>comment
constant
constant.character.escape
constant.language
constant.numeric
declaration.section entity.name.section
declaration.tag
deco.folding
entity.name.function
entity.name.tag
entity.name.type
entity.other.attribute-name
entity.other.inherited-class
invalid
invalid.deprecated.trailing-whitespace
keyword
keyword.control.import
keyword.operator.js
markup.heading
markup.list
markup.quote
meta.embedded
meta.preprocessor
meta.section entity.name.section
meta.tag
storage
storage.type.method
string
string source
string.unquoted
support.class
support.constant
support.function
support.type
support.variable
text source
variable
variable.language
variable.other
variable.parameter
</code></pre>
<p>以下是一个<code>tmTheme</code>格式文件的代码片段：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Keyword<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>scope<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>keyword.control,keyword.other,variable.language,storage.type,storage.modifier,keyword.function<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>settings<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>foreground<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>#0808D1<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Invalid<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>scope<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>invalid<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>settings<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>foreground<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>#cd3131<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
</code></pre>
<p>从上面的代码可以看出，其实这个<code>tmTheme</code>格式的文件似乎也挺简单的，然而初学者而言，难的是<strong>不知道<code>scope</code>怎么写</strong>，下文会循序渐进地对此进行说明。</p>
<h2><a id="_94"></a>创建颜色主题项目</h2>
<p>根据官方文档，我们先执行以下命令安装<a href="http://yeoman.io/">Yeoman</a>代码生成工具来创建一个默认的颜色主题项目：</p>
<pre><code class="language-bash">$ npm install -g yo generator-code
</code></pre>
<p>安装完毕之后，进入<code>~/.vscode/extensions</code>目录执行以下命令启动生成器：</p>
<pre><code class="language-bash">$ yo code
</code></pre>
<p>说明：<code>~/.vscode/extensions</code>表示用户根目录下的<code>.vscode/extensions</code>目录，之所以在此处新建项目主要是为了不用发布到扩展商店也可以在本地进行使用，并且方便调试。</p>
<p>选择<code>New Color Theme</code>创建颜色主题项目：</p>
<pre><code>     _-----_     ╭──────────────────────────╮
    |       |    │   Welcome to the Visual  │
    |--(o)--|    │   Studio Code Extension  │
   `---------´   │        generator!        │
    ( _´U`_ )    ╰──────────────────────────╯
    /___A___\   /
     |  ~  |
   __'.___.'__
 ´   `  |° ´ Y `

? What type of extension do you want to create?
  New Extension (TypeScript)
  New Extension (JavaScript)
❯ New Color Theme
  New Language Support
  New Code Snippets
</code></pre>
<p>接着需要在命令行下交互式地填写一些问题，以下是我在执行过程中填写的内容：</p>
<pre><code>? What type of extension do you want to create? New Color Theme
URL (http, https) or file name of the tmTheme file, e.g., http://www.monokai.nl/blog/wp-content/asdev/Monokai.tmTheme.
? URL or file name: http://www.monokai.nl/blog/wp-content/asdev/Monokai.tmTheme
? What's the name of your extension? my-theme
? What's the identifier of your extension? my-theme
? What's the description of your extension?
? What's your publisher name? leizongmin
? What's the name of your theme shown to the user? my-theme
? Select a base theme: Dark
</code></pre>
<p>需要说明的是，第一个问题<code>URL (http, https) or file name of the tmTheme file</code>需要提供一个已有的<code>tmTheme</code>文件作为基础，此处可直接复制示例中的<code>URL</code>。</p>
<p>稍等片刻，工具自动生成了项目之后，会提示我们执行以下命令开始编辑代该项目：</p>
<pre><code>$ cd my-theme
$ code .
</code></pre>
<p>以下是生成的项目的文件结构：</p>
<pre><code>.
├── README.md
├── package.json （扩展信息文件）
├── themes
│   └── Monokai.tmTheme （颜色主题定义文件）
└── vsc-extension-quickstart.md （帮助文件，上面详细说明操作步骤）
</code></pre>
<p>首先看看<code>package.json</code>文件：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-theme"</span>,
  <span class="hljs-attr">"displayName"</span>: <span class="hljs-string">"my-theme"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,
  <span class="hljs-attr">"publisher"</span>: <span class="hljs-string">"leizongmin"</span>,
  <span class="hljs-attr">"engines"</span>: {
    <span class="hljs-attr">"vscode"</span>: <span class="hljs-string">"^1.5.0"</span>
  },
  <span class="hljs-attr">"categories"</span>: [
    <span class="hljs-string">"Themes"</span>
  ],
  <span class="hljs-attr">"contributes"</span>: {
    <span class="hljs-attr">"themes"</span>: [
      {
        <span class="hljs-attr">"label"</span>: <span class="hljs-string">"my-theme"</span>,
        <span class="hljs-attr">"uiTheme"</span>: <span class="hljs-string">"vs-dark"</span>,
        <span class="hljs-attr">"path"</span>: <span class="hljs-string">"./themes/Monokai.tmTheme"</span>
      }
    ]
  }
}
</code></pre>
<p><code>contributes</code>中定义了此扩展项目包含的内容，其中<code>themes</code>表示颜色主题，是一个数组，我们可在此处放入多个颜色主题。以下是<code>themes</code>中每个元素的定义：</p>
<ul>
<li><code>label</code>表示颜色主题的名称，即在<code>Preferences: Color Theme</code>列表中显示的名称</li>
<li><code>uiTheme</code>是指编辑器 UI 的颜色，可选为<code>vs-light</code>和<code>vs-dark</code>，如果我们的颜色主题是深色系的，就选<code>vs-dark</code></li>
<li><code>path</code>是<code>tmTheme</code>文件的位置</li>
</ul>
<p>为了避免混淆，我们可以将文件<code>./themes/Monokai.tmTheme</code>改名为<code>./themes/my-theme.tmTheme</code>，并修改<code>package.json</code>相应的位置。</p>
<p>现在在 Visual Studio Code 中按快捷键<code>⌘Command + Shift + P</code>打开命令面板（Windows / Linux 系统应为<code>Ctrl + Shift + P</code>），输入<code>Color Theme</code>并按回车，再中列表中选择<code>my-theme</code>按回车即可使用刚刚创建的新颜色主题：</p>
<p><img src="../../images/2016-11/my-theme-1.png" alt="my-theme"></p>
<p>从上图可以看出，这其实就是一个标准的<code>Monokai</code>主题。</p>
<h2><a id="tmTheme__207"></a>tmTheme 编辑器</h2>
<p>从生成的<code>vsc-extension-quickstart.md</code>文件中我们得知有一款 Web 版的在线 <a href="https://tmtheme-editor.herokuapp.com">tmTheme 编辑器</a>，通过该编辑器可以进行可视化地编辑 tmTheme 文件。比如以下视频是更改<code>String</code>和<code>Keyword</code>颜色的示例：</p>
<p><video src="../../images/2016-11/tmtheme-editor-change-color.mp4" controls width="100%" loop="loop">你的浏览器不支持 <code>video</code> 标签.</video></p>
<p>主要的操作方法为：</p>
<ul>
<li>在左侧<code>Scope Name</code>列表中选中一项，然后双击<code>FG</code>列上的颜色（FG 表示 foreground，即前景颜色），然后选择要更改的颜色即可，可以看到代码预览区域的颜色会实时改变</li>
<li>点击顶部栏的【Download】按钮即可下载编辑后的<code>tmTheme</code>文件，直接将其覆盖项目中的<code>./themes/my-theme.tmTheme</code>文件即可</li>
<li>在 Visual Studio Code 中按快捷键<code>⌘Command + Shift + P</code>打开命令面板，输入<code>Reload Window</code>并按回车即可看到修改后的颜色主题</li>
</ul>
<p>但是，在一些实现细节上，Visual Studio Code 并不与该 tmTheme 编辑器一致，所以我们在该在线编辑器上看到的效果可能与 Visual Studio Code 上稍有不同，所以我们可能还需要直接编辑<code>tmTheme</code>文件。</p>
<h2><a id="_scope__222"></a>如何知道 scope 是什么</h2>
<p>下面是这款主题中，模板字符串的渲染效果：</p>
<p><img src="../../images/2016-11/my-theme-2.png" alt="template-string"></p>
<p>从图中可以看到，模板字符串中的字符串和变量的颜色都是一样的，而假如我想改变模板字符串中变量的颜色，却是无从下手，因为即使翻遍 TextMate 官方文档中关于 tmTheme 的介绍也找不到模板字符串的<code>scope</code>是什么。</p>
<p>其实我们可以借助 Visual Studio Code 的开发者工具来找到任意元素的<code>scope</code>，以下是演示视频：</p>
<p><video src="../../images/2016-11/vscode-developer-tools.mp4" controls width="100%" loop="loop">你的浏览器不支持 <code>video</code> 标签.</video></p>
<p>从开发者工具中我们可以看到模板字符串中<code>${</code>的样式是：</p>
<pre><code>token block ts punctuation definition meta string begin function arrow new expr template expression template-expression
</code></pre>
<p>而模板变量<code>file</code>的样式是：</p>
<pre><code>token block ts meta variable other readwrite string function arrow new expr template expression
</code></pre>
<p>再结合文首对于<code>scope</code>介绍的文章，我们假设我们要的<code>scope</code>名为<code>template.expression</code>。接着打开文件<code>./themes/my-theme.tmTheme</code>，仿照该文件的格式，我们添加以下代码在对应位置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Template Expression<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>scope<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>template.expression<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>settings<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>foreground<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>#23C4FA<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
</code></pre>
<p>再按快捷键<code>⌘Command + Shift + P</code>打开命令面板，执行<code>Reload Window</code>，此时可以看到模板字符串中的变量颜色跟字符串的颜色不一样了：</p>
<p><img src="../../images/2016-11/my-theme-3.png" alt="template-string"></p>
<h2><a id="tmTheme__267"></a>tmTheme 文件处理规则</h2>
<p>尽管已经实现了我们想要的效果，相信阅读到这里的时候很多人还是一头雾水，并不知道为何<code>scope</code>是<code>template.expression</code>。我在刚开始时虽然也猜想到是像 CSS 的类选择器一样，但还是不太确定，直到阅读到 Visual Studio Code 的源码后才得以印证。</p>
<p>以下是<a href="https://github.com/Microsoft/vscode">Visual Studio Code</a>源码中负责处理<code>tmTheme</code>的<code>scope</code>的程序文件<code>src/vs/workbench/services/themes/electron-browser/stylesContributions.ts</code>（<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/services/themes/electron-browser/stylesContributions.ts#L93">点此查看完整文件</a>）:</p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TokenStylesContribution {

  <span class="hljs-keyword">public</span> contributeStyles(themeId: <span class="hljs-built_in">string</span>, themeDocument: IThemeDocument, cssRules: <span class="hljs-built_in">string</span>[]): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">let</span> theme = <span class="hljs-keyword">new</span> Theme(themeId, themeDocument);
    theme.getSettings().forEach((s: IThemeSetting, index, arr) =&gt; {
      <span class="hljs-comment">// @martin TS(2.0.2) - s.scope is already a string[] so no need for all this checking.</span>
      <span class="hljs-comment">// However will add a cast at split to keep semantic in case s.scope is wrongly typed.</span>
      <span class="hljs-keyword">let</span> scope: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[] = s.scope;
      <span class="hljs-keyword">let</span> settings = s.settings;
      <span class="hljs-keyword">if</span> (scope &amp;&amp; settings) {
        <span class="hljs-keyword">let</span> rules = <span class="hljs-built_in">Array</span>.isArray(scope) ? &lt;<span class="hljs-built_in">string</span>[]&gt;scope : (scope as <span class="hljs-built_in">string</span>).split(<span class="hljs-string">','</span>);
        <span class="hljs-keyword">let</span> statements = <span class="hljs-keyword">this</span>._settingsToStatements(settings);
        rules.forEach(rule =&gt; {
          rule = rule.trim().replace(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">'.'</span>); <span class="hljs-comment">// until we have scope hierarchy in the editor dom: replace spaces with .</span>

          cssRules.push(<span class="hljs-string">`.monaco-editor.<span class="hljs-subst">${theme.getSelector()}</span> .token.<span class="hljs-subst">${rule}</span> { <span class="hljs-subst">${statements}</span> }`</span>);
        });
      }
    });
  }

  <span class="hljs-keyword">private</span> _settingsToStatements(settings: IThemeSettingStyle): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">let</span> statements: <span class="hljs-built_in">string</span>[] = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> settingName <span class="hljs-keyword">in</span> settings) {
      <span class="hljs-keyword">const</span> value = settings[settingName];
      <span class="hljs-keyword">switch</span> (settingName) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'foreground'</span>:
          <span class="hljs-keyword">let</span> foreground = <span class="hljs-keyword">new</span> Color(value);
          statements.push(<span class="hljs-string">`color: <span class="hljs-subst">${foreground}</span>;`</span>);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'background'</span>:
          <span class="hljs-comment">// do not support background color for now, see bug 18924</span>
          <span class="hljs-comment">//let background = new Color(value);</span>
          <span class="hljs-comment">//statements.push(`background-color: ${background};`);</span>
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'fontStyle'</span>:
          <span class="hljs-keyword">let</span> segments = value.split(<span class="hljs-string">' '</span>);
          segments.forEach(s =&gt; {
            <span class="hljs-keyword">switch</span> (s) {
              <span class="hljs-keyword">case</span> <span class="hljs-string">'italic'</span>:
                statements.push(<span class="hljs-string">`font-style: italic;`</span>);
                <span class="hljs-keyword">break</span>;
              <span class="hljs-keyword">case</span> <span class="hljs-string">'bold'</span>:
                statements.push(<span class="hljs-string">`font-weight: bold;`</span>);
                <span class="hljs-keyword">break</span>;
              <span class="hljs-keyword">case</span> <span class="hljs-string">'underline'</span>:
                statements.push(<span class="hljs-string">`text-decoration: underline;`</span>);
                <span class="hljs-keyword">break</span>;
            }
          });
      }
    }
    <span class="hljs-keyword">return</span> statements.join(<span class="hljs-string">' '</span>);
  }
}
</code></pre>
<p>我们再来回顾一下上文<code>tmTheme</code>文件每一项<code>scope</code>的配置内容：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Template Expression<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>scope<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>template.expression<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>settings<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>foreground<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>#23C4FA<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
</code></pre>
<p>其中第一项<code>name</code>表示的是我们给该规则起的名称；<code>scope</code>则是适用的<code>scope</code>，如果多个可以用逗号分隔，比如<code>User-defined constant</code>的<code>scope</code>值就为<code>constant.character, constant.other</code>；<code>settings</code>则是具体的样式信息，比如颜色值。</p>
<p>从源码中可以看出，支持的样式只有<code>foreground</code>和<code>fontStyle</code>，而<code>background</code>则从注释中可以看出由于某原因导致 Visual Studio Code 暂时不支持。</p>
<p><code>scope</code>值为<code>template.expression</code>则可被认为是 CSS 类选择器<code>token.template.expression</code>，在前文的 Developer Tools 的演示视频中，模板字符串的变量名在渲染时其 HTML 为<code>&lt;span class=&quot;token block ts meta variable other readwrite string function arrow new expr template expression&quot;&gt;...&lt;/span&gt;</code>，如果我们熟悉 CSS 的话应该能一眼就看出来<code>.token.template.expression</code>是会匹配到该标签的。所以，我们可以简单地把<code>scope</code>当作是 CSS 的类选择器。</p>
<p>需要注意的是，如果我们在定义<code>scope</code>时写得不够详细，可能会错误地匹配到其他元素，致使调好了一部分，另一部分却被调坏了，所以要做得完美也并非易事。</p>
<h2><a id="_357"></a>发布到扩展商店</h2>
<p>要将扩展发布到扩展商店以便让更多人可以使用到，我们需要借助<code>vsce</code>命令行工具，可以参考文档<a href="https://code.visualstudio.com/docs/tools/vscecli">vsce - Publishing Tool Reference</a>。以下是其基本步骤：</p>
<ul>
<li>安装 vsce 命令行工具。执行命令<code>npm install -g vsce</code></li>
<li>注册 Visual Studio Team Services 账号，并获取到 Access Token</li>
<li>创建 Publisher。执行命令<code>vsce create-publisher</code></li>
<li>登录到 Publisher。执行命令<code>vsce login</code></li>
<li>发布扩展。执行命令<code>vsce publish</code></li>
</ul>
<p>详细操作步骤建议参考相应的官方文档。</p>
<h2><a id="_370"></a>后记</h2>
<p>本文并没有详细到手把手教地去讲解如何打造一款 Visual Studio Code 颜色主题，仅仅是提到了几个我在折腾过程中认为比较关键，而又很难通过文档去查到的要点。爱折腾是程序员的天性，希望本文能让爱折腾的你少走一些弯路，把喜爱的 Visual Studio Code 玩出花来。</p>
<h2><a id="_375"></a>相关链接</h2>
<ul>
<li><a href="https://code.visualstudio.com/docs/customization/themes#_adding-a-new-theme">Visual Studio Code Themes - Adding a new Theme</a></li>
<li><a href="http://www.apeth.com/nonblog/stories/textmatebundle.html">Writing a TextMate Grammar: Some Lessons Learned</a></li>
<li><a href="https://code.visualstudio.com/docs/tools/vscecli">vsce - Publishing Tool Reference</a></li>
<li><a href="https://github.com/leizongmin/lei-theme-vscode">Lei Theme for Visual Studio Code</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-11/how-to-make-vscode-color-theme.html</link><guid isPermaLink="true">http://morning.work/page/2016-11/how-to-make-vscode-color-theme.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Sun, 20 Nov 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[基于 generator 与 promise 的异步编程解决方案]]></title><description><![CDATA[<h2><a id="_2"></a>前言</h2>
<p>一直以来，“异步”编程问题一直困扰着广大的 JavaScript 开发者。近年来出现了各种异步解决方案，从基于最原始的<code>callback</code>方式的<code>async</code>函数，到<code>promise</code>标准，再到基于<code>generator</code>的<code>co</code>库，以及即将纳入 ES7 标准的<code>async function / await</code>语法，但是由于各种现实的原因，它们的表现并不尽人意。</p>
<p>原始的<code>callback</code>方式简单明了，不需要过多的依赖，但是在异步逻辑较复杂的场景下写出来的程序并不太直观，就我个人的使用经验而言，尽管多年来已经练就了一身可以穿梭在各种嵌套回调的“乱码”之中，每次重新看这些代码都头疼不已。</p>
<p>JavaScript 异步解决方案都是朝着更直观（跟写同步代码一样）的方向发展的，比如近来呼声最高的<code>async function / await</code>语法，直接从语言层面解决问题，使用体验那是好得没法说的。但是，这是一个 ES7 （ES2017，即明年才会发布的 ES 标准）标准的语法，目前并没有得到各 JavaScript 引擎的内置支持。虽然我们照样可以使用 Babel 神器来将它编译成 ES5 / ES6 的语法，然后运行在现有的 JavaScript 引擎之上。然而使用 Babel 编译后的代码并不易于维护，首先这些代码修改后要先经过一次编译，当我们在生产环境上执行编译后的代码时，很难准确地定位到源码出错的位置。另外，根据最新可靠的消息，Node  v7 版本会在语法层面上支持<code>async function / await</code>语法，但该版本原计划于 9 月 30 号发布却跳票了，而且按照往年的惯例，也要在 1 年后发布的 Node v8 LTS 版本上才会正式支持该语法，这对于追求稳定的企业来说还需要一个漫长的等待过程。</p>
<h2><a id="_Babel__async_function__await___10"></a>通过 Babel 编译 async function / await  语法解决方案</h2>
<p>利用<code>async function / await</code>语法，我们可以很直观地书写异步程序：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// sleep 函数，返回一个 Promise 对象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(resolve, ms);
  });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 循环 100 次</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-comment">// 等待 100ms 再返回</span>
    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">100</span>);
  }
}
</code></pre>
<p>但由于目前的 JavaScript 引擎均不支持该语法，需要通过 Babel 之类的工具编译成 ES6 语法后的程序是这样的：</p>
<pre><code class="language-javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_asyncToGenerator</span>(<span class="hljs-params">fn</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> gen = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{ <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">key, arg</span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">var</span> info = gen[key](arg); <span class="hljs-keyword">var</span> value = info.value; } <span class="hljs-keyword">catch</span> (error) { reject(error); <span class="hljs-keyword">return</span>; } <span class="hljs-keyword">if</span> (info.done) { resolve(value); } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(value).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{ <span class="hljs-keyword">return</span> step(<span class="hljs-string">"next"</span>, value); }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{ <span class="hljs-keyword">return</span> step(<span class="hljs-string">"throw"</span>, err); }); } } <span class="hljs-keyword">return</span> step(<span class="hljs-string">"next"</span>); }); }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(resolve, ms);
  });
}

<span class="hljs-keyword">let</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> ref = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">yield</span> sleep(<span class="hljs-number">100</span>);
        }
    });

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> ref.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    };
}();
</code></pre>
<p>从编译后的代码来看，虽然在前面增加了一坨<code>_asyncToGenerator</code>函数的代码，但<code>test</code>函数的代码还是能看出程序原来的结构。通过以上凌乱的代码我们还是可以看出，其内部是通过<code>generator function</code>实现的，在外层返回一个<code>promise</code>对象。</p>
<h2><a id="_generator__promise__61"></a>基于 generator 与 promise 的解决方案</h2>
<p>首先我们要达成这样的共识：<strong><code>async function / await</code>语法是未来的主流，但是要让主流的 JavaScript 引擎支持该语法还需要一个很漫长的过程，而现在我们需要找到一种替代的方法，而这种方法又能尽量保持与<code>async function / await</code>非常相近，在以后可以很轻易地替换成新的用法。</strong> 基于以上的考虑可以得出以下结论：</p>
<ul>
<li>异步函数执行后需要返回一个<code>promise</code>对象（<code>async function</code>执行后返回的也是一个<code>promise</code>对象）</li>
<li>使用<code>generator function</code>，<code>yield</code>代替<code>await</code>，这样可以最大程度上保持程序逻辑结构不变（<code>generator function</code>从 Node v4 已经开始支持，经过两年多的使用验证，性能和可靠性性上还是有保证的）</li>
</ul>
<p>基于以上两点的考虑，我们可以假设新的异步代码应该是这样的：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// sleep 函数，返回一个 Promise 对象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(resolve, ms);
  });
}

<span class="hljs-comment">// 通过 coroutine 来包装异步函数</span>
<span class="hljs-keyword">const</span> test = coroutine(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 循环 100 次</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-comment">// 等待 100ms 再返回</span>
    <span class="hljs-keyword">yield</span> sleep(<span class="hljs-number">100</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i=%s'</span>, i);
  }
  <span class="hljs-comment">// 返回执行 sleep 次数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;
});

 <span class="hljs-comment">// 执行函数，其返回一个 Promise 对象</span>
test()
  .then(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'执行了%s 次 sleep'</span>, i))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'出错'</span>, err));
</code></pre>
<p>对比直接使用<code>async function / await</code>语法，我们发现只是在声明异步函数和<code>yield</code>这两行写法不同，它可以在 Node v4 及更高版本上可直接执行，并且可以直接在源码上进行调试。以下是上文的程序在 Visual Studio Code 上进行调试的界面（<code>coroutine</code>函数的实现将在下文讲解）：</p>
<p><img src="../../images/2016-10/debug_coroutine.png" alt="调试 coroutine 程序"></p>
<h2><a id="_coroutine__102"></a>实现一个简单的 coroutine 函数</h2>
<p>本小节只是是为了通过演示如何动手写一个<code>coroutine</code>函数来了解其中的原理，实际久经考验的<code>bluebird</code>模块和<code>co</code>模块已经实现了此功能，下一小节将会讲解基于这些现成模块的使用方法。</p>
<p>首先我们需要了解一下 Generator 的概念。Generator 中文名称为“生成器”，通过<code>function*</code>来定义的函数称之为“生成器函数”（<code>generator function</code>），而生成器函数执行后返回的是一个生成器对象（<code>Generator</code>），这个生成器对象包含了几个方法，其中一个重要的方法是<code>next()</code>，我们可以通过不断地调用<code>next()</code>来取得在生成器中<code>yield</code>出来的值，生成器是否已执行结束则可以通过返回值的<code>done</code>属性来判断。</p>
<p>生成器有一个特点就是它可以中断函数的执行，每次执行<code>yield</code>语句之后，函数即暂停执行，直到调用返回的生成器对象的<code>next()</code>函数它才会继续执行。以下是一个简单的例子：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">// 生成器函数，可以生成指定数量的数字</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genNumbers</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">yield</span> i;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">'ok'</span>;
}

<span class="hljs-comment">// 执行生成器函数</span>
<span class="hljs-keyword">const</span> gen = genNumbers(<span class="hljs-number">10</span>);
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-comment">// 执行 next()方法取下一个数字</span>
  <span class="hljs-keyword">const</span> ret = gen.next();
  <span class="hljs-comment">// 打印结果</span>
  <span class="hljs-built_in">console</span>.log(ret);
  <span class="hljs-keyword">if</span> (ret.done) {
    <span class="hljs-comment">// 如果 done=true 则表示生成器执行结束</span>
    <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>);
</code></pre>
<p>上面的代码执行后的结果如下：</p>
<pre><code>{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: 4, done: false }
{ value: 5, done: false }
{ value: 6, done: false }
{ value: 7, done: false }
{ value: 8, done: false }
{ value: 9, done: false }
{ value: 10, done: false }
{ value: 'ok', done: true }
done
</code></pre>
<p>说明：</p>
<ul>
<li>每次执行<code>next()</code>都会返回一个包含<code>{ value, done }</code>两个属性的对象，其中<code>value</code>是该次<code>yield</code>返回的值，<code>done</code>表示是否执行结束</li>
<li>最后一次返回的值是生成器函数内<code>return</code>语句返回的值</li>
</ul>
<p>从上文的代码可知，只有我们执行<code>gen.next()</code>时生成器才会继续执行。如果还不太确定，我们可以尝试把它换成异步的执行方式：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">// 生成器函数，可以生成指定数量的数字</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genNumbers</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">yield</span> i;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">'ok'</span>;
}

<span class="hljs-comment">// 执行生成器函数</span>
<span class="hljs-keyword">const</span> gen = genNumbers(<span class="hljs-number">10</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 执行 next()方法取下一个数字</span>
  <span class="hljs-keyword">const</span> ret = gen.next();
  <span class="hljs-comment">// 打印结果</span>
  <span class="hljs-built_in">console</span>.log(ret);
  <span class="hljs-keyword">if</span> (ret.done) {
    <span class="hljs-comment">// 如果 done=true 则表示生成器执行结束</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 500ms 后继续执行</span>
    setTimeout(next, <span class="hljs-number">500</span>);
  }
}

next();
</code></pre>
<p>如无意外，执行上面的代码后我们应该能看到每隔 0.5 秒会打印出一行结果，直到 5 秒后程序才执行结束，而打印的结果跟之前的一模一样。</p>
<p>现在我们不妨假设，在我们的异步函数中，通过<code>yield</code>返回一个<code>promise</code>对象，然后等待<code>promise</code>执行回调后再执行<code>gen.next()</code>方法，如此循环，是不是就可以实现异步流程控制呢？</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ret = gen.next();
<span class="hljs-keyword">if</span> (ret.done) {
  <span class="hljs-comment">// 执行结束</span>
  resolve(ret.value);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 等待 promise 回调</span>
  ret.value
    .than(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ret.next())
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err));
}
</code></pre>
<p>以下是这个简单<code>coroutine</code>函数的代码：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">// 判断是否为 Promise 对象，再次只简单判断该对象是否包含 then 和 catch 方法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPromise</span>(<span class="hljs-params">p</span>) </span>{
  <span class="hljs-keyword">return</span> p &amp;&amp; <span class="hljs-keyword">typeof</span> p.then === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> p.catch === <span class="hljs-string">'function'</span>;
}

<span class="hljs-comment">// coroutine 函数，接收一个 generator function 作为参数，返回一个新的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coroutine</span>(<span class="hljs-params">genFn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 函数执行结果是一个 promise 对象</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 首先执行 generator function，它会返回一个 Generator 对象</span>
      <span class="hljs-keyword">const</span> gen = genFn.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);
      <span class="hljs-keyword">let</span> ret;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-comment">// 执行.next()返回 yield 返回的值</span>
        <span class="hljs-comment">// next()可以接收一个参数，用作在生成器函数里面 yield 语句的返回值</span>
        ret = gen.next(value);
        <span class="hljs-comment">// 如果 done=true 则表示结束</span>
        <span class="hljs-keyword">if</span> (ret.done) {
          <span class="hljs-keyword">return</span> resolve(ret.value);
        }
        <span class="hljs-comment">// 如果返回的值不是 promise 则报错</span>
        <span class="hljs-keyword">if</span> (!isPromise(ret.value)) {
          <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'You may only yield a promise, but the following object was passed: '</span> + <span class="hljs-built_in">String</span>(ret.value)));
        }
        <span class="hljs-comment">// 等待 promise 执行结果</span>
        ret.value.then(next).catch(reject);
      }
      <span class="hljs-comment">// 开始执行</span>
      next();
    });
  };
}
</code></pre>
<p>说明：此代码仅用作演示，尽管通常情况下它也能正确地运行，但是并没有考虑性能问题和一些异常情况，生产环境下请使用稳定的 NPM 模块。</p>
<h2><a id="_bluebird__coroutine__251"></a>使用 bluebird 模块的 coroutine 函数</h2>
<p>使用前先执行以下命令安装<code>bluebird</code>模块：</p>
<pre><code class="language-bash">$ npm install bluebird --save
</code></pre>
<p>以下是基于<code>bluebird</code>模块的<code>coroutine</code>函数的使用方法：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);

<span class="hljs-keyword">const</span> test = <span class="hljs-built_in">Promise</span>.coroutine(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">n, ms</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i=%s'</span>, i);
    <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.delay(ms);
  }
  <span class="hljs-keyword">return</span> n;
});

test(<span class="hljs-number">10</span>, <span class="hljs-number">500</span>)
  .then(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'执行结束，n=%s'</span>, n))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'执行出错：'</span>, err));
</code></pre>
<p>说明：</p>
<ul>
<li><code>bluebird</code>自带了<code>delay()</code>函数，功能与上文实现的<code>sleep()</code>相同</li>
</ul>
<h2><a id="_co__285"></a>使用 co 模块</h2>
<p>使用前先执行以下命令安装<code>co</code>模块：</p>
<pre><code class="language-bash">$ npm install co --save
</code></pre>
<p>以下是基于<code>co</code>模块的简单使用方法：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(resolve, ms);
  });
}

<span class="hljs-keyword">const</span> test = co.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">n, ms</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i=%s'</span>, i);
    <span class="hljs-keyword">yield</span> sleep(ms);
  }
  <span class="hljs-keyword">return</span> n;
});

test(<span class="hljs-number">10</span>, <span class="hljs-number">500</span>)
  .then(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'执行结束，n=%s'</span>, n))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'执行出错：'</span>, err));
</code></pre>
<p>实际上<code>bluebird</code>模块和<code>co</code>模块还是有区别的：<code>bluebird</code>模块只支持<code>yield</code>一个<code>promise</code>对象，而<code>co</code>模块可以支持<code>promise</code>，<code>generator</code>，<code>array</code>，<code>object</code>和<code>Thunk</code>函数，可在异步函数内实现多个并发异步任务，比前者复杂得多。</p>
<h2><a id="_321"></a>后记</h2>
<p>回想在过去的一年多时间里，我确实是对以使用<code>generator</code>的<code>co</code>模块来解决异步问题是有些许偏见，也曾喷过某<strong>月饼云</strong>的 Node.js SDK 竟然不支持<code>callback</code>而是直接返回一个<code>generator</code>。究其原因，我深以为有以下几点：</p>
<ul>
<li>早期版本的<code>co</code>封装并不是返回一个<code>promise</code>对象，再加上大多数介绍<code>co</code>的文章讲的基本上都是<code>thunks</code>的概念，这对初使用<code>co</code>的人是相当恶心的</li>
<li><code>co</code> 的<code>yield</code>支持的功能实在太丰 fu 富 za 了，而我更喜欢简单的</li>
<li>在 Node v4 发布之前，使用 Generator 还需要开启 Harmony 特性</li>
<li>从 Node v4 开始，直接支持了 Generator 和 Promise</li>
</ul>
<p>最后一句，JavaScript 的世界变化实在太快了。</p>
<h2><a id="_334"></a>相关链接</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">Generator 函数的含义与用法</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">生成器</a></li>
<li><a href="http://www.jianshu.com/p/d6ac6b0b41d6">你不懂 JS: 异步与性能 第四章: Generator（上）</a></li>
<li><a href="http://www.jianshu.com/p/e6f6766cba13">你不懂 JS: 异步与性能 第四章: Generator（下）</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/co.html">co 函数库的含义和用法</a></li>
<li><a href="http://lifemap.in/koa-co-and-coroutine/">Koa, co and coroutine</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20794401">生成器（Generator）——《实战 ES2015》章节试读</a></li>
</ul>
]]></description><link>http://morning.work/page/maintainable-nodejs/asynchronous-programming.html</link><guid isPermaLink="true">http://morning.work/page/maintainable-nodejs/asynchronous-programming.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 13 Oct 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[利用 ESLint 检查代码质量]]></title><description><![CDATA[<blockquote>
<p>其实很早的时候就想尝试 ESLint 了，但是很多次都是玩了一下就觉得这东西巨复杂，<strong>一执行检查就是满屏的<code>error</code>，简直是不堪入目，遂放弃</strong>。直到某天终于下定决心深入看了文档，才发现其实挺简单的，只是当时没有看到合适入门教程而已。我相信很多人也有着跟我一样的经历，所以希望将自己的踩坑心得记录下来，让后来者更轻易地掌握 ESLint 的使用，因为它确实是个好东西。</p>
</blockquote>
<p>JavaScript 是一门神奇的动态语言，它在带给我们编程的灵活性的同时也悄悄埋下了一些地雷。除了基本的语法错误能在程序一启动的时候被检测到之外，很多隐含的错误都是在运行的时候才突然地蹦出来。除非你的程序有着 100% 的测试覆盖率，否则说不定哪天就会因为一个<code>xxx is undefined</code>而导致程序崩溃，而为了避免这样的错误可能你只需要在提交代码的时候用工具静态分析一下，仅此而已。</p>
<p>ESLint 是一个插件化的 javascript 代码检测工具，它可以用于检查常见的 JavaScript 代码错误，也可以进行代码风格检查，这样我们就可以根据自己的喜好指定一套 ESLint 配置，然后应用到所编写的项目上，从而实现<strong>辅助编码规范的执行，有效控制项目代码的质量</strong>。</p>
<h2><a id="_9"></a>手把手入门</h2>
<p>在开始使用 ESLint 之前，我们需要通过 NPM 来安装它：</p>
<pre><code class="language-bash">$ npm install -g eslint
</code></pre>
<p>我从 Gist 上找到了自己几年前写的一个小函数，将其保存为文件<code>merge.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> ret = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">arguments</span>) {
    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">arguments</span>[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j <span class="hljs-keyword">in</span> m) ret[j] = m[j];
  }
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-built_in">console</span>.log(merge({<span class="hljs-attr">a</span>: <span class="hljs-number">123</span>}, {<span class="hljs-attr">b</span>: <span class="hljs-number">456</span>}));
</code></pre>
<p>然后执行<code>node merge.js</code>确保它是可以正确运行的（输出结果为<code>{ a: 123, b: 456 }</code>）。</p>
<p>接着我们执行以下命令来使用 ESLint 检查：</p>
<pre><code class="language-bash">$ eslint merge.js
</code></pre>
<p>可以看到，没有任何输出结果。这是因为我们没有指定任何的配置，除非这个文件是有语法错误，否则应该是不会有任何提示的。现在我们先使用内置的<code>eslint:recommended</code>配置，它包含了一系列核心规则，能报告一些常见的问题。</p>
<p>首先新建 ESLint 配置文件<code>.eslintrc.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'eslint:recommended'</span>,
};
</code></pre>
<p>重新执行<code>eslint merge.js</code>可以看到输出了 2 个错误：</p>
<pre><code>/example/merge.js
  10:1  error  Unexpected console statement  no-console
  10:1  error  'console' is not defined      no-undef

✖ 2 problem (2 error, 0 warnings)
</code></pre>
<p>这两条提示信息还是足够我们搞清楚是怎么回事的：</p>
<ul>
<li><strong>Unexpected console statement no-console</strong> - 不能使用<code>console</code></li>
<li><strong>'console' is not defined     no-undef</strong> - <code>console</code>变量未定义，不能使用未定义的变量</li>
</ul>
<p>针对第 1 条提示，我们可以禁用<code>no-console</code>规则。将配置文件<code>.eslintrc.js</code>改为这样：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'eslint:recommended'</span>,
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-string">'no-console'</span>: <span class="hljs-string">'off'</span>,
  },
};
</code></pre>
<p>说明：配置规则写在<code>rules</code>对象里面，<code>key</code>表示规则名称，<code>value</code>表示规则的配置，具体说明见下文。</p>
<p>重新执行检查还是提示<code>no-undef</code>：</p>
<pre><code>/example/merge.js
  10:1  error  'console' is not defined  no-undef

✖ 1 problem (1 error, 0 warnings)
</code></pre>
<p>这是因为 JavaScript 有很多种运行环境，比如常见的有浏览器和 Node.js，另外还有很多软件系统使用 JavaScript 作为其脚本引擎，比如 PostgreSQL 就支持使用 JavaScript 来编写存储引擎，而这些运行环境可能并不存在<code>console</code>这个对象。另外在浏览器环境下会有<code>window</code>对象，而 Node.js 下没有；在 Node.js 下会有<code>process</code>对象，而浏览器环境下没有。</p>
<p>所以在配置文件中我们还需要指定程序的目标环境：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'eslint:recommended'</span>,
  <span class="hljs-attr">env</span>: {
    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-string">'no-console'</span>: <span class="hljs-string">'off'</span>,
  },
};
</code></pre>
<p>再重新执行检查时，已经没有任何提示输出了，说明<code>merge.js</code>已经完全通过了检查。</p>
<h3><a id="_105"></a>配置文件</h3>
<p>ESLint 还可以在项目的<code>package.json</code>文件中指定配置，直接将上文中的<code>module.exports</code>的值写到<code>eslintConfig</code>里面即可：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-package"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,
  <span class="hljs-attr">"eslintConfig"</span>: {
    <span class="hljs-attr">"extends"</span>: <span class="hljs-string">"eslint:recommended"</span>,
    <span class="hljs-attr">"env"</span>: {
      <span class="hljs-attr">"node"</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">"rules"</span>: {
      <span class="hljs-attr">"no-console"</span>: <span class="hljs-string">"off"</span>
    }
  }
}
</code></pre>
<p>另外还可以在执行<code>eslint</code>命令时通过命令行参数来指定，详细文档可以参考这里：<a href="http://eslint.cn/docs/user-guide/configuring">Configuring ESLint - 配置</a></p>
<h3><a id="_127"></a>规则</h3>
<p>每条规则有 3 个等级：<code>off</code>、<code>warn</code>和<code>error</code>。<code>off</code>表示禁用这条规则，<code>warn</code>表示仅给出警告，并不会导致检查不通过，而<code>error</code>则会导致检查不通过。</p>
<p>有些规则还带有可选的参数，比如<code>comma-dangle</code>可以写成<code>[ &quot;error&quot;, &quot;always-multiline&quot; ]</code>；<code>no-multi-spaces</code>可以写成<code>[ &quot;error&quot;, { exceptions: { &quot;ImportDeclaration&quot;: true }}]</code>。</p>
<p>规则的详细说明文档可以参考这里：<a href="http://eslint.cn/docs/rules/">Rules - 规则</a></p>
<h2><a id="_136"></a>使用共享的配置文件</h2>
<p>上文我们以<code>eslint:recommended</code>为基础配置，然后在此之上修改<code>no-console</code>这条规则。而在大多数时候，我们可能会根据自己个人或团队的习惯，定制更多的规则，比如限定缩进是 2 个空格和使用单引号的字符串等。而如果每一个项目都要这样写到<code>.eslintrc.js</code>文件上，管理起来会比较麻烦。</p>
<p>我们可以将定义好规则的<code>.eslintrc.js</code>文件存储到一个公共的位置，比如<code>public-eslintrc.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'eslint:recommended'</span>,
  <span class="hljs-attr">env</span>: {
    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-string">'no-console'</span>: <span class="hljs-string">'off'</span>,
    <span class="hljs-string">'indent'</span>: [ <span class="hljs-string">'error'</span>, <span class="hljs-number">2</span> ],
    <span class="hljs-string">'quotes'</span>: [ <span class="hljs-string">'error'</span>, <span class="hljs-string">'single'</span> ],
  },
};
</code></pre>
<p>然后将原来的<code>.eslintrc.js</code>文件改成这样：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'./public-eslintrc.js'</span>,
};
</code></pre>
<p>为了验证这样的修改是否生效，将<code>merge.js</code>中的<code>var ret = {};</code>这一行前面多加一个空格，再执行 ESLint 检查：</p>
<pre><code>/example/merge.js
  2:4  error  Expected indentation of 2 space characters but found 3  indent

✖ 1 problem (1 error, 0 warnings)
</code></pre>
<p>这时候提示的是缩进只能为 2 个空格，而文件的第 2 行却发现了 3 个空格，说明公共配置文件<code>public-eslintrc.js</code>已经生效了。</p>
<p>我们还可以使用已经发布到 NPM 上的 ESLint 配置，这些配置的模块名一般以<code>eslint-config-</code>为前缀，比如我在学习 ESLint 时自己编写的一个配置名为<code>eslint-config-lei</code>。要使用这个配置，先执行以下命令安装它：</p>
<pre><code class="language-bash">$ npm install -g eslint-config-lei
</code></pre>
<p><strong>注意：由于我们的<code>eslint</code>命令是全局安装的，所有用到的<code>eslint-config-*</code>模块也必须全局安装，否则将无法正确载入。这是一个已知的 Bug，参考这里：<a href="https://github.com/eslint/eslint/issues/4822#issuecomment-167600953">Error: Cannot read config package for shareable config using global eslint #4822</a></strong></p>
<p>然后将<code>.eslintrc.js</code>文件改成这样：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'lei'</span>,
};
</code></pre>
<p>再执行 ESLint 检查，可以看到输出如下的提示：</p>
<pre><code>/example/merge.js
   1:15  warning  Unexpected space before function parentheses  space-before-function-paren
   2:3   error    Unexpected var, use let or const instead      no-var
   3:8   error    Unexpected var, use let or const instead      no-var
   4:5   error    Unexpected var, use let or const instead      no-var
   5:10  error    Unexpected var, use let or const instead      no-var
  10:19  warning  A space is required after '{'                 object-curly-spacing
  10:26  warning  A space is required before '}'                object-curly-spacing
  10:29  warning  A space is required after '{'                 object-curly-spacing
  10:36  warning  A space is required before '}'                object-curly-spacing

✖ 9 problems (4 errors, 5 warnings)
</code></pre>
<p>ESLint 配置文件中的<code>extends</code>还可以用来指定各种来源的配置引用，具体说明可以参考以下链接：</p>
<ul>
<li><a href="http://eslint.cn/docs/user-guide/configuring#using-a-shareable-configuration-package">Using a shareable configuration package - 使用共享的模块</a></li>
<li><a href="http://eslint.cn/docs/user-guide/configuring#using-the-configuration-from-a-plugin">Using the configuration from a plugin - 使用插件</a></li>
<li><a href="http://eslint.cn/docs/user-guide/configuring#using-a-configuration-file">Using a configuration file - 使用配置文件</a></li>
<li><a href="http://eslint.cn/docs/user-guide/configuring#using-eslintall">Using &quot;eslint:all&quot; - 使用&quot;eslint:all&quot;</a></li>
</ul>
<h2><a id="_216"></a>代码格式化</h2>
<p>在<a href="http://eslint.cn/docs/rules/">ESLint 规则列表</a>页面，我们发现有些规则的旁边会带有一个<strong>橙色扳手图标</strong>，表示在执行<code>eslint</code>命令时指定<code>--fix</code>参数可以<strong>自动修复</strong>该问题。</p>
<p>接着上文使用<code>eslint-config-lei</code>配置的检查，我们尝试在执行检查时添加<code>--fix</code>参数：</p>
<pre><code class="language-bash">$ eslint merge.js --fix
</code></pre>
<p>执行完毕，没有发现任何提示。再打开<code>merge.js</code>文件发现已经变成了这样：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> ret = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">arguments</span>) {
    <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">arguments</span>[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> j <span class="hljs-keyword">in</span> m) ret[j] = m[j];
  }
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-built_in">console</span>.log(merge({ <span class="hljs-attr">a</span>: <span class="hljs-number">123</span> }, { <span class="hljs-attr">b</span>: <span class="hljs-number">456</span> }));
</code></pre>
<p>主要的变化有以下三部分：</p>
<ul>
<li>声明函数时，函数名与参数列表的空格不见了：<code>merge ()</code>修改为<code>merge()</code></li>
<li><code>var</code>声明的变量变成了<code>const</code>声明：<code>var ret = {}</code>修改为<code>const ret = {}</code></li>
<li>对象的内容与花括号之间增加了空格：<code>{a: 123}</code>修改为<code>{ a: 123 }</code></li>
</ul>
<p>我们可以利用这个特性来自动格式化项目代码，这样就可以保证代码书写风格的统一。</p>
<h2><a id="_250"></a>发布自己的配置</h2>
<p>前文关于「共享的配置文件」一小节已经提到，可以在<code>extends</code>中指定一个文件名，或者一个<code>eslint-config-</code>开头的模块名。为了便于共享，一般推荐将其发布成一个 NPM 模块。</p>
<p>其原理就是在载入模块时输出原来<code>.eslintrc.js</code>的数据。比如我们可以创建一个模块<code>eslint-config-my</code>用于测试。</p>
<p>新建文件<code>eslint-config-my/index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'eslint:recommended'</span>,
  <span class="hljs-attr">env</span>: {
    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">es6</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-string">'no-console'</span>: <span class="hljs-string">'off'</span>,
    <span class="hljs-string">'indent'</span>: [ <span class="hljs-string">'error'</span>, <span class="hljs-number">2</span> ],
    <span class="hljs-string">'quotes'</span>: [ <span class="hljs-string">'error'</span>, <span class="hljs-string">'single'</span> ],
  },
};
</code></pre>
<p>再新建文件<code>eslint-config-my/package.json</code>：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"eslint-config-my"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,
  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>
}
</code></pre>
<p>为了能让<code>eslint</code>正确载入这个模块，我们需要执行<code>npm link</code>将这个模块链接到本地全局位置：</p>
<pre><code>$ npm link eslint-config-my
</code></pre>
<p>然后将文件<code>.eslintrc.js</code>改成这样：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">extends</span>: <span class="hljs-string">'my'</span>,
};
</code></pre>
<p>说明：在<code>extends</code>中，<code>eslint-config-my</code>可简写为<code>my</code>。</p>
<p>在执行<code>eslint merge.js</code>检查，可看到没有任何错误提示信息，说明<code>eslint</code>已经成功载入了<code>eslint-config-my</code>的配置。如果我们使用<code>npm publish</code>将其发布到 NPM 上，那么其他人通过<code>npm install eslint-config-my</code>即可使用我们共享的这个配置。</p>
<p>另外可以参考我自己写的一个 ESLint 配置模块：<a href="https://github.com/leizongmin/eslint-config-lei">eslint-config-lei</a></p>
<p>关于共享 ESLint 配置的详细文档可参考：<a href="http://eslint.cn/docs/developer-guide/shareable-configs">Shareable Configs - 可共享的配置</a></p>
<h2><a id="_306"></a>例外情况</h2>
<p>尽管我们在编码时怀着<strong>严格遵守规则</strong>的美好愿景，而<strong>凡事总有例外</strong>。定立 ESLint 规则的初衷是为了避免自己犯错，但是我们也要避免不顾实际情况而将其搞得太过于形式化，本末倒置。</p>
<p>ESLint 提供了多种临时禁用规则的方式，比如我们可以通过一条<code>eslint-disable-next-line</code>备注来使得下一行可以跳过检查：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// eslint-disable-next-line</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
</code></pre>
<p>在上面的示例代码中，<code>var a = 123</code>不会受到检查，而<code>var b = 456</code>则右恢复检查，在上文我们使用的<code>eslint-config-lei</code>的配置规则下，由于不允许使用<code>var</code>声明变量，则<code>var b</code>这一行会报告一个<code>error</code>。</p>
<p>我们还可以通过成对的<code>eslint-enable</code>和<code>eslint-disable</code>备注来禁用对某一段代码的检查，但是稍不小心少写了一个<code>eslint-disable</code>就可能会导致后面所有文件的检查都被禁用，所以我并不推荐使用。</p>
<p>详细使用方法可以参考文档：<a href="http://eslint.cn/docs/user-guide/configuring#disabling-rules-with-inline-comments">Disabling Rules with Inline Comments - 使用行内注释禁用规则</a></p>
<h2><a id="_325"></a>总结</h2>
<p>刚开始接触 ESLint 时觉得太难，是因为过太过于<strong>迷信权威</strong>。比如 Airbnb 公司的 JavaScript 风格，在 GitHub 上受到了很大的好评，其实我自己也非常认可这样的编码风格。但每个团队都会根据自己的的<strong>实际情况</strong>来<strong>定制</strong>不同的东西，我们并<strong>不能随便照搬</strong>过来。所以当使用<code>eslint-config-airbnb</code>这个配置进行 ESLint 检查时，满屏都是<code>error</code>和<code>warning</code>，从而觉得这东西根本没啥卵用。</p>
<p>另外我也犯了「大忌」：直接使用<code>eslint-config-airbnb</code>这种某个公司高度定制化的配置，而不是<code>eslint:recommended</code>这样保守的。而且是直接用来检查整个项目好几十个 JS 文件，可想而知那是怎样的画面（本文最后版本的<code>merge.js</code>文件使用<code>airbnb</code>的配置，总共 12 行的代码就提示了 8 个问题：<em>✖ 8 problems (7 errors, 1 warning)</em>）。</p>
<p>本文的目的是让读者以一个比较低的姿态开始接触 ESLint，先学会简单地配置规则，如果要更深入地定制自己的规则，建议阅读「相关链接」中的 ESLint 文档。</p>
<h2><a id="_334"></a>相关链接</h2>
<ul>
<li><a href="https://csspod.com/getting-started-with-eslint/">ESLint 使用入门</a></li>
<li><a href="http://eslint.cn/">ESLinit 中文版文档</a></li>
</ul>
]]></description><link>http://morning.work/page/maintainable-nodejs/getting-started-with-eslint.html</link><guid isPermaLink="true">http://morning.work/page/maintainable-nodejs/getting-started-with-eslint.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 30 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何让异步接口同时支持 callback 和 promise]]></title><description><![CDATA[<h2><a id="_unhandledRejection__2"></a>避免 unhandledRejection 事件</h2>
<p>随着 ES6 的普及，越来越多的异步接口都开始同时支持<code>callback</code>和<code>promise</code>两种方式，我在最近的两篇文章<a href="http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html">《如何用 Node.js 编写一个 API 客户端》</a>和<a href="http://morning.work/page/2016-05/how-to-write-a-nodejs-redis-client.html">《如何编写一个简单的 Redis 客户端》</a>中也使用<strong>一个简单的小技巧</strong>来实现这样的功能：</p>
<pre><code class="language-javascript">request(method, path, params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_resolve, _reject</span>) =&gt;</span> {

    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> {
      _resolve(ret);
      callback &amp;&amp; callback(<span class="hljs-literal">null</span>, ret);
    };

    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      _reject(err);
      callback &amp;&amp; callback(err);
    };

    <span class="hljs-comment">// 以下部分不变</span>
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre>
<p>上文的代码使得<code>request()</code>函数可以返回一个<code>Promise</code>对象，同时如果传入了一个<code>callback</code>参数它也能工作良好，这似乎已经能满足了前文的目标。</p>
<p>但这样的做法带来的一个问题是，<strong>如果我们使用<code>callback</code>方式，当<code>request()</code>函数在执行时回调了一个错误对象（即执行了<code>callback(err)</code>和<code>reject(err)</code>），此时会触发一个<code>unhandledRejection</code>事件</strong>。大多数情况下这样也并不会影响到我们程序的功能，它还是能够正常的工作，但是这些本该可以避免的<code>unhandledRejection</code>事件会对我们调试程序时造成很大的干扰。</p>
<p>究其原因，正确的**实现同时支持<code>callback</code>和<code>promise</code>**必须做到，当使用者传入<code>callback</code>参数时不应该返回一个 Promise 对象。如果返回了一个 Promise 对象，而使用者并不会调用<code>.catch()</code>去捕捉可能发生的错误，这样就会导致触发<code>unhandledRejection</code>事件。</p>
<p>所以，针对上文的例子我们可以改成这样：</p>
<pre><code class="language-javascript">request(method, path, params, callback) {
  <span class="hljs-keyword">if</span> (callback) {
    doRequest(method, path, params, callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      doRequest(method, path, params, (err, ret) =&gt; {
        err ? reject(err) : resolve(ret);
      });
    });
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doRequest</span>(<span class="hljs-params">method, path, params, callback</span>) </span>{
    <span class="hljs-comment">// 以下部分不变</span>
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>或者我们可以写成这样：</p>
<pre><code class="language-javascript">request(method, path, params, callback) {
  <span class="hljs-keyword">if</span> (!callback) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 重新调用当前函数</span>
      request(method, path, params, (err, ret) =&gt; {
        err ? reject(err) : resolve(ret);
      });
    });
  }

  <span class="hljs-comment">// 以下部分不变</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h2><a id="_callback__71"></a>重复执行 callback 的坑</h2>
<p>也许以上的写法并没有那么直观，我们更希望有这么一个<code>promiseToCallback</code>函数（代码来自<a href="http://www.plusman.cn/2016/05/09/b7-error-catch/">《<code>callback</code>和<code>promise</code>的错误捕获
》</a>]，有删改）：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseToCallback</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.apply(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">const</span> callback = args.pop();
    fn.apply(<span class="hljs-literal">null</span>, args)
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        callback(<span class="hljs-literal">null</span>, result);
      })
      .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
        <span class="hljs-built_in">console</span>.error(err);
        callback(err);
      });
  };
}
</code></pre>
<p>正如该文章所说的那样，上文这个代码在<code>callback</code>执行出错时，会被<code>.catch()</code>捕捉到，从而又重复执行了一次<code>callback</code>，这样往往会将我们带入一个更大的坑里面。</p>
<p>我们可以通过以下代码来测试这个<code>promiseToCallback()</code>所存在的问题：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

process.on(<span class="hljs-string">'unhandledRejection'</span>, err =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unhandledRejection'</span>, err);
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">msg</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      resolve(<span class="hljs-string">`hello, <span class="hljs-subst">${ msg }</span>`</span>);
    });
  });
}

promiseToCallback(hello)(<span class="hljs-string">'test'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(err, ret);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'haha'</span>);
});
</code></pre>
<p>执行程序后输出结果如下：</p>
<pre><code>null 'hello, test'
[Error: haha]
[Error: haha] undefined
unhandledRejection [Error: haha]
</code></pre>
<p>其中第一行的输出是正常回调时的输出，但是在回调里面有抛出了一个<code>haha</code>错误，被<code>promiseToCallback</code>的<code>.catch()</code>捕捉到，然后它先把这个<code>err</code>对象打印出来，再重复执行了一遍回调函数，在回调函数中又输出了一遍。同时，在这次的回调函数中，有抛出了一个<code>haha</code>错误，此时<code>promiseToCallback</code>中的<code>.catch()</code>已经不能再捕捉到这个错误了，然后被注册的<code>unhandledRejection</code>事件监听器监听到，并将其打印了出来。</p>
<p>在此先不讨论这个<code>promiseToCallback()</code>是否满足了<strong>同时支持<code>callback</code>和<code>promise</code>这个前提</strong>，就重复执行<code>callback</code>的问题我们是万万不能使用它的。</p>
<p>当然我们也可以有办法使得它不会重复执行回调函数：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseToCallback</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.apply(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">const</span> callback = args.pop();

    <span class="hljs-comment">// 包装 callback，在此函数中保证 callback 只会调用一次</span>
    <span class="hljs-comment">// 再次调用会直接忽略</span>
    <span class="hljs-keyword">const</span> cb = <span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (cb.isCalled) <span class="hljs-keyword">return</span>;
      cb.isCalled = <span class="hljs-literal">true</span>;
      callback(err, ret);
    };

    fn.apply(<span class="hljs-literal">null</span>, args)
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        cb(<span class="hljs-literal">null</span>, result);
      })
      .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
        <span class="hljs-built_in">console</span>.error(err);
        cb(err);
      });
  };
}
</code></pre>
<p>我们通过一个<code>isCalled</code>属性来保证了回调函数只会被执行一次，它确实保证了<code>callback</code>不被重复执行，但同时它也悄悄地将<code>callback</code>发生的错误藏了起来，说不定这又成了将来某一天困扰你多时的坑。</p>
<h2><a id="_162"></a>也许这是最佳的解决方案</h2>
<p>说了这么一大堆，要使得很好地同时支持<code>callback</code>和<code>promise</code>，关键是要处理好这两个问题：</p>
<ul>
<li>避免<code>unhandledRejection</code>事件（一定要使用<code>promise.catch()</code>捕捉错误）</li>
<li>避免多次执行<code>callback</code></li>
</ul>
<p>而我觉得处理好这两个问题其实只需要记住这一个原则：<strong>「原始函数使用 callback 实现，仅在必要时才返回 promise」</strong>。下面是根据这一原则实现的<code>promiseOrCallback</code>函数：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseOrCallback</span>(<span class="hljs-params">fn, argc</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.apply(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-comment">// 判断调用函数时实际传过来的参数数量</span>
    <span class="hljs-keyword">if</span> (args.length &gt; argc) {
      <span class="hljs-comment">// 这是 callback 方式调用的</span>
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, args);
    }
    <span class="hljs-comment">// 这是 promise 方式调用的</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 创建一个 callback 函数用来对接 promise 的 resolve 和 reject</span>
      args.push(<span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> {
        err ? reject(err) : resolve(ret);
      });
      fn.apply(<span class="hljs-literal">null</span>, args);
    });
  };
}
</code></pre>
<p>说明：在包装函数时，<strong>需要明确知道这个函数会接收多少个参数</strong>，假设<code>argc = 1</code>，那么当调用包装后的函数时传入了<code>2</code>个参数，则会认为它是以<code>callback</code>方式调用的，否则会返回一个<code>promise</code>。</p>
<p>我们可以使用以下程序来测试：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

process.on(<span class="hljs-string">'unhandledRejection'</span>, err =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unhandledRejection'</span>, err);
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">msg, callback</span>) </span>{
  setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    callback(<span class="hljs-literal">null</span>, <span class="hljs-string">`hello, <span class="hljs-subst">${ msg }</span>`</span>);
  });
}

promiseOrCallback(hello, <span class="hljs-number">1</span>)(<span class="hljs-string">'test'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(err, ret);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'haha'</span>);
});
</code></pre>
<p>其执行结果应该是这样的：</p>
<pre><code>null 'hello, test'
/tmp/test.js:45
  throw new Error('haha');
  ^

Error: haha
    at /tmp/test.js:45:9
    at Immediate._onImmediate (/tmp/test.js:39:5)
    at processImmediate [as _immediateCallback] (timers.js:383:17)
</code></pre>
<p>说明：在回调函数中，先执行<code>console.log(err, ret)</code>输出了结果，然后<code>throw new Error('haha')</code>再抛出一个错误，这时因为外层没有捕捉到，使得进程因为异常而退出了，这正是我们所期望的。</p>
<p>如果我们改用<code>promise</code>的方式去调用：</p>
<pre><code class="language-javascript">promiseOrCallback(hello, <span class="hljs-number">1</span>)(<span class="hljs-string">'test'</span>).then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>, ret);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'haha'</span>);
}).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(err);
});
</code></pre>
<p>则其执行结果是这样的：</p>
<pre><code>null 'hello, test'
[Error: haha]
</code></pre>
<p>说明：在<code>.then()</code>的回调函数内，我们先输出结果，在<code>throw</code>出一个错误时，并<code>.catch()</code>捕捉到并打印了出来，这符合<code>promise</code>的行为。</p>
<p><strong>如果你要问「原始函数是基于 promise 实现的，想支持 callback 怎么办」，我建议你最好放弃这个想法。</strong></p>
<h2><a id="_254"></a>接口设计的哲学</h2>
<p>在本文发出去之后，得到了大神<a href="http://weibo.com/haxy">@Hax</a>的点评：</p>
<blockquote>
<p>有些代码直接调，不传<code>cb</code>因为它想触发副作用，结果你改成了<code>p</code>，然后还是掉坑了……</p>
</blockquote>
<p>结合上下文我们可以理解为，在上文我们通过判断是否传入了一个<code>callback</code>参数来判断异步方式，在合适的时候再返回<code>promise</code>。但是，假如我们仅仅是想触发一个副作用（执行异步函数，但并不关心它的回调结果），由于没有传入<code>callback</code>参数，此时会被自动识别为<code>promise</code>方式调用，于是它返回了一个<code>promise</code>对象。而当函数执行时回调了一个<code>err</code>对象时，我们又重新掉进了前文所说的<code>unhandledRejection</code>的坑里面。</p>
<p>通过判断参数数量这样的方式来实现不同异步方式的转换并<strong>不严谨</strong>。所以，针对<strong>不同的异步方式应该使用不同的接口</strong>，比如我们可以规定所有异步方法默认都是<code>callback</code>方式（如<code>request</code>），而<code>promise</code>方式都有<code>P</code>后缀（如<code>requestP</code>）。</p>
<p><a href="http://weibo.com/haxy">@Hax</a>继续评论道：</p>
<blockquote>
<p>是的，这是为啥 Node.js 的人最后决定把<code>promise</code>化的 API 单独分开</p>
<p>我个人觉得<code>xxxP</code>名字也不是很友好。其实用不同的包就好了。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> xxx <span class="hljs-keyword">from</span> <span class="hljs-string">'api/callback'</span>
<span class="hljs-keyword">import</span> xxx <span class="hljs-keyword">from</span> <span class="hljs-string">'api/promise'</span>
</code></pre>
</blockquote>
<p>所以，封装成单独的包才是更优雅的方式。最后还有一句话，<strong>切勿混用<code>callback</code>和<code>promise</code></strong>。</p>
<h2><a id="_278"></a>总结</h2>
<p>大多数时候，我们只需要一点点小技巧就能使得程序看起来正常地工作起来。然而要写出<strong>完美</strong>的程序却并不是一件简单的事情。</p>
<h2><a id="_283"></a>相关链接</h2>
<ul>
<li><a href="http://www.plusman.cn/2016/05/09/b7-error-catch/">callback 和 promise 的错误捕获</a></li>
<li><a href="http://www.jianshu.com/p/9e4026614fbe">Promise 陷阱</a></li>
<li><a href="http://liubin.org/promises-book">JavaScript Promise 迷你书（中文版）</a></li>
</ul>
]]></description><link>http://morning.work/page/maintainable-nodejs/promise-and-callback-problem.html</link><guid isPermaLink="true">http://morning.work/page/maintainable-nodejs/promise-and-callback-problem.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Wed, 03 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何编写一个简单的 Redis 客户端]]></title><description><![CDATA[<p>前几天写了篇文章<a href="http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html">《如何用 Node.js 编写一个 API 客户端》</a>（<a href="http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html">http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html</a> ），有人说这 <em>不能算是一个 API 客户端，顶多是一个支持 GET / POST 操作的模块</em> ，羞得我老脸微微一红，故作镇静地自然自语道，简单是简单点了，好歹也是个 API 客户端嘛。</p>
<p>这次要写的这个 Redis 客户端应该算是个客户端了，需要直接发起<code>TCP/IP</code>连接去跟服务器通讯，需要自己解析客户端返回的结果，还要做一些简单的容错处理，如果要做到足够健壮也不容易，不过就本文要实现一个基本可用的例子来说，还是简单了点。</p>
<p>无论是实现 REST 的 API 客户端还是这样一个 Redis 客户端，虽然具体实现的细节不同，但是，<strong>套路</strong>还是<strong>一样</strong>的。二十一世纪行走江湖最重要的是什么？套路！套路！套路！所以呢，本文还是跟之前一样的套路。</p>
<h2><a id="Redis__9"></a>Redis 协议</h2>
<p>要开始编写一个 Redis 客户端，我们首先要知道怎么去跟 Redis 通讯，比如要执行<code>GET a</code>应该按照什么样的格式给服务器发送指令，服务器返回的结果又是什么样的格式这些。Redis 协议的详细介绍可以参考这里：<a href="http://redis.cn/topics/protocol.html">http://redis.cn/topics/protocol.html</a></p>
<p>假如我要执行命令<code>KEYS *</code>，只要往服务器发送<code>KEYS *\r\n</code>即可，这时服务器会直接响应结果，返回的结果格式如下：</p>
<ul>
<li>用单行回复，回复的第一个字节将是<code>+</code></li>
<li>错误消息，回复的第一个字节将是<code>-</code></li>
<li>整型数字，回复的第一个字节将是<code>:</code></li>
<li>批量回复，回复的第一个字节将是<code>$</code></li>
<li>多个批量回复，回复的第一个字节将是<code>*</code></li>
</ul>
<p>每一行都使用<code>\r\n</code>来分隔。</p>
<p>为了查看具体的返回结果是怎样的，我们可以用<code>nc</code>命令来测试。假定本机已经运行了 Redis 服务，其监听端口为<code>6379</code>，我们可以执行以下命令连接：</p>
<pre><code class="language-bash">$ nc 127.0.0.1 6379
</code></pre>
<p>如果本机没有<code>nc</code>命令（比如 Windows 用户），可以使用<code>telnet</code>命令：</p>
<pre><code class="language-bash">$ telnet 127.0.0.1 6379
</code></pre>
<p>下面我们分别测试各个命令返回的结果（其中第一行表示客户端输入的命令，行尾的<code>↵</code>表示按回车发送，第二行开始表示服务器端返回的内容）：</p>
<p>1、返回错误</p>
<pre><code>help ↵

-ERR unknown command 'help'
</code></pre>
<p>2、操作成功</p>
<pre><code>set abc 123456 ↵

+OK
</code></pre>
<p>3、得到结果</p>
<pre><code>get abc ↵

$6
123456
</code></pre>
<p>4、得不到结果</p>
<pre><code>get aaa ↵

$-1
</code></pre>
<p>5、得到的结果是整形数字</p>
<pre><code>hlen aaa ↵

:5
</code></pre>
<p>6、数组结果</p>
<pre><code>keys a* ↵

*3
$3
abc
$3
aa1
$1
a
</code></pre>
<p>7、多命令执行</p>
<pre><code>multi ↵

+OK

get a ↵

+QUEUED

get b ↵

+QUEUED

get c ↵

+QUEUED

exec ↵

*3
$5
hello
$-1
$5
world
</code></pre>
<h2><a id="_122"></a>解析结果</h2>
<p>实现一个 Redis 客户端大概的原理是，<strong>客户端依次把需要执行的命令发送给服务器，而服务器会按照先后顺序把结果返回给用户</strong>。在本文我们使用 Node.js 内置的<code>net</code>模块来操作，通过<code>data</code>事件来接收结果。需要注意的是，有时候结果太长我们可能要几次<code>data</code>事件才能拿到完整的结果，有时可能是一个<code>data</code>事件中包含了几条命令的执行结果，也有可能当前命令的结果还没有传输完，剩下一半的结果在下一个<code>data</code>事件中。</p>
<p>为了方便调试，我们将解析结果的部分独立封装成一个函数，接口如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> proto = <span class="hljs-keyword">new</span> RedisProto();

<span class="hljs-comment">// 接受到数据</span>
proto.push(<span class="hljs-string">'*3\r\n$3\r\nabc\r\n$3\r\naa1\r\n$1\r\na\r\n'</span>);
proto.push(<span class="hljs-string">'$6\r\n123456\r\n'</span>);
proto.push(<span class="hljs-string">'-ERR unknown command \'help\'\r\n'</span>);
proto.push(<span class="hljs-string">'+OK\r\n'</span>);
proto.push(<span class="hljs-string">':5\r\n'</span>);
proto.push(<span class="hljs-string">'*3\r\n$5\r\nhe'</span>);
proto.push(<span class="hljs-string">'llo\r\n$-'</span>);
proto.push(<span class="hljs-string">'1\r\n$5\r\nworld\r\n'</span>);

<span class="hljs-keyword">while</span> (proto.next()) {
  <span class="hljs-comment">// proto.next() 如果有解析出完整的结果则返回结果，没有则返回 false</span>
  <span class="hljs-comment">// 另外可以通过 proto.result 获得</span>
  <span class="hljs-built_in">console</span>.log(proto.result);
}
</code></pre>
<p>接下来开始编写相应的代码。</p>
<p>按照套路，我们先初始化项目：</p>
<pre><code class="language-bash">$ mkdir redis_client
$ <span class="hljs-built_in">cd</span> redis_client
$ git init
$ npm init
</code></pre>
<p>新建文件<code>proto.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">/**
 * 简单 Redis 客户端
 *
 * @author Zongmin Lei &lt;leizongmin@gmail.com&gt;
 */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisProto</span> </span>{

  <span class="hljs-keyword">constructor</span>() {

    <span class="hljs-keyword">this</span>._lines = []; <span class="hljs-comment">// 已初步解析出来的行</span>
    <span class="hljs-keyword">this</span>._text = <span class="hljs-string">''</span>;  <span class="hljs-comment">// 剩余不能构成一行的文本</span>

  }

  <span class="hljs-comment">// 将收到的数据添加到缓冲区</span>
  push(text) {

    <span class="hljs-comment">// 将结果按照\r\n 分隔</span>
    <span class="hljs-keyword">const</span> lines = (<span class="hljs-keyword">this</span>._text + text).split(<span class="hljs-string">'\r\n'</span>);
    <span class="hljs-comment">// 如果结尾是\r\n，那么数组最后一个元素肯定是一个空字符串</span>
    <span class="hljs-comment">// 否则，我们应该将剩余的部分跟下一个 data 事件接收到的数据连起来</span>
    <span class="hljs-keyword">this</span>._text = lines.pop();
    <span class="hljs-keyword">this</span>._lines = <span class="hljs-keyword">this</span>._lines.concat(lines);

  }

  <span class="hljs-comment">// 解析下一个结果，如果没有则返回 null</span>
  next() {

    <span class="hljs-keyword">const</span> lines = <span class="hljs-keyword">this</span>._lines;
    <span class="hljs-keyword">const</span> first = lines[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// 去掉指定数量的行，并且返回结果</span>
    <span class="hljs-keyword">const</span> popResult = <span class="hljs-function">(<span class="hljs-params">lineNumber, result</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>._lines = <span class="hljs-keyword">this</span>._lines.slice(lineNumber);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result = result;
    };

    <span class="hljs-comment">// 返回空结果</span>
    <span class="hljs-keyword">const</span> popEmpty = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result = <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">if</span> (lines.length &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> popEmpty();

    <span class="hljs-keyword">switch</span> (first[<span class="hljs-number">0</span>]) {

      <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
        <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {<span class="hljs-attr">data</span>: first.slice(<span class="hljs-number">1</span>)});

      <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
        <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {<span class="hljs-attr">error</span>: first.slice(<span class="hljs-number">1</span>)});

      <span class="hljs-keyword">case</span> <span class="hljs-string">':'</span>:
        <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {<span class="hljs-attr">data</span>: <span class="hljs-built_in">Number</span>(first.slice(<span class="hljs-number">1</span>))});

      <span class="hljs-keyword">case</span> <span class="hljs-string">'$'</span>: {
        <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Number</span>(first.slice(<span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">-1</span>) {
          <span class="hljs-comment">// 如果是 $-1 表示空结果</span>
          <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {<span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>});
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 否则取后面一行作为结果</span>
          <span class="hljs-keyword">const</span> second = lines[<span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> second !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">2</span>, {<span class="hljs-attr">data</span>: second});
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> popEmpty();
          }
        }
      }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: {
        <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Number</span>(first.slice(<span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> popResult(<span class="hljs-number">1</span>, {<span class="hljs-attr">data</span>: []});
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">const</span> array = [];
          <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
          <span class="hljs-keyword">for</span> (; i &lt; lines.length &amp;&amp; array.length &lt; n; i++) {
            <span class="hljs-keyword">const</span> a = lines[i];
            <span class="hljs-keyword">const</span> b = lines[i + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (a.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">'$-1'</span>) {
              array.push(<span class="hljs-literal">null</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">':'</span>) {
              array.push(<span class="hljs-built_in">Number</span>(a.slice(<span class="hljs-number">1</span>)));
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">'undefined'</span>) {
                array.push(b);
                i++;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> popEmpty();
              }
            }
          }
          <span class="hljs-keyword">if</span> (array.length === n) {
            <span class="hljs-keyword">return</span> popResult(i, {<span class="hljs-attr">data</span>: array});
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> popEmpty();
          }
        }
      }

      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> popEmpty();

    }

  }

}

<span class="hljs-built_in">module</span>.exports = RedisProto;
</code></pre>
<p>执行上文中的测试代码可得到如下结果：</p>
<pre><code class="language-javascript">{ <span class="hljs-attr">data</span>: <span class="hljs-string">'123456'</span> }
{ <span class="hljs-attr">data</span>: [ <span class="hljs-string">'abc'</span>, <span class="hljs-string">'aa1'</span>, <span class="hljs-string">'a'</span> ] }
{ <span class="hljs-attr">error</span>: <span class="hljs-string">'ERR unknown command \'help\''</span> }
{ <span class="hljs-attr">data</span>: <span class="hljs-string">'OK'</span> }
{ <span class="hljs-attr">data</span>: <span class="hljs-number">5</span> }
{ <span class="hljs-attr">data</span>: [ <span class="hljs-string">'hello'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span> ] }
</code></pre>
<h2><a id="_Redis__292"></a>实现 Redis 客户端</h2>
<p>上文我们已经实现了一个简单的解析器，其可以通过<code>push()</code>将接收到的数据片段加进去，然后我们只需要不断地调用<code>next()</code>来获取下一个解析出来的结果即可，直到其返回<code>false</code>，在下一次收到数据时，重复刚才的动作。</p>
<p>新建文件<code>index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-comment">/**
 * 简单 Redis 客户端
 *
 * @author Zongmin Lei &lt;leizongmin@gmail.com&gt;
 */</span>

<span class="hljs-keyword">const</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);
<span class="hljs-keyword">const</span> RedisProto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./proto'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">events</span>.<span class="hljs-title">EventEmitter</span> </span>{

  <span class="hljs-keyword">constructor</span>(options) {
    <span class="hljs-keyword">super</span>();

    <span class="hljs-comment">// 默认连接配置</span>
    options = options || {};
    options.host = options.host || <span class="hljs-string">'127.0.0.1'</span>;
    options.port = options.port || <span class="hljs-number">6379</span>;
    <span class="hljs-keyword">this</span>.options = options;

    <span class="hljs-comment">// 连接状态</span>
    <span class="hljs-keyword">this</span>._isClosed = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._isConnected = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 回调函数列表</span>
    <span class="hljs-keyword">this</span>._callbacks = [];

    <span class="hljs-keyword">this</span>._proto = <span class="hljs-keyword">new</span> RedisProto();

    <span class="hljs-keyword">this</span>.connection = net.createConnection(options.port, options.host, () =&gt; {
      <span class="hljs-keyword">this</span>._isConnected = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'connect'</span>);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'error'</span>, err =&gt; {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'close'</span>, () =&gt; {
      <span class="hljs-keyword">this</span>._isClosed = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'close'</span>);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'end'</span>, () =&gt; {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'end'</span>);
    });

    <span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'data'</span>, data =&gt; {
      <span class="hljs-keyword">this</span>._pushData(data);
    });

  }

  <span class="hljs-comment">// 发送命令给服务器</span>
  sendCommand(cmd, callback) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

      <span class="hljs-keyword">const</span> cb = <span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> {
        callback &amp;&amp; callback(err, ret);
        err ? reject(err) : resolve(ret);
      };

      <span class="hljs-comment">// 如果当前连接已断开，直接返回错误</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isClosed) {
        <span class="hljs-keyword">return</span> cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'connection has been closed'</span>));
      }

      <span class="hljs-comment">// 将回调函数添加到队列</span>
      <span class="hljs-keyword">this</span>._callbacks.push(cb);
      <span class="hljs-comment">// 发送命令</span>
      <span class="hljs-keyword">this</span>.connection.write(<span class="hljs-string">`<span class="hljs-subst">${cmd}</span>\r\n`</span>);

    });
  }

  <span class="hljs-comment">// 接收到数据，循环结果</span>
  _pushData(data) {

    <span class="hljs-keyword">this</span>._proto.push(data);

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._proto.next()) {

      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">this</span>._proto.result;
      <span class="hljs-keyword">const</span> cb = <span class="hljs-keyword">this</span>._callbacks.shift();

      <span class="hljs-keyword">if</span> (result.error) {
        cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(result.error));
      } <span class="hljs-keyword">else</span> {
        cb(<span class="hljs-literal">null</span>, result.data);
      }

    }

  }

  <span class="hljs-comment">// 关闭连接</span>
  end() {
    <span class="hljs-keyword">this</span>.connection.destroy();
  }

}

<span class="hljs-built_in">module</span>.exports = Redis;
</code></pre>
<p>说明：</p>
<ul>
<li>每次<code>data</code>事件接收到结果时，直接将其<code>push()</code>到<code>RedisProto</code>中，并尝试执行<code>next()</code>获得结果</li>
<li>因为命令的执行结果都是按照顺序返回的，所以我们只需要按顺序从<code>this._callbacks</code>中取出最前面的元素，直接执行回调</li>
<li>如果连接已经断开，则不允许再执行命令，直接返回<code>connection has been closed</code>错误</li>
<li><code>sendCommand()</code>同时支持<code>callback</code>和<code>promise</code>方式的回调，但是套路跟上一篇文章《如何用 Node.js 编写一个 API 客户端》稍有不同</li>
<li><strong>此处关于同时支持<code>promise</code>和<code>callback</code>的实现方式有问题，详情请阅读<a href="http://morning.work/page/maintainable-nodejs/promise-and-callback-problem.html">《如何让异步接口同时支持 callback 和 promise》</a></strong></li>
</ul>
<p>新建测试文件<code>test.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./index'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Redis();

client.sendCommand(<span class="hljs-string">'GET a'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'GET b'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'KEYS *IO*'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'KEYS *IO*=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'OOXX'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OOXX=%s, err=%s'</span>, ret, err);
});

client.sendCommand(<span class="hljs-string">'SET a '</span> + <span class="hljs-built_in">Date</span>.now())
  .then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success'</span>, ret))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>, err))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> client.end());
</code></pre>
<p>执行测试文件<code>node test.js</code>可看到类似如下的结果：</p>
<pre><code>a=1463041835231, err=null
b=null, err=null
KEYS *IO*=sess:cz5F-npwOnw0FmesT6JjqJPL13IO8AzV,sess:NS90IkF6uZNAm-FPEAWXHuh3JrIW1-IO, err=null
OOXX=undefined, err=Error: ERR unknown command 'OOXX'
success OK
</code></pre>
<p>从结果中可以看出我们这个 Redis 客户端已经基本能用了。</p>
<h2><a id="_458"></a>更友好的接口</h2>
<p>上文我们实现了一个<code>sendCommand()</code>方法，理论上可以通过该方法执行任意的 Redis 命令，但是我们可能更希望每条命令有一个对应的方法，比如<code>sendCommand('GET a')</code>我们可以写成<code>get('a')</code>，这样看起来会更直观。</p>
<p>首先在<code>index.js</code>文件头部载入<code>fs</code>和<code>path</code>模块：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
</code></pre>
<p>然后给<code>Redis</code>类增加<code>_bindCommands()</code>方法：</p>
<pre><code class="language-javascript">_bindCommands() {

  <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>;

  <span class="hljs-comment">// 绑定命令</span>
  <span class="hljs-keyword">const</span> bind = <span class="hljs-function">(<span class="hljs-params">cmd</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

      <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
      <span class="hljs-keyword">let</span> callback;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[args.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'function'</span>) {
        callback = args.pop();
      }

      <span class="hljs-comment">// 每个参数使用空格分隔</span>
      args = args.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item) ? item.join(<span class="hljs-string">' '</span>) : item).join(<span class="hljs-string">' '</span>);

      <span class="hljs-keyword">return</span> self.sendCommand(<span class="hljs-string">`<span class="hljs-subst">${cmd}</span> <span class="hljs-subst">${args}</span>`</span>, callback);

    };
  };

  <span class="hljs-comment">// 从文件读取命令列表</span>
  <span class="hljs-keyword">const</span> cmdList = fs.readFileSync(path.resolve(__dirname, <span class="hljs-string">'cmd.txt'</span>)).toString().split(<span class="hljs-string">'\n'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cmd <span class="hljs-keyword">of</span> cmdList) {

    <span class="hljs-comment">// 同时支持大写和小写的函数名</span>
    <span class="hljs-keyword">this</span>[cmd.toLowerCase()] = <span class="hljs-keyword">this</span>[cmd.toUpperCase()] = bind(cmd);

  }

}
</code></pre>
<p>然后在<code>Redis</code>类的<code>constructor()</code>方法尾部增加以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">this</span>._bindCommands();
</code></pre>
<p>由于在<code>_bindCommands()</code>中通过读取<code>cmd.txt</code>文件来读取 Redis 的命令列表，所以还需要新建文件<code>cmd.txt</code>，内容格式为每条命令一行（由于篇幅限制，本文只列出需要用到的几条命令）：</p>
<pre><code>GET
SET
AUTH
MULTI
EXEC
KEYS
</code></pre>
<p>把测试文件<code>test.js</code>改为以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./index'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Redis();

client.get(<span class="hljs-string">'a'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a=%s, err=%s'</span>, ret, err);
});

client.get(<span class="hljs-string">'b'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b=%s, err=%s'</span>, ret, err);
});

client.keys(<span class="hljs-string">'*IO*'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'KEYS *IO*=%s, err=%s'</span>, ret, err);
});

client.set(<span class="hljs-string">'a'</span>, <span class="hljs-built_in">Date</span>.now())
  .then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success'</span>, ret))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>, err))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> client.end())
</code></pre>
<p>重新执行<code>node test.js</code>可看到结果跟上文还是一致的。</p>
<h2><a id="_552"></a>简单容错处理</h2>
<p>假如将测试文件<code>test.js</code>改为这样：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./index'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Redis();

client.get(<span class="hljs-string">'a'</span>, (err, ret) =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a=%s, err=%s'</span>, ret, err);

  client.end();

  client.get(<span class="hljs-string">'b'</span>, (err, ret) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b=%s, err=%s'</span>, ret, err);
  });
});
</code></pre>
<p>在完成<code>get('a')</code>的时候，我们执行<code>client.end()</code>关闭了连接，然后再执行<code>get('b')</code>，大多数情况下将会得到如下的结果：</p>
<pre><code>a=1463042964235, err=null
</code></pre>
<p>而<code>get('b')</code>的回调函数并没有被执行，因为我们在关闭连接后，再也没有收到服务端返回的结果。另外也有可能是因为其他原因，客户端与服务端的连接断开了，此时我们应该能执行回调并返回一个错误。</p>
<p>在文件<code>index.js</code>中给<code>Redis</code>类增加一个方法<code>_callbackAll()</code>：</p>
<pre><code class="language-javascript">_callbackAll() {

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cb <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>._callbacks) {
    cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'connection has been closed'</span>));
  }
  <span class="hljs-keyword">this</span>._callbacks = [];

}
</code></pre>
<p>另外，在<code>constructor()</code>方法内，将监听连接的<code>close</code>事件部分代码改成这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">this</span>.connection.on(<span class="hljs-string">'close'</span>, () =&gt; {
  <span class="hljs-keyword">this</span>._isClosed = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'close'</span>);
  <span class="hljs-keyword">this</span>._callbackAll();
});
</code></pre>
<p>重新执行<code>node test.js</code>，从执行结果可看出所有回调函数均已被执行：</p>
<pre><code>a=1463042964235, err=null
b=undefined, err=Error: connection has been closed
</code></pre>
<h2><a id="_612"></a>还存在的问题</h2>
<p>看起来这个模块已经能正常使用了，但是其实并不完善。跟 NPM 上的<code>ioredis</code>模块起来还存在以下问题：</p>
<ul>
<li>不支持<code>multi()</code>命令</li>
<li>不支持<code>publish</code>和<code>subscribe</code>命令</li>
<li>不能解析更复杂的返回结果，比如<code>command</code>命令的返回结果</li>
<li>不支持更多的连接选项，比如密码验证</li>
<li>可能存在 unicode 字符被截断问题</li>
<li>因为结果是通过<code>\r\n</code>来分行的，如果一条数据里面本身包含<code>\r\n</code>字符，可能会解析出错</li>
<li>没有严格的测试，假如服务端返回了一个非预期的格式，我也不知道程序会咋样</li>
<li><code>RedisProto</code>解析结果的算法还是可以优化的，目前这个只能算是大概能用</li>
<li>如果连接意外断开了，我们可能希望能自动重新连接而不是直接报错</li>
</ul>
<h2><a id="_627"></a>相关链接</h2>
<ul>
<li><a href="http://redis.cn/topics/protocol.html">Redis 协议</a>（<a href="http://redis.cn/topics/protocol.html%EF%BC%89">http://redis.cn/topics/protocol.html）</a></li>
<li><a href="http://morning.work/page/maintainable-nodejs/promise-and-callback-problem.html">如何让异步接口同时支持 callback 和 promise</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-05/how-to-write-a-nodejs-redis-client.html</link><guid isPermaLink="true">http://morning.work/page/2016-05/how-to-write-a-nodejs-redis-client.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Wed, 03 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何用 Node.js 编写一个 RESTful API 客户端]]></title><description><![CDATA[<h2><a id="_2"></a>说几句无关主题的话</h2>
<p>尽管这几年来 Node.js 已经得到越来越多的关注，连市场卖菜的老太婆都能分别得出哪个是写 Node.js 的，哪个是写 PHP 的。然而，终究是不能跟老大哥 Java 比的。我们在使用一些第三方服务时常常会碰到一时半会还没有官方的 Node.js SDK 的问题，所以能自己随手撸一个刚好够用的 RESTful API 客户端来应急成了必备技能。</p>
<p>说到这里，我忍不住要先吐槽一下：</p>
<blockquote>
<p>前几天在 CNodeJS 上看到一个帖子<a href="https://cnodejs.org/topic/56ab1c0526d02fc6626bb383">《拥抱 ES6——阿里云 OSS 推出 JavaScript SDK》</a>，对其中的滥用<code>generator</code>还<strong>洋洋自得</strong>的行为有点不满，之前也遇到过该厂的 SDK 强行返回<code>generator</code>而放弃使用，我想说我<strong>已经忍了很久</strong>了。</p>
<p><strong>「我自己写得爽，也希望把这种“爽”带给用户」</strong>-- <em>该 SDK 的维护者如是说</em></p>
<p><strong>作为一个 SDK（尤其是官方出品的），应该使用最 common 的技术或规范来实现</strong>。比如在 Node.js 中的异步问题，应该使用传统的<code>callback</code>或者 ES6 里面的<code>promise</code>，而不是使用比较奇葩的<code>generator</code>来做。<code>generator</code>来做不妥的地方是：</p>
<ul>
<li><code>generator</code>的出现不是为了解决异步问题</li>
<li>使用<code>generator</code>是会传染的，当你尝试<code>yield</code>一下的时候，它要求你也必须在一个<code>generator function</code>内</li>
</ul>
<p>当然，如果这是一个内部项目，使用各种花式姿势都是没问题的，只要定好规范就行。而如果这是要给别人使用的东西，应该照顾其他人的感受。</p>
<p>所以我们要自己动手写一个 SDK 还有另外一种情况就是<strong>对官方的 SDK 并不满意</strong>。</p>
<p>好了，我吐槽完了。</p>
</blockquote>
<h2><a id="_24"></a>运行环境</h2>
<p>最近一年来，Node.js 相继发布了 4.0、5.0、6.0（前几天），7.0 也已经蓄势待发，但目前来看<strong>主流还是 4.x 版本</strong>。Node.js 4.x 支持一部分的 ES6 语法，比如箭头函数、<code>let</code>和<code>const</code>等，解决异步问题也可以直接使用 ES6 的<code>promise</code>。</p>
<p>如果没有特殊情况，新写的程序可以不用考虑在 0.12 或者更早的 0.10 上运行，如果以后确实需要在些版本上执行，可以借用 Babel 来编译成 ES5 语法的程序。</p>
<p>API 接口将同时支持<code>callback</code>和<code>promise</code>两种回调方式。<code>promise</code>直接使用 ES6 原生的<code>Promise</code>对象而不是使用<code>bluebird</code>模块。尽管使用<code>bluebird</code>会有更多的功能和更好的性能，但在这样一个需要网络 IO 的场景下，那么一点性能差别基本可以忽略不计，而作为一个极简主义者，觉得没太大必要引入这么一个依赖库。</p>
<h2><a id="_33"></a>功能设计</h2>
<p>本文将以 <a href="https://cnodejs.org/api">CNodeJS 提供的 API</a> 为例。CNodeJS 的 API 分两种：</p>
<ul>
<li>公共接口，比如获取主题列表和详情等</li>
<li>用户接口，需要提供<code>accesstoken</code>参数来验证用户权限（<code>accessToken</code>可以在个人设置界面中得到）</li>
</ul>
<p>程序的使用方法如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> CNodeJS({
  <span class="hljs-attr">token</span>: <span class="hljs-string">'xxxxxxx'</span>, <span class="hljs-comment">// accessToken，可为空</span>
});

<span class="hljs-comment">// promise 方式调用</span>
client.getTopics({<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>})
  .then(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(list))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// callback 方式调用</span>
client.getTopics({<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>}, (err, list) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(list);
  }
});
</code></pre>
<h2><a id="_65"></a>初始化项目</h2>
<p>1、首先新建项目目录：</p>
<pre><code class="language-bash">$ mkdir cnodejs_api_client
$ <span class="hljs-built_in">cd</span> cnodejs_api_client
$ git init
</code></pre>
<p>2、初始化<code>package.json</code>：</p>
<pre><code class="language-bash">$ npm init
</code></pre>
<p>3、新建文件<code>index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> rawRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNodeJS</span> </span>{

  <span class="hljs-keyword">constructor</span>(options) {

    <span class="hljs-keyword">this</span>.options = options = options || {};
    options.token = options.token || <span class="hljs-literal">null</span>;
    options.url = options.url || <span class="hljs-string">'https://cnodejs.org/api/v1/'</span>;

  }

  baseParams(params) {

    params = <span class="hljs-built_in">Object</span>.assign({}, params || {});
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.token) {
      params.accesstoken = <span class="hljs-keyword">this</span>.options.token;
    }

    <span class="hljs-keyword">return</span> params;

  }

  request(method, path, params, callback) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

      <span class="hljs-keyword">const</span> opts = {
        <span class="hljs-attr">method</span>: method.toUpperCase(),
        <span class="hljs-attr">url</span>: <span class="hljs-keyword">this</span>.options.url + path,
        <span class="hljs-attr">json</span>: <span class="hljs-literal">true</span>,
      };

      <span class="hljs-keyword">if</span> (opts.method === <span class="hljs-string">'GET'</span> || opts.method === <span class="hljs-string">'HEAD'</span>) {
        opts.qs = <span class="hljs-keyword">this</span>.baseParams(params);
      } <span class="hljs-keyword">else</span> {
        opts.body = <span class="hljs-keyword">this</span>.baseParams(params);
      }

      rawRequest(opts, (err, res, body) =&gt; {

        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> reject(err);

        <span class="hljs-keyword">if</span> (body.success) {
          resolve(body);
        } <span class="hljs-keyword">else</span> {
          reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(body.error_msg));
        }

      });

    });
  }

}

<span class="hljs-built_in">module</span>.exports = CNodeJS;
</code></pre>
<p>说明：</p>
<ul>
<li>使用<code>request</code>模块来发送 HTTP 请求，需要执行命令来安装该模块：<code>npm install request --save</code></li>
<li>我们实现了一个带有<code>request</code>方法的<code>CNodeJS</code>类，可以通过该方法来发送任意 API 请求，比如请求主题首页是<code>request('GET', 'topics', {page: 1})</code></li>
<li>如果初始化<code>CNodeJS</code>实例时传入了<code>token</code>，则每次请求都会自动带上<code>accesstoken</code>参数</li>
<li>返回的结果<code>success=true</code>表示 API 请求成功，则直接回调该结果；如果失败则<code>error_msg</code>表示出错信息</li>
</ul>
<p>4、新建测试文件<code>test.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> CNodeJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>);
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> CNodeJS();

client.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, {<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>})
  .then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(ret))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(err));
</code></pre>
<p>5、执行命令<code>node test.js</code>即可看到类似以下的结果：</p>
<pre><code class="language-javascript">{ <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">data</span>:
   [ { <span class="hljs-attr">id</span>: <span class="hljs-string">'572afb6b15c24e592c16e1e6'</span>,
       <span class="hljs-attr">author_id</span>: <span class="hljs-string">'504c28a2e2b845157708cb61'</span>,
       <span class="hljs-attr">tab</span>: <span class="hljs-string">'share'</span>,
       <span class="hljs-attr">content</span>: <span class="hljs-string">'.......'</span>
...
</code></pre>
<p>至此我们已经完成了一个 API 客户端最基本的功能，接下来根据不同的 API 封装一下<code>request</code>方法即可。</p>
<h2><a id="_callback_178"></a>支持 callback</h2>
<p>前文已经提到，<strong>「作为一个 SDK，应该使用最 common 的技术或规范来实现」</strong>，所以除了<code>promise</code>之外还需要提供<code>callback</code>的支持。</p>
<p>1、修改文件<code>index.js</code>中<code>request(method, path, params) { }</code>定义部分：</p>
<pre><code class="language-javascript">request(method, path, params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_resolve, _reject</span>) =&gt;</span> {

    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> {
      _resolve(ret);
      callback &amp;&amp; callback(<span class="hljs-literal">null</span>, ret);
    };

    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      _reject(err);
      callback &amp;&amp; callback(err);
    };

    <span class="hljs-comment">// 以下部分不变</span>
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre>
<p>说明：</p>
<ul>
<li>将<code>new Promise()</code>中的<code>resolve</code>和<code>reject</code>分别改名为<code>_resolve</code>和<code>_reject</code></li>
<li>在函数开头新建<code>resolve</code>和<code>reject</code>，其作用是调用原来的<code>_resolve</code>和<code>_reject</code>，同时判断如果有<code>callback</code>参数，则也调用该函数</li>
<li><strong>此处关于同时支持<code>promise</code>和<code>callback</code>的实现方式有问题，详情请阅读另一篇文章<a href="http://morning.work/page/maintainable-nodejs/promise-and-callback-problem.html">《如何让异步接口同时支持 callback 和 promise》</a></strong></li>
</ul>
<p>2、将文件<code>test.js</code>中<code>client.request()</code>部分改为 callback 方式调用：</p>
<pre><code class="language-javascript">client.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, {<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>}, (err, ret) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(ret);
  }
});
</code></pre>
<p>3、重新执行<code>node test.js</code>可以看到结果跟之前是一样的。</p>
<p>通过简单的修改我们就已经实现了同时支持<code>promise</code>和<code>callback</code>两种异步回调方式。</p>
<h2><a id="_API_227"></a>封装 API</h2>
<p>前文我们实现的<code>request()</code>方法已经可以调用任意的 API 了，但是为了是方便，一般需要为每个 API 单独封装一个方法，比如：</p>
<ul>
<li><code>getTopics()</code>- 获取主题首页</li>
<li><code>getTopicDetail()</code>- 获取主题详情</li>
<li><code>testToken()</code>- 测试<code>token</code>是否正确</li>
</ul>
<p>对于<code>getTopics()</code>可以这样简单地实现：</p>
<pre><code class="language-javascript">getTopics(params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, params, callback);
}
</code></pre>
<p>但其返回的结果是这样结构的：</p>
<pre><code class="language-javascript">{ <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">data</span>: []
}
</code></pre>
<p>要取得结果还要读取里面的<code>data</code>，针对这种情况我们可以改成这样：</p>
<pre><code class="language-javascript">getTopics(params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'topics'</span>, params, callback)
             .then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(ret.data));
}
</code></pre>
<p><code>getTopicDetail()</code>和<code>testToken()</code>可以这样实现：</p>
<pre><code class="language-javascript">getTopicDetail(params, callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'GET'</span>,<span class="hljs-string">`topic/<span class="hljs-subst">${params.id}</span>`</span>, params, callback)
             .then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(ret.data));
}

testToken(callback) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'POST'</span>,<span class="hljs-string">`accesstoken`</span>, {}, callback);
}
</code></pre>
<p>对于其他的 API 也可以采用类似的方法一一实现。</p>
<h2><a id="_276"></a>总结</h2>
<p>由此看来编写一个简单的 API 客户端也不是一件很难的事情，本文介绍的方法已经能适用大多数的情况了。当然还有些问题是没提到的，比如阿里云 OSS 这种 SDK 还要考虑 stream 上传问题，还有断点续传。对于安全性要求较高的 SDK 可能还需要做数据签名等等。</p>
<p>在编写本文的时候，通过阅读<code>request</code>的 API 文档我才发现原来可以通过<code>json=true</code>选项来让它自动解析返回的结果，这样确实能少写好几行代码了。</p>
<p>另外我还是忍不住再吐槽一下，CNodeJS 的 API 接口设计得并不一致，响应成功时并不是所有数据都放在<code>data</code>里面（比如<code>testToken()</code>）。</p>
<h2><a id="_285"></a>相关链接</h2>
<ul>
<li><a href="http://morning.work/page/maintainable-nodejs/promise-and-callback-problem.html">如何让异步接口同时支持 callback 和 promise</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html</link><guid isPermaLink="true">http://morning.work/page/2016-05/how-to-write-a-nodejs-api-client-package.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Wed, 03 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 的 Readable Stream 与日志文件处理]]></title><description><![CDATA[<blockquote>
<p>在上一篇文章<a href="http://morning.work/page/2016-07/how-to-implement-a-tail-f-command-in-nodejs.html">《如何实时监听文件的新增内容：一个简单 tailf 命令的实现》</a>里面，我们已经实现了一个<code>tailf</code>函数用来监听文件的新增内容，看起来它也工作良好。然而当我想把它应用到手头正要做的日志文件处理时，却发现这样一个<strong>非标准的接口很难与之前编写的模块愉快地合作</strong>。</p>
<p>我在去年的文章<a href="http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html">《在 Node.js 中读写大文件》</a>中实现了一个<code>readLine(stream)</code>函数，其接收的参数是一个<code>Readable Stream</code>对象，能按照给定的规则（比如使用<code>\n</code>换行）来<code>emit</code>出每一行的内容，再结合<code>tailf</code>来监听文件的新增内容，我们就可以很轻易地对新增的内容进行按行切分。</p>
<p>所以，我们要实现一个实现了<code>Readable Stream</code>接口的<code>tailf</code>，在本文中我给它起了个名字叫<code>TailStream</code>。</p>
<p>本文所实现的<code>TailStream</code>已加入<code>lei-stream</code>模块，使用方法为：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 使用前先执行 npm install lei-stream 安装模块</span>
<span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).tailStream(file, {<span class="hljs-attr">position</span>: <span class="hljs-string">'end'</span>});
</code></pre>
<p><code>lei-stream</code>模块详细介绍请参考这里：<a href="https://github.com/leizongmin/node-lei-stream">https://github.com/leizongmin/node-lei-stream</a></p>
</blockquote>
<h2><a id="_Readable_Stream_17"></a>关于 Readable Stream</h2>
<p>Node.js 的<code>stream</code>模块提供了四种形式的流，分别适用于不同的场景：</p>
<table>
<thead>
<tr>
<th>适用场景</th>
<th>Class</th>
<th>需要实现的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>只读</td>
<td><a href="https://nodejs.org/api/stream.html#stream_class_stream_readable">Readable</a></td>
<td><code>_read</code></td>
</tr>
<tr>
<td>只写</td>
<td><a href="https://nodejs.org/api/stream.html#stream_class_stream_writable">Writable</a></td>
<td><code>_write</code>, <code>_writev</code></td>
</tr>
<tr>
<td>读写</td>
<td><a href="https://nodejs.org/api/stream.html#stream_class_stream_duplex">Duplex</a></td>
<td><code>_read</code>, <code>_write</code>, <code>_writev</code></td>
</tr>
<tr>
<td>处理写入的数据供读取</td>
<td><a href="https://nodejs.org/api/stream.html#stream_class_stream_transform">Transform</a></td>
<td><code>_transform</code>, <code>_flush</code></td>
</tr>
</tbody>
</table>
<p>从表格可以得知，要实现一个<code>Readable</code>的流，只需要实现一个<code>_read()</code>方法即可。然后我们再来看看<a href="https://nodejs.org/api/stream.html#stream_readable_read_size_1">_read() 的定义</a>：</p>
<p><code>readable._read(size)</code></p>
<ul>
<li><code>size</code> 参数表示需要异步读取的字节数</li>
<li>当<code>_read(size)</code>被调用时，尝试从底层资源中读取指定长度的数据，如果读取到数据则使用<code>this.push(data)</code>将数据推送到队列中</li>
<li>当底层资源已读取到末尾时，通过<code>this.push(null)</code>来表示结束</li>
<li>如果在操作过程中发生错误，通过<code>this.emit('error', err)</code>来触发<code>error</code>事件</li>
</ul>
<h2><a id="_TailStream__43"></a>简单的 TailStream 实现</h2>
<p>由此官方文档中对 Readable Stream 的介绍，再结合文章<a href="http://morning.work/page/2016-07/how-to-implement-a-tail-f-command-in-nodejs.html">《如何实时监听文件的新增内容：一个简单 tailf 命令的实现》</a>中监控文件变化的方法，我们可以编写以下代码来实现一个<code>tailf</code>的<code>stream</code>版本：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TailStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">stream</span>.<span class="hljs-title">Readable</span> </span>{

  <span class="hljs-comment">/**
   * TailStream
   *
   * @param {Object} options
   *   - {String} file 文件名
   */</span>
  <span class="hljs-keyword">constructor</span>(options) {
    options = options || {};
    <span class="hljs-comment">// 调用基类的构造函数</span>
    <span class="hljs-keyword">super</span>(options);
    <span class="hljs-comment">// 文件名</span>
    <span class="hljs-keyword">this</span>._file = options.file;
    <span class="hljs-comment">// 起始位置</span>
    <span class="hljs-keyword">this</span>._position = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 开始打开文件</span>
    <span class="hljs-keyword">this</span>._openFile();
  }

  <span class="hljs-comment">// 打开文件</span>
  _openFile() {
    <span class="hljs-keyword">this</span>._fd = fs.openSync(<span class="hljs-keyword">this</span>._file, <span class="hljs-string">'r'</span>);
    <span class="hljs-keyword">this</span>._watchFile();
  }

  <span class="hljs-comment">// 监听文件内容变化</span>
  _watchFile() {
    <span class="hljs-keyword">this</span>._watcher = fs.watch(<span class="hljs-keyword">this</span>._file, (event, filename) =&gt; {
      <span class="hljs-keyword">if</span> (event === <span class="hljs-string">'change'</span>) {
        <span class="hljs-keyword">this</span>._read(<span class="hljs-keyword">this</span>._getHighWaterMark());
      }
    });
  }

  <span class="hljs-comment">// 获取每次合适的读取字节数</span>
  _getHighWaterMark() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._readableState.highWaterMark;
  }

  <span class="hljs-comment">// 读取数据</span>
  _read(size) {
    fs.read(<span class="hljs-keyword">this</span>._fd, <span class="hljs-keyword">new</span> Buffer(size), <span class="hljs-number">0</span>, size, <span class="hljs-keyword">this</span>._position,
    (err, bytesRead, buf) =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
      <span class="hljs-keyword">if</span> (bytesRead &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 将数据推送到队列</span>
        <span class="hljs-keyword">this</span>._position += bytesRead;
        <span class="hljs-keyword">this</span>.push(buf.slice(<span class="hljs-number">0</span>, bytesRead));
      }
    });
  }

}
</code></pre>
<p>说明：</p>
<ul>
<li>为了让程序逻辑显得尽可能简单，在打开文件时是使用<code>fs.openSync()</code>这样的阻塞方法，在下文将会对此进行改造</li>
<li><code>_getHighWaterMark()</code>用来获取每次要尝试读取的字节数，其实就是在<code>_read(size)</code>时传入的默认<code>size</code>值</li>
<li>如果操作过程中出错，使用<code>this.emit('error', err)</code>来抛出错误</li>
</ul>
<p>对于上面的代码，可以编写以下程序来测试：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> file = process.argv[<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> TailStream({file});
s.on(<span class="hljs-string">'data'</span>, data =&gt; {
  process.stdout.write(data);
});
</code></pre>
<p>假如将上面的代码保存为文件<code>tail_stream.js</code>，而我们要监听的文件名为<code>test.log</code>，可以执行以下命令先新建一个<code>test.log</code>文件：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">""</span> &gt; test.log
</code></pre>
<p>在可以执行以下命令启动监听程序：</p>
<pre><code class="language-bash">$ node tail_stream test.log
</code></pre>
<p>然后再在另一个控制台窗口下执行命令测试：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$(date)</span> hello, world"</span> &gt;&gt; test.log
</code></pre>
<p>如果一切顺利，我们所写的程序应该是能很好地工作的。</p>
<h2><a id="_146"></a>不止于玩具</h2>
<p>当你兴高采烈地开始使用上面的代码时，<strong>「我跟你讲，你会踩坑的」</strong>。我都不好意思说当我不小心掉坑里的时候，整整花了一个多小时才回过神来。</p>
<p>我先来上文的代码存在的一些问题吧：</p>
<ul>
<li>在<code>_read(size)</code>里，由于<code>fs.read()</code>是使用异步读取的，<code>_position</code>只会在读取完成后的回调函数中更新，当读取过程中<code>_watchFile()</code>所监听的文件有被更改的事件触发时，假如此时有一个<code>fs.read()</code>读取还未完成，再进行一个<code>fs.read()</code>就会导致数据错乱</li>
<li>打开文件用的是<code>fs.openSync()</code>，为了保持实现的一致，还是需要使用异步方法来实现的</li>
</ul>
<p>下面我们尝试将<code>_openFile()</code>改为异步实现：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 打开文件</span>
_openFile() {
  fs.open(<span class="hljs-keyword">this</span>._file, <span class="hljs-string">'r'</span>, (err, fd) =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    <span class="hljs-keyword">this</span>._fd = fd;
    <span class="hljs-keyword">this</span>._watchFile();
  });
}
</code></pre>
<p>虽然仅仅是去掉了个<code>Sync</code>，但是变化却出乎意料。当尝试运行程序时，报错了：</p>
<pre><code>fs.js:687
  binding.read(fd, buffer, offset, length, position, req);
          ^

TypeError: fd must be a file descriptor
    at TypeError (native)
    at Object.fs.read (fs.js:687:11)
    at TailStream._read (~/tail_stream.js:49:8)
    at TailStream.Readable.read (_stream_readable.js:349:10)
    at resume_ (_stream_readable.js:738:12)
    at _combinedTickCallback (internal/process/next_tick.js:74:11)
    at process._tickCallback (internal/process/next_tick.js:98:9)
    at Module.runMain (module.js:577:11)
    at run (bootstrap_node.js:352:7)
    at startup (bootstrap_node.js:144:9)
</code></pre>
<p>由于<strong>在注册<code>data</code>事件监听器后，Readable Stream 立刻执行<code>_read()</code>尝试从底层读取数据</strong>，而此时我们的异步打开文件的操作可能还没有执行回调，还没有获得文件操作句柄<code>this._fd</code>，所以程序报错了。</p>
<p>我们可以尝试使用一个<code>this._ready</code>标记来表示是否准备就绪，在<code>_read(size)</code>方法内首先判断如果<code>this._ready = true</code>才正在调用<code>fs.read()</code>读取文件。由于改动的位置较多，以下直接贴出完整的代码：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TailStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">stream</span>.<span class="hljs-title">Readable</span> </span>{

  <span class="hljs-comment">/**
   * TailStream
   *
   * @param {Object} options
   *   - {String} file 文件名
   */</span>
  <span class="hljs-keyword">constructor</span>(options) {
    options = options || {};
    <span class="hljs-comment">// 调用基类的构造函数</span>
    <span class="hljs-keyword">super</span>(options);
    <span class="hljs-comment">// 文件名</span>
    <span class="hljs-keyword">this</span>._file = options.file;
    <span class="hljs-comment">// 起始位置</span>
    <span class="hljs-keyword">this</span>._position = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 标记是否准备就绪</span>
    <span class="hljs-keyword">this</span>._ready = <span class="hljs-literal">false</span>;
    <span class="hljs-comment">// 开始打开文件</span>
    <span class="hljs-keyword">this</span>._openFile();
  }

  <span class="hljs-comment">// 打开文件</span>
  _openFile() {
    fs.open(<span class="hljs-keyword">this</span>._file, <span class="hljs-string">'r'</span>, (err, fd) =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
      <span class="hljs-keyword">this</span>._fd = fd;
      <span class="hljs-keyword">this</span>._watchFile();
      <span class="hljs-keyword">this</span>._ready = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>._tryRead();
    });
  }

  <span class="hljs-comment">// 监听文件内容变化</span>
  _watchFile() {
    <span class="hljs-keyword">this</span>._watcher = fs.watch(<span class="hljs-keyword">this</span>._file, (event, filename) =&gt; {
      <span class="hljs-keyword">if</span> (event === <span class="hljs-string">'change'</span>) {
        <span class="hljs-keyword">this</span>._tryRead();
      }
    });
  }

  <span class="hljs-comment">// 获取每次合适的读取字节数</span>
  _getHighWaterMark() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._readableState.highWaterMark;
  }

  <span class="hljs-comment">// 尝试读取数据</span>
  _tryRead() {
    <span class="hljs-keyword">this</span>._read(<span class="hljs-keyword">this</span>._getHighWaterMark());
  }

  <span class="hljs-comment">// 读取数据</span>
  _read(size) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._ready) {
      <span class="hljs-comment">// 仅当_ready=true 时才尝试读取数据</span>
      <span class="hljs-keyword">this</span>._ready = <span class="hljs-literal">false</span>;
      fs.read(<span class="hljs-keyword">this</span>._fd, <span class="hljs-keyword">new</span> Buffer(size), <span class="hljs-number">0</span>, size, <span class="hljs-keyword">this</span>._position,
      (err, bytesRead, buf) =&gt; {
        <span class="hljs-comment">// 设置_ready=true 以便可以再次读取数据</span>
        <span class="hljs-keyword">this</span>._ready = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
        <span class="hljs-keyword">if</span> (bytesRead &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-comment">// 将数据推送到队列</span>
          <span class="hljs-keyword">this</span>._position += bytesRead;
          <span class="hljs-keyword">this</span>.push(buf.slice(<span class="hljs-number">0</span>, bytesRead));
        }
      });
    }
  }

}
</code></pre>
<h2><a id="_273"></a>直接定位到文件尾部</h2>
<p>记得在之前实现的<code>tailf()</code>函数里，我们已经实现了打开文件时立刻定位到文件尾部，所以在<code>TailStream</code>里也希望能支持这样的选项。</p>
<p>首先修改构造函数<code>constructor</code>，增加了初始化选项<code>position</code>：</p>
<pre><code class="language-javascript"><span class="hljs-comment">/**
  * TailStream
  *
  * @param {Object} options
  *   - {String} file 文件名
  *   - {Number|String} position 位置，为"end"表示定位到尾部
  */</span>
<span class="hljs-keyword">constructor</span>(options) {
  options = options || {};
  <span class="hljs-comment">// 调用基类的构造函数</span>
  <span class="hljs-keyword">super</span>(options);
  <span class="hljs-comment">// 文件名</span>
  <span class="hljs-keyword">this</span>._file = options.file;
  <span class="hljs-comment">// 起始位置</span>
  <span class="hljs-keyword">this</span>._position = options.position || <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 标记是否准备就绪</span>
  <span class="hljs-keyword">this</span>._ready = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 开始打开文件</span>
  <span class="hljs-keyword">this</span>._openFile();
}
</code></pre>
<p>然后增加一个方法用于定位文件到文件尾部：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 定位到文件尾部</span>
_goToEnd(callback) {
  fs.fstat(<span class="hljs-keyword">this</span>._fd, (err, stats) =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    <span class="hljs-comment">// stats.size 即为文件末尾的位置</span>
    <span class="hljs-keyword">this</span>._position = stats.size;
    callback();
  });
}
</code></pre>
<p>相应地我们还要修改<code>_openFile()</code>方法：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 打开文件</span>
_openFile() {
  fs.open(<span class="hljs-keyword">this</span>._file, <span class="hljs-string">'r'</span>, (err, fd) =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    <span class="hljs-keyword">this</span>._fd = fd;

    <span class="hljs-keyword">const</span> done = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-comment">// 定位完成后开始监听文件变化和尝试读取数据</span>
      <span class="hljs-keyword">this</span>._watchFile();
      <span class="hljs-keyword">this</span>._ready = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>._tryRead();
    };

    <span class="hljs-comment">// 判断如果 this._position='end'则定位到文件尾部</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._position === <span class="hljs-string">'end'</span>) {
      <span class="hljs-keyword">this</span>._goToEnd(done);
    } <span class="hljs-keyword">else</span> {
      done();
    }
  });
}
</code></pre>
<p>说明：这里主要的改动为，打开文件后先判断如果<code>this._position = 'end'</code>，则调用<code>this._goToEnd()</code>定位到文件尾部，否则就可以直接尝试读取文件了。</p>
<p>如果在创建<code>TailStream</code>实例的时候指定<code>position = 'end'</code>，比如这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> file = process.argv[<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> TailStream({file, <span class="hljs-attr">position</span>: <span class="hljs-string">'end'</span>});
</code></pre>
<p>重新运行测试程序时，我们应该能发现启动后并没有输出任何信息，因为此时已经定位到末尾，并不会输出文件前部分的内容，仅当继续往文件写入内容时测试程序才会将内容显示出来。</p>
<h2><a id="_354"></a>停止</h2>
<p>上文我们实现的<code>TailStream</code>一旦开始就会源源不断地读取文件新增的内容，有时候就像没了脚刹的汽车，一旦加了油飙了车就根本停不下来了，想想还是很危险的。所以，接下来我们实现一个<code>close()</code>方法，这样就可以在合适的时候停车了：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 关闭</span>
close() {
  <span class="hljs-comment">// 关闭文件 watcher</span>
  <span class="hljs-keyword">this</span>._watcher.close();
  <span class="hljs-comment">// 关闭文件操作句柄</span>
  fs.close(<span class="hljs-keyword">this</span>._fd, err =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    <span class="hljs-comment">// 结束 stream</span>
    <span class="hljs-keyword">this</span>.push(<span class="hljs-literal">null</span>);
  });
}
</code></pre>
<h2><a id="_373"></a>暂停</h2>
<p>当文章读到这里的时候，你会想，现在已经完美地实现<code>TailStream</code>了吧？毕竟该有的功能都有了。可是，既然我们有了<code>close()</code>用来停止监听，为什么不能有一个暂停功能呢？</p>
<p>熟悉<code>Stream</code>的同学都知道，<code>readable.pause()</code>和<code>readable.resume()</code>这两个方法就可以用来暂停和继续，实际上，上文的代码不经任何修改也可以在各种使用<code>pause()</code>和<code>resume()</code>良好地工作。</p>
<p>在经过详细阅读 Node.js 相关的 API 文档之后，我们发现这三个概念：</p>
<ul>
<li><a href="https://nodejs.org/api/stream.html#stream_buffering">缓冲</a></li>
<li><a href="https://nodejs.org/api/stream.html#stream_two_modes">Readable Stream 的两种模式</a></li>
<li><a href="https://nodejs.org/api/stream.html#stream_three_states">Readable Stream 的三种状态</a></li>
</ul>
<p>从文档得知，<code>Readable Stream</code>有两种模式：流动（<strong>flowing</strong>）和暂停（<strong>paused</strong>）。初始状态下，<code>readable._readableState.flowing = null</code>，此时流处于暂停状态，并不会主动调用<code>readable._read(size)</code>来请求读取数据。</p>
<p>当执行以下操作时才切换到流动（<strong>flowing</strong>）状态：</p>
<ul>
<li>添加了一个<code>data</code>事件的监听器</li>
<li>执行了<code>readable.resume()</code></li>
<li>执行了<code>readable.pipe()</code></li>
</ul>
<p>如果执行了以上的任一操作，此时<code>readable._readableState.flowing = true</code>，流开始尝试调用<code>readable._read(size)</code>从底层资源中读取数据，并通过触发<code>data</code>事件消费这些数据，或者将其<code>pipe</code>到另一个流中。</p>
<p>当使用<code>readable.pause()</code>暂停之后，此时<code>readable._readableState.flowing = false</code>，如果我们还继续使用<code>readable.push()</code>来推送数据，数据实际上是被存储到缓冲区<code>readable._readableState.buffer</code>里面。当程序执行<code>readable.resume()</code>后，此时<code>readable._readableState.flowing = true</code>才会继续消费缓冲区内的数据。</p>
<p>在暂停状态下，我们也可以通过<code>readable.read()</code>去手动消费数据。</p>
<p>好了，我们现在来说说上文的程序存在的问题。在<code>_read()</code>里面，我们已经可以通过一个<code>this._ready</code>标记来判断流是否处于就绪状态从而决定是否要从文件中读取数据，而在暂停的情况下<code>Readable Stream</code>也不会胡乱调用<code>_read()</code>请求读取数据。</p>
<p>当文件内容改变时，会执行<code>_tryRead()</code>，在这个方法里面我们主动去调用<code>_read()</code>请求读取数据了。假如此时流正处于暂停状态，我们<strong>读取资源的操作还是不会被暂停，数据仍然会不停地推送到缓冲区，尽管从外表上看流还是处于暂停状态</strong>。</p>
<p>所以我们还要做的修改是，在调用<code>_read()</code>之前先判断一下<code>this._readableState.flowing</code>的状态：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 尝试读取数据</span>
_tryRead() {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._readableState.flowing) {
    <span class="hljs-comment">// 仅当 flowing=true 时才读取数据</span>
    <span class="hljs-keyword">this</span>._read(<span class="hljs-keyword">this</span>._getHighWaterMark());
  }
}
</code></pre>
<h2><a id="_416"></a>日志文件处理</h2>
<p>前面铺垫了那么多，终于要说到日志文件处理了。一般情况下，日志都是按行存储到文件里面的，在本文的例子中，我们要监听一个日志文件，把它新增的日志内容按行读取出来，简单处理之后实时地打印到屏幕上。</p>
<p>假如每一行都是一个 JSON 字符串，我们借助<code>lei-stream</code>模块编写一个用于模拟生成日志的程序<code>make_logs.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>);
<span class="hljs-keyword">const</span> writeLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).writeLine;

<span class="hljs-comment">// 创建写日志文件流</span>
<span class="hljs-keyword">const</span> s = writeLine(<span class="hljs-string">'test.log'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">'json'</span>});

<span class="hljs-comment">// 模拟日志输出</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextLog</span>(<span class="hljs-params"></span>) </span>{
  s.write({
    <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
    <span class="hljs-attr">loadavg</span>: os.loadavg(),
    <span class="hljs-attr">memoryUsage</span>: process.memoryUsage(),
  });
}
setInterval(nextLog, <span class="hljs-number">1000</span>);
</code></pre>
<p>在执行程序之前，我们还要安装<code>lei-stream</code>模块：</p>
<pre><code class="language-bash">$ npm install lei-stream
</code></pre>
<p>然后执行程序：</p>
<pre><code class="language-bash">$ node make_logs
</code></pre>
<p>此时程序已经在给我们生成日志了。现在开始编写处理日志的程序<code>watch_logs.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;
<span class="hljs-keyword">const</span> TailStream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./tail_stream'</span>);

<span class="hljs-comment">// 创建按行读取日志文件流</span>
<span class="hljs-keyword">const</span> s = readLine(<span class="hljs-keyword">new</span> TailStream({
  <span class="hljs-attr">file</span>: <span class="hljs-string">'test.log'</span>,  <span class="hljs-comment">// 日志文件名</span>
  position: <span class="hljs-string">'end'</span>,   <span class="hljs-comment">// 定位到尾部</span>
}), {
  <span class="hljs-attr">encoding</span>: <span class="hljs-string">'json'</span>,  <span class="hljs-comment">// 使用 JSON 编码</span>
  autoNext: <span class="hljs-literal">false</span>,   <span class="hljs-comment">// 不自动读下一行</span>
});

s.on(<span class="hljs-string">'data'</span>, data =&gt; {
  <span class="hljs-comment">// 将日志打印到屏幕</span>
  <span class="hljs-built_in">console</span>.log(data);
  <span class="hljs-comment">// 处理完后调用 next()继续读取下一行</span>
  s.next();
});
</code></pre>
<p>执行以下命令启动日志监听程序：</p>
<pre><code class="language-bash">$ node watch_logs
</code></pre>
<p>稍等几秒，应该会看到屏幕不断地打印出这样的信息出来：</p>
<pre><code>{ time: '2016-07-24T02:18:11.325Z',
  loadavg: [ 2.31494140625, 2.4052734375, 2.19775390625 ],
  memoryUsage: { rss: 22818816, heapTotal: 8384512, heapUsed: 5224824 } }
{ time: '2016-07-24T02:18:12.331Z',
  loadavg: [ 2.31494140625, 2.4052734375, 2.19775390625 ],
  memoryUsage: { rss: 22818816, heapTotal: 8384512, heapUsed: 5226688 } }
</code></pre>
<p><strong>注意：在这个实例中，我们是直接定位到日志文件末尾开始，在新增日志数据量较大的情况下，有可能定位到的位置是在一行日志数据的中间部分，也就是说可能出现读取出来的第一条日志是不完整的（只有后半部分），因此要根据实际情况做相应的容错处理。</strong></p>
<h2><a id="_499"></a>谁更机智</h2>
<p>当我编写完文章<a href="http://morning.work/page/2016-07/how-to-implement-a-tail-f-command-in-nodejs.html">《如何实时监听文件的新增内容：一个简单 tailf 命令的实现》</a>之后，机智的小伙伴指出，要完成这样的功能最简单的方法是用<code>child_process</code>，我想象出来的代码应该是这样的：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> child_process = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TailStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">stream</span>.<span class="hljs-title">Readable</span> </span>{

  <span class="hljs-comment">/**
   * TailStream
   *
   * @param {Object} options
   *   - {String} file 文件名
   */</span>
  <span class="hljs-keyword">constructor</span>(options) {
    options = options || {};
    <span class="hljs-comment">// 调用基类的构造函数</span>
    <span class="hljs-keyword">super</span>(options);
    <span class="hljs-comment">// 文件名</span>
    <span class="hljs-keyword">this</span>._file = options.file;
    <span class="hljs-comment">// 执行 tail 命令</span>
    <span class="hljs-keyword">this</span>._process = child_process.spawn(<span class="hljs-string">'tail'</span>, [<span class="hljs-string">'-c'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'-f'</span>, options.file], {
      <span class="hljs-attr">cwd</span>: __dirname,
    });
    <span class="hljs-keyword">this</span>._process.on(<span class="hljs-string">'error'</span>, err =&gt; <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err));
    <span class="hljs-comment">// 将收到的数据推送到缓冲区</span>
    <span class="hljs-keyword">this</span>._process.stdout.on(<span class="hljs-string">'data'</span>, data =&gt; {
      <span class="hljs-keyword">this</span>.push(data);
    });
    <span class="hljs-comment">// 如果进程执行结束则关闭流</span>
    <span class="hljs-keyword">this</span>._process.on(<span class="hljs-string">'exit'</span>, () =&gt; {
      <span class="hljs-keyword">this</span>.push(<span class="hljs-literal">null</span>);
    });
  }

  <span class="hljs-comment">// 读取数据</span>
  _read(size) {
    <span class="hljs-comment">// 不需要做任何事情</span>
  }

  <span class="hljs-comment">// 关闭</span>
  close() {
    <span class="hljs-keyword">this</span>._process.kill();
  }

}

<span class="hljs-built_in">module</span>.exports = TailStream;
</code></pre>
<p>说明：</p>
<ul>
<li>使用<code>child_process.spawn()</code>来执行<code>tail</code>命令监听文件，并将进程的输出作为<code>TailStream</code>的数据推送出去</li>
<li>这种实现方式只适用于有<code>tail</code>命令的系统，比如 Windows 这种是没有自动该命令的</li>
<li>这种方式看起来简单，但是程序执行的开销会比完全使用 Node.js 来实现要大</li>
</ul>
<h2><a id="_560"></a>总结</h2>
<p>本文首先实现了一个简单的<code>TailStream</code>来监听文件的新增内容，另外针对可能存在的问题给出了相应的解决方案，最后结合<code>lei-stream</code>实现了一个处理日志文件的例子。对于实现一个<code>Readable Stream</code>而言，简单地实现一个<code>_read(size)</code>方法即可，但是为了让这个<code>Stream</code>表现的更好，我们可能还有根据各自不同的场景去做一些处理。</p>
<p><strong>实现一个<code>Readable Stream</code>的重要意义是，通过这些已被大家熟知的标准来让不同系统模块之间的协作变得更简单，而不是实现各自五花八门的接口。</strong></p>
<h2><a id="_567"></a>相关链接</h2>
<ul>
<li><a href="http://tech.meituan.com/stream-basics.html">Node.js Stream - 基础篇</a></li>
<li><a href="https://nodejs.org/api/stream.html">Stream - Node.js API</a></li>
<li><a href="http://morning.work/page/2016-07/how-to-implement-a-tail-f-command-in-nodejs.html">如何实时监听文件的新增内容：一个简单 tailf 命令的实现</a></li>
<li><a href="http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html">在 Node.js 中读写大文件</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-07/readable-stream-and-log-files-processing-in-nodejs.html</link><guid isPermaLink="true">http://morning.work/page/2016-07/readable-stream-and-log-files-processing-in-nodejs.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Sun, 24 Jul 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[如何实时监听文件的新增内容：一个简单 tailf 命令的实现]]></title><description><![CDATA[<blockquote>
<p>在 Linux/Uinx 系统上，有一个<code>tail</code>命令，它可以用来显示一个文件尾部的内容，比如执行<code>tail large_file.txt</code>仅仅显示该文件最后的 10 行内容（通过<code>-n</code>参数可以指定显示的行数）。</p>
<p><code>tail</code>命令还有一个<code>-f</code>选项，可以监听文件内容的变化，当有新增的内容时会继续打印到屏幕上，因此在处理日志文件时常常会使用到它来跟踪文件变化。</p>
</blockquote>
<p>前段时间在研究 Node.js 上的日志文件的处理时，偶然得知<code>tail -f</code>命令（下文简称<code>tailf</code>）的用法，因此十分好奇，<strong>Node.js 的 fs 模块是否有一种 API 可以实时监听文件内容的变化，并可以从中不断地读出新增的内容？</strong>，当然答案是否定的。后来经过网上查找资料，发现其实原理很简单，无非是不断地尝试<code>read()</code>文件的内容，如果能读取到就输出，仅此而已。</p>
<p>首先从网上找到一段<a href="http://stackoverflow.com/questions/557844/java-io-implementation-of-unix-linux-tail-f?answertab=active#tab-top">使用 Java 实现 tail -f 的代码</a>：</p>
<pre><code class="language-java">BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(...);
String line;
<span class="hljs-keyword">while</span> (keepReading) {
    line = reader.readLine();
    <span class="hljs-keyword">if</span> (line == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">//wait until there is more of the file for us to read</span>
        Thread.sleep(<span class="hljs-number">1000</span>);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//do something interesting with the line</span>
    }
}
</code></pre>
<p>从上面的程序逻辑可以看出，在<code>while</code>循环里面，不断地尝试<code>readLine()</code>来读取一行内容，如果读取成功就继续，不成功则先<code>sleep(1000)</code>等待 1 秒钟。</p>
<h2><a id="_tailf_27"></a>实现一个简单的 tailf</h2>
<p>因此我们可以使用以下 Node.js 代码实现相似的功能：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">/**
 * tailf
 *
 * @param {String} filename 文件名
 * @param {Number} delay 读取不到内容时等待的时间，ms
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tailf</span>(<span class="hljs-params">filename, delay</span>) </span>{

  <span class="hljs-comment">// 每次读取文件块大小，16K</span>
  <span class="hljs-keyword">const</span> CHUNK_SIZE = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>;
  <span class="hljs-comment">// 打开文件，获取文件句柄</span>
  <span class="hljs-keyword">const</span> fd = fs.openSync(filename, <span class="hljs-string">'r'</span>);
  <span class="hljs-comment">// 文件开始位置</span>
  <span class="hljs-keyword">let</span> position = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 循环读取</span>
  <span class="hljs-keyword">const</span> loop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

    <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(CHUNK_SIZE);
    <span class="hljs-keyword">const</span> bytesRead = fs.readSync(fd, buf, <span class="hljs-number">0</span>, CHUNK_SIZE, position);
    <span class="hljs-comment">// 实际读取的内容长度以 bytesRead 为准，并且更新 position 位置</span>
    position += bytesRead;
    process.stdout.write(buf.slice(<span class="hljs-number">0</span>, bytesRead));

    <span class="hljs-keyword">if</span> (bytesRead &lt; CHUNK_SIZE) {
      <span class="hljs-comment">// 如果当前已到达文件末尾，则先等待一段时间再继续</span>
      setTimeout(loop, delay);
    } <span class="hljs-keyword">else</span> {
      loop();
    }
  };
  loop();
}
</code></pre>
<p>说明：</p>
<ul>
<li>首先使用<code>fs.openSync()</code>来打开文件，得到文件句柄之后，再通过<code>fs.readSync()</code>读取文件内容</li>
<li>由于 Node.js 中并没有阻塞的<code>sleep()</code>方法，我们只能使用<code>setTimeout()</code>来模拟，不能直接使用<code>while</code>死循环，否则程序会占满整个 CPU 资源</li>
</ul>
<p>将以上的代码保存为文件<code>tailf.js</code>，并且在文件末尾增加以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> filename = process.argv[<span class="hljs-number">2</span>];
<span class="hljs-keyword">if</span> (filename) {
  tailf(filename, <span class="hljs-number">100</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'使用方法： node tailf &lt;文件名&gt;'</span>);
}
</code></pre>
<p>现在我们来测试一下。首先执行以下命令新建一个日志文件：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; test.log
</code></pre>
<p>然后再开始监听文件的变化：</p>
<pre><code class="language-bash">$ node tailf test.log
</code></pre>
<p>执行以上命令后，可以看到屏幕上打印出内容<code>hello</code>，但是程序还没有结束。再尝试在另一个控制台窗口下执行以下命令：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$(date)</span> hello, world"</span> &gt;&gt; test.log
</code></pre>
<p>如果能看到<code>tailf</code>屏幕上打印出<code>Sat Jul 23 01:46:05 CST 2016 hello, world</code>这样的内容，说明我们实现的这个<code>tailf</code>命令已经基本上能用了。我们也不妨多执行几次上面的命令，还可以把<code>hello, world</code>改成其他的内容，好好感受一下，有木有一股很强的成就感迎面吹来呢……</p>
<h2><a id="_107"></a>从文件末尾开始</h2>
<p>上面的程序有一个小问题：每次执行<code>tailf</code>时都会先从头读取一遍文件，然后才开始监听，假如我们是用来处理很大的日志文件，每次都重头读取一遍似乎不太好，也对不起<code>tail</code>这个单词。所以呢，我们机智地修改一行代码解决它吧：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 文件开始位置</span>
<span class="hljs-keyword">let</span> position = fs.fstatSync(fd).size;
</code></pre>
<p>说明：通过<code>fs.fstatSync()</code>读取文件的属性，然后得到当前文件的尺寸，直接把<code>position</code>设置到文件最末尾就行啦。</p>
<h2><a id="_119"></a>使用异步方法</h2>
<p>为了使得程序简单清晰，上文的程序用的都是<code>Sync</code>后缀的方法，这在只处理一个任务的<code>tailf</code>命令是最简单直接的。假如我们要实现一个<code>tailf</code>函数，将它嵌入到我们编写的项目里面处理多个监听文件内容的任务，那就得使用非阻塞的方法来操作文件了：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">/**
 * tailf
 *
 * @param {String} filename 文件名
 * @param {Number} delay 读取不到内容时等待的时间，ms
 * @param {Function} onError 操作出错时的回调函数，onError(err)
 * @param {Function} onData 读取到文件内容时的回调函数，onData(data)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tailf</span>(<span class="hljs-params">filename, delay, onError, onData</span>) </span>{

  <span class="hljs-comment">// 每次读取文件块大小，16K</span>
  <span class="hljs-keyword">const</span> CHUNK_SIZE = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>;
  <span class="hljs-comment">// 打开文件，获取文件句柄</span>
  fs.open(filename, <span class="hljs-string">'r'</span>, (err, fd) =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> onError(err);

    <span class="hljs-comment">// 文件开始位置</span>
    fs.fstat(fd, (err, stats) =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> onError(err);

      <span class="hljs-comment">// 文件开始位置</span>
      <span class="hljs-keyword">let</span> position = stats.size;
      <span class="hljs-comment">// 循环读取</span>
      <span class="hljs-keyword">const</span> loop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

        <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(CHUNK_SIZE);
        fs.read(fd, buf, <span class="hljs-number">0</span>, CHUNK_SIZE, position,
        (err, bytesRead, buf) =&gt; {
          <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> onError(err);

          <span class="hljs-comment">// 实际读取的内容长度以 bytesRead 为准</span>
          <span class="hljs-comment">// 并且更新 position 位置</span>
          position += bytesRead;
          onData(buf.slice(<span class="hljs-number">0</span>, bytesRead));

          <span class="hljs-keyword">if</span> (bytesRead &lt; CHUNK_SIZE) {
            <span class="hljs-comment">// 如果当前已到达文件末尾，则先等待一段时间再继续</span>
            setTimeout(loop, delay);
          } <span class="hljs-keyword">else</span> {
            loop();
          }
        });
      };
      loop();
    });
  });
}
</code></pre>
<p>说明：</p>
<ul>
<li>所有操作文件的方法去掉<code>Sync</code>后缀，改用回调函数获取结果</li>
<li><code>tailf</code>新增了两个参数<code>onError</code>和<code>onData</code>，分别用来回调操作时发生错误和检测到文件内容更新，其中<code>onData</code>会被执行多次</li>
</ul>
<p>现在可以这样使用<code>tailf()</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> filename = process.argv[<span class="hljs-number">2</span>];
<span class="hljs-keyword">if</span> (filename) {
  tailf(filename, <span class="hljs-number">100</span>, err =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
  }, data =&gt; {
    process.stdout.write(data);
  });
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'使用方法： node tailf &lt;文件名&gt;'</span>);
}
</code></pre>
<p>测试方法还是跟上文的一样，当然这么简单的场景根本看不出区别啦。</p>
<h2><a id="_200"></a>更好的性能？</h2>
<p>在本文初稿完成后，很多机智的读者指出，Linux 的<code>tailf</code>是使用<code>inotify</code>来实现的，以下文字是摘自<a href="http://baike.baidu.com/view/2645027.htm">百度百科关于 Inotify 的介绍</a>：</p>
<blockquote>
<p>Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。</p>
<p>使用 inotify 很简单：创建一个文件描述符，附加一个或多个监视器（一个监视器 是一个路径和一组事件），然后使用 read 方法从描述符获取事件。read 并不会用光整个周期，它在事件发生之前是被阻塞的。</p>
<p>更好的是，因为 inotify 通过传统的文件描述符工作，您可以利用传统的 select 系统调用来被动地监控监视器和许多其他输入源。两种方法 — 阻塞文件描述符和使用 select— 都避免了繁忙轮询。</p>
</blockquote>
<p>简而言之，在本文实现的例子中，我们可以借助 Inotify 来监听文件的变化，如果文件内容有改变就立即尝试取读取，从而避免通过<code>setTimeout(loop, delay)</code>来轮询，这样看起来会更高效一些吧。</p>
<p>在 NPM 上有有一个 <a href="https://www.npmjs.com/package/inotify">inotify 模块</a>，其简介为<strong>inotify bindings for v8 javascript engine</strong>，由此可以确定这正是我们需要的一个模块。</p>
<p>但当尝试在我的 Mac 上安装此模块时并没成功，由出错信息判断应该是这个模块并不兼容 Mac 系统：</p>
<pre><code>npm ERR! notsup Not compatible with your operating system or architecture: inotify@1.4.1
npm ERR! notsup Valid OS:    linux
npm ERR! notsup Valid Arch:  any
npm ERR! notsup Actual OS:   darwin
npm ERR! notsup Actual Arch: x64
</code></pre>
<p>所幸的是 Node.js API 提供了<code>fs.watch(filename[, options][, listener])</code>可以让我们监听文件的变化，因此我们可以使用它来代替轮询实现更高效率的监听读取。</p>
<p>基于上文异步版本的<code>tailf()</code>，我们可以将<code>loop()</code>函数改成这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> loop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

  <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(CHUNK_SIZE);
  fs.read(fd, buf, <span class="hljs-number">0</span>, CHUNK_SIZE, position,
  (err, bytesRead, buf) =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> onError(err);

    <span class="hljs-comment">// 实际读取的内容长度以 bytesRead 为准，并且更新 position 位置</span>
    position += bytesRead;
    onData(buf.slice(<span class="hljs-number">0</span>, bytesRead));

    <span class="hljs-keyword">if</span> (bytesRead &lt; CHUNK_SIZE) {
      <span class="hljs-comment">// 如果当前已到达文件末尾，则等待 change 事件再尝试读取</span>
    } <span class="hljs-keyword">else</span> {
      loop();
    }
  });
};
loop();

<span class="hljs-comment">// 监听文件变化，如果收到 change 事件则尝试读取文件内容</span>
fs.watch(filename, (event, filename) =&gt; {
  <span class="hljs-keyword">if</span> (event === <span class="hljs-string">'change'</span>) {
    loop();
  }
});
</code></pre>
<p>说明：</p>
<ul>
<li>去掉了读取到文件末尾后的<code>setTimeout(loop, delay)</code></li>
<li>增加<code>fs.watch()</code>来监听文件的变化，如果发现有<code>change</code>事件则调用<code>loop()</code>尝试读取文件</li>
</ul>
<p>另外我们也可以去掉<code>tailf</code>函数的<code>delay</code>参数：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tailf</span>(<span class="hljs-params">filename, onError, onData</span>) </span>{
</code></pre>
<p>测试程序也不需要传递相应的参数。再重新按照上文的方法来测试时，发现新的程序在我的 Mac 系统上也能工作良好。</p>
<h2><a id="_271"></a>总结</h2>
<p>在文章前半部分，我们使用最简单的轮询方法实现了<code>tailf</code>，但是在效率上可能并不能满足我们对效率的要求。此时我们可以尝试使用一些系统 API 来监听到文件被修改的事件，从而代替低效的轮询。但是使用这些高级的 API 可能在不同的操作系统上得不到完整的支持，当然使用 Node.js 内置的 API 应该是兼容性最好的，本文的例子并没有在 Windows 上运行测试过。</p>
<h2><a id="_276"></a>相关链接</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/557844/java-io-implementation-of-unix-linux-tail-f">Java IO implementation of unix/linux “tail -f”</a></li>
<li><a href="http://stackoverflow.com/questions/1703640/how-to-implement-a-pythonic-equivalent-of-tail-f">How to implement a pythonic equivalent of tail -F?</a></li>
<li><a href="http://codingstandards.iteye.com/blog/832760">我使用过的 Linux 命令之 tailf - 跟踪日志文件/更好的 tail -f 版本</a></li>
<li><a href="http://linux.die.net/man/7/inotify">inotify API - Linux man page</a></li>
<li><a href="http://www.infoq.com/cn/articles/inotify-linux-file-system-event-monitoring/">Inotify: 高效、实时的 Linux 文件系统事件监控框架</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-07/how-to-implement-a-tail-f-command-in-nodejs.html</link><guid isPermaLink="true">http://morning.work/page/2016-07/how-to-implement-a-tail-f-command-in-nodejs.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Sat, 23 Jul 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES2015 & babel 实战：开发 NPM 模块]]></title><description><![CDATA[<h2><a id="_3"></a>前言</h2>
<p>近一年来，JavaScript 界关于 ES6（ECMAScript 6，本文简称 ES6）的讨论越来激烈，作为未来要统一全宇宙的语言（<strong>PHP 是世界上最好的语言，但 JavaScript 终将统一全宇宙</strong>），JavaScript 的运行环境众多，对 ECMAScript 标准的支持程度不一，所以对于 ES6 我一直处于观望状态。</p>
<p>前不久 ES6 标准正式发布，而 Node.js 也在最近刚刚发布了 5.1.0 版本，对 ES6 标准的支持也越来越完善，babel（一个将 ES6/ES7 写的代码转换为 ES5 代码的编译器）也发布了 6.0 版本，近期也涌现出了不少好文章（比如<a href="http://lifemap.in/">小问</a>写的<a href="http://gank.io/post/564151c1f1df1210001c9161">「给 JavaScript 初心者的 ES2015 实战」</a>），种种迹象表明 ES6 真的要火了，而我也终于按耐不住了……</p>
<p>这几天正在写一个<a href="https://github.com/leizongmin/node-lei-download">方便下载文件的模块</a>（可以得到下载进度信息），正好可以使用 ES6 新语法特性来改写，作为我写下的第一个使用 ES6 语法的 NPM 模块。本文内容将分为以下几部分：</p>
<ul>
<li>配置 babel 编译环境</li>
<li>编写模块</li>
<li>单元测试</li>
<li>发布模块</li>
</ul>
<p>本文的重点是介绍借助 babel 开发 Node.js 项目的基本方法，同时会简略介绍文中出现的 ES2015 新语法，具体介绍可阅读<a href="http://www.ruanyifeng.com">阮一峰</a>所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门」</a>或 babel 官方文档中的<a href="http://babeljs.io/docs/learn-es2015/">「Learn ES2015」</a>。</p>
<p>babel 官方提供了一个<a href="http://babeljs.io/repl">在线 REPL</a>，可以实时输出转换后的 JavaScript 代码，并且看到其运行结果，对于初学者尤为有用。访问网址 <a href="http://babeljs.io/repl">http://babeljs.io/repl</a> ，其界面如下：</p>
<p><img src="../../images/2015-11/babel_online_repl.jpg" alt="babel online repl"></p>
<p>说明：使用时勾选左边的<code>Experimental</code>可使用最新的语法特性。</p>
<h2><a id="_25"></a>软件环境</h2>
<p>由于相关软件和模块正处于高速发展期，无法保证你阅读这篇文章的时候还能照着一步一步<strong>准确无误</strong>地运行下去，以下列出在编写本文时所用到的软件和模块的版本：</p>
<ul>
<li><strong>Node.js</strong> <code>v5.1.0</code></li>
<li><strong>npm</strong> <code>3.3.12</code></li>
<li><strong>babel</strong> <code>6.2.0 (babel-core 6.2.1)</code></li>
<li><strong>mocha</strong> <code>2.3.4</code></li>
</ul>
<h2><a id="_babel__34"></a>配置 babel 编译环境</h2>
<h3><a id="1_babel_36"></a>1、安装 babel</h3>
<blockquote>
<p>Babel is a JavaScript compiler. Use next generation JavaScript, today</p>
</blockquote>
<p>目前最新版的 Node.js（v5.1.0）还未完全支持 ES2015 的新语法特性，而且我们编写的模块可能要在 Node v0.12.x 或更低版本下运行，因此需要借助 babel 将 ES2015 标准的 JavaScript 程序转换成 ES5 标准的。</p>
<p>执行以下命令安装 babel：</p>
<pre><code class="language-bash">$ npm i -g babel-cli
</code></pre>
<p>由于 babel 依赖的模块比较多，可能会花费比较长的时间甚至安装不成功，可以尝试使用 cnpmjs 的 NPM 镜像，比如（简单在安装命令末尾添加<code>--registry=http://registry.npm.taobao.org</code>）：</p>
<pre><code class="language-bash">$ npm i -g babel-cli --registry=http://registry.npm.taobao.org
</code></pre>
<p><a href="http://cnpmjs.org/">cnpmjs</a>镜像的详细介绍可访问其官网：<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></p>
<p>安装完成后，系统将获得以下两个命令：</p>
<ul>
<li><code>babel</code> 编译器</li>
<li><code>babel-node</code> 可以直接运行 ES2015 程序的 Node 命令</li>
</ul>
<p><code>babel-cli</code>的详细用法可以参考其文档：<a href="https://babeljs.io/docs/usage/cli/">https://babeljs.io/docs/usage/cli/</a></p>
<h3><a id="2_63"></a>2、初始化项目</h3>
<p>执行以下命令初始化项目（执行<code>npm init</code>时需要按提示输入相应信息，可直接按回车跳过）：</p>
<pre><code class="language-bash">$ mkdir es2015_demo &amp;&amp; <span class="hljs-built_in">cd</span> es2015_demo &amp;&amp; git init &amp;&amp; npm init
</code></pre>
<p>现在我们新建一个文件<code>test.js</code>试试是否能正常运行：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">500</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i=<span class="hljs-subst">${i}</span>`</span>);
  }
}

test().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>));
</code></pre>
<p>执行以下命令运行<code>test.js</code>：</p>
<pre><code class="language-bash">$ babel-node test.js
</code></pre>
<p>在我本机的环境下显示以下错误信息：</p>
<pre><code>/usr/local/lib/node_modules/babel-cli/node_modules/babel-core/lib/transformation/file/index.js:540
      throw err;
      ^

SyntaxError: /private/tmp/es2015_demo/test.js: Unexpected token (5:6)
  3 | }
  4 |
&gt; 5 | async function test() {
    |       ^
  6 |   for (let i = 0; i &lt; 10; i++) {
  7 |     await sleep(500);
  8 |     console.log(`i=${i}`);

...
</code></pre>
<p>由提示信息可判断出，应该是不支持<code>async function</code>导致的，因为这是 ES7 标准中定义的新语法，需要配置相应的 babel 插件才能支持它。本文为了方面使用最新的 JavaScript 语法，暂时不考虑 babel 的编译性能，直接开启所有可能用到的插件，具体可以自行研究 babel 的官方文档。</p>
<p>新建文件<code>.babelrc</code>：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"es2015"</span>, <span class="hljs-string">"stage-0"</span>]
}
</code></pre>
<p><code>.babelrc</code>为 babel 的配置文件，保存在项目的根目录下，其中<code>presets</code>用于设置开启的语法特性集合，详细介绍可参考官方文档：<a href="https://babeljs.io/docs/usage/babelrc/">https://babeljs.io/docs/usage/babelrc/</a> 和 <a href="http://babeljs.io/docs/plugins/#presets">http://babeljs.io/docs/plugins/#presets</a></p>
<p>接下来我们还需要安装插件依赖的模块，执行以下命令安装并保存到<code>package.json</code>的<code>devDependencies</code>中：</p>
<pre><code class="language-bash">$ npm i babel-preset-es2015 babel-preset-stage-0 --save-dev
</code></pre>
<p>现在再重新执行<code>test.js</code>，可看到控制台每隔 500ms 打印出一行，直到输出<code>done</code>时结束：</p>
<pre><code class="language-bash">$ babel-node test.js

i=0
i=1
i=2
i=3
i=4
i=5
i=6
i=7
i=8
i=9
<span class="hljs-keyword">done</span>
</code></pre>
<h3><a id="3_149"></a>3、编译程序</h3>
<p>在发布项目时，要求可以在不依赖 babel 编译器的环境下运行，因此我们需要将 ES2015 的程序编译成 ES5 的：</p>
<pre><code class="language-bash">$ babel test.js --out-file test.compiled.js
</code></pre>
<p>执行上面的命令后，生成了编译后的文件<code>test.compiled.js</code>，我们尝试执行它看看：</p>
<pre><code class="language-bash">$ node test.compiled.js
</code></pre>
<p>在我的系统环境下提示以下出错信息：</p>
<pre><code>/private/tmp/es2015_demo/test.compiled.js:4
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                              ^

ReferenceError: regeneratorRuntime is not defined
    at /private/tmp/es2015_demo/test.compiled.js:4:31

...
</code></pre>
<p>经阅读官方文档可知，编译后的 JavaScript 程序有时候需要依赖一些运行时<code>polyfill</code>，通过安装<code>babel-polyfill</code>模块来获得：</p>
<pre><code class="language-bash">$ npm i babel-polyfill --save
</code></pre>
<p>然后，我们需要修改编译后的文件<code>test.compiled.js</code>，在其首行加上以下代码来载入<code>babel-polyfill</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-polyfill'</span>);
</code></pre>
<p>再次执行<code>test.compiled.js</code>便可看到与<code>$ babel-node test.js</code>一样的结果。</p>
<p><code>polyfill</code>的详细介绍可参考官方文档：<a href="http://babeljs.io/docs/usage/polyfill/">http://babeljs.io/docs/usage/polyfill/</a></p>
<p>至此，我们已经配置了一个能使用 ES2015 语法的 Node.js 运行环境了。</p>
<h3><a id="4_194"></a>4、重要提示</h3>
<p>在一个 Node.js 进程中只能载入一个版本的<code>babel-polyfill</code>，不同的模块所<code>require('babel-polyfill')</code>很可能不是同一个版本，此时进程会抛出一个异常并退出，所以一般建议在打包的 NPM 模块中不要有<code>require('babel-polyfill')</code>，而是要求在使用该模块的最终项目自行编写<code>require('babel-polyfill')</code>，这样可以保证一个进程中只会有一个<code>babel-polyfill</code>版本。</p>
<h2><a id="_199"></a>编写模块</h2>
<h3><a id="1_201"></a>1、功能描述</h3>
<p>本文以<a href="https://github.com/leizongmin/node-lei-download">lei-download</a>模块为例，该模块是一个主要功能是根据一个 URL 来下载文件到本地，或者本地直接文件的复制，同时提供下载/复制进度信息。其使用方法如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> download = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-download'</span>);

<span class="hljs-keyword">let</span> source = <span class="hljs-string">'一个 URL 或者本地文件名'</span>;
<span class="hljs-keyword">let</span> target = <span class="hljs-string">'要存储到的本地位置，null|false|undefined 表示自动生成一个临时文件'</span>;
<span class="hljs-comment">// 用于获取进度通知的函数，可以省略</span>
<span class="hljs-keyword">let</span> progress = <span class="hljs-function">(<span class="hljs-params">size, total</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度：<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>);

download(source, target, progress)
  .then(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到：<span class="hljs-subst">${filename}</span>`</span>))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));

<span class="hljs-comment">// 也可以使用 callback 模式</span>
download(source, target, progress, (err, filename) =&gt; {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到：<span class="hljs-subst">${filename}</span>`</span>);
});
</code></pre>
<p>在编写模块时，我们首先要实现以下两个函数的功能：</p>
<ul>
<li><code>downloadFile(source, target, progress)</code> 从一个 URL 下载文件并保存到本地</li>
<li><code>copyFile(source, target, progress)</code> 复制一个本地文件</li>
</ul>
<p>然后再编写一个<code>download()</code>函数来判断<code>source</code>参数，并选择使用<code>downloadFile()</code>或者<code>copyFile()</code>来完成请求。</p>
<h3><a id="2_231"></a>2、编写程序</h3>
<p>在本项目中，所有的 ES2015 源程序均保存在<code>src</code>目录下，发布项目时会执行相应的命令将其编译并输出到<code>lib</code>目录，具体方法在 <strong>「发布模块」</strong> 小节中介绍。</p>
<p>实现<code>copyFile()</code>函数，新建文件<code>src/copy.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyFile</span>(<span class="hljs-params">source, target, progress</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

    fs.stat(source, (err, stats) =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> reject(err);

      <span class="hljs-keyword">let</span> ss = fs.createReadStream(source);
      <span class="hljs-keyword">let</span> ts = fs.createWriteStream(target);
      ss.on(<span class="hljs-string">'error'</span>, reject);
      ts.on(<span class="hljs-string">'error'</span>, reject);

      <span class="hljs-keyword">let</span> copySize = <span class="hljs-number">0</span>;
      ss.on(<span class="hljs-string">'data'</span>, data =&gt; {
        copySize += data.length;
        progress &amp;&amp; progress(copySize, stats.size);
      });

      ss.on(<span class="hljs-string">'end'</span>, () =&gt; resolve(target));

      ss.pipe(ts);
    });

  });
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>import fs from 'fs'</code>为 ES2015 模块系统加载模块的方式，可理解为<code>var fs = require('fs')</code>，具体在下文「模块系统」一节中介绍。</li>
<li>通过<code>fs.createReadStream(source)</code>和<code>fs.createWriteStream(target)</code>来创建读取文件流和写入文件流，并监听读取文件流的<code>data</code>事件获得当前进度信息。</li>
<li><code>export default function copyFile() {}</code>将函数<code>copyFile()</code>作为模块输出，相当于<code>module.exports = function copyFile() {}</code>，具体在下文「模块系统」一节中介绍。</li>
<li>函数执行后返回一个<code>Promise</code>对象，通过其<code>.then()</code>和<code>.catch()</code>来获取执行结果，关于 Promise 的详细介绍可阅读<a href="http://www.ruanyifeng.com">阮一峰</a>所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门 」</a>中<a href="http://es6.ruanyifeng.com/#docs/promise">「 Promise 对象」</a>一章。</li>
</ul>
<p>为了测试该代码能否正常工作，可在文件末尾增加以下测试程序（在编写单元测试时将删除）：</p>
<pre><code class="language-javascript">copyFile(__filename, <span class="hljs-string">'/tmp/copy.js'</span>, (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>))
  .then(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到<span class="hljs-subst">${filename}</span>`</span>))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));
</code></pre>
<p>以上程序的作用是将当前 JavaScript 文件复制到<code>/tmp/copy.js</code>，使用<code>babel-node</code>执行该文件将得到以下结果：</p>
<pre><code class="language-bash">$ babel-node src/copy.js

进度 749/749
已保存到/tmp/copy.js
</code></pre>
<p>实现<code>downloadFile()</code>函数，新建文件<code>src/download.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'request'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadFile</span>(<span class="hljs-params">url, target, progress</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

    <span class="hljs-keyword">let</span> s = fs.createWriteStream(target);
    s.on(<span class="hljs-string">'error'</span>, reject);

    <span class="hljs-keyword">let</span> totalSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> downloadSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> req = request
      .get({
        <span class="hljs-attr">url</span>: url,
        <span class="hljs-attr">encoding</span>: <span class="hljs-literal">null</span>
      })
      .on(<span class="hljs-string">'response'</span>, res =&gt; {
        <span class="hljs-keyword">if</span> (res.statusCode !== <span class="hljs-number">200</span>) {
          <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'status #'</span> + res.statusCode));
        }
        totalSize = <span class="hljs-built_in">Number</span>(res.headers[<span class="hljs-string">'content-length'</span>]) || <span class="hljs-literal">null</span>;

        res.on(<span class="hljs-string">'data'</span>, data =&gt; {
          downloadSize += data.length;
          progress &amp;&amp; progress(downloadSize, totalSize);
        });
        res.on(<span class="hljs-string">'end'</span>, () =&gt; resolve(target));
      })
      .pipe(s);

  });
}
</code></pre>
<p>说明：</p>
<ul>
<li>程序使用<code>request</code>模块来下载 URL 的内容，使用时执行命令<code>$ npm i request --save</code>安装该模块。</li>
<li>通过<code>request</code>模块的<code>pipe()</code>方法将收到的数据写入到<code>fs.createWriteStream(target)</code>创建的写入文件流中，<code>request</code>模块的详细使用方法可参考其文档：<a href="https://www.npmjs.com/package/request">https://www.npmjs.com/package/request</a></li>
</ul>
<p>为了测试该代码能否正常工作，可在文件末尾增加以下测试程序（在编写单元测试时将删除）：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">'http://dn-cnodestatic.qbox.me/public/images/cnodejs_light.svg'</span>;
downloadFile(url, <span class="hljs-string">'/tmp/avatar.jpg'</span>, (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>))
  .then(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到<span class="hljs-subst">${filename}</span>`</span>))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));
</code></pre>
<p>以上程序的作用是将 URL 为<code>http://dn-cnodestatic.qbox.me/public/images/cnodejs_light.svg</code>的文件复制到<code>/tmp/avatar.jpg</code>，使用<code>babel-node</code>执行该文件将得到以下结果：</p>
<pre><code class="language-bash">$ babel-node src/download.js

进度 5944/5944
已保存到/tmp/avatar.jpg
</code></pre>
<p>实现<code>download()</code>函数，新建文件<code>src/index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> os <span class="hljs-keyword">from</span> <span class="hljs-string">'os'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> mkdirp <span class="hljs-keyword">from</span> <span class="hljs-string">'mkdirp'</span>;
<span class="hljs-keyword">import</span> copyFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./copy'</span>;
<span class="hljs-keyword">import</span> downloadFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./download'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params">source, target, progress</span>) </span>{
  target = target || randomFilename(download.tmpDir);
  progress = progress || noop;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

    mkdirp(path.dirname(target), err =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> callback(err);

      resolve((isURL(source) ? downloadFile : copyFile)
        (source, target, progress));
    });

  });
}

<span class="hljs-keyword">let</span> getTmpDir = os.tmpdir || os.tmpDir;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomString</span>(<span class="hljs-params">size = <span class="hljs-number">6</span>, chars = <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz0123456789'</span></span>) </span>{
  <span class="hljs-keyword">let</span> max = chars.length + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) {
    str += chars.charAt(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * max));
    size--;
  }
  <span class="hljs-keyword">return</span> str;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFilename</span>(<span class="hljs-params">tmpDir = getTmpDir(</span>)) </span>{
  <span class="hljs-keyword">return</span> path.resolve(tmpDir, randomString(<span class="hljs-number">20</span>));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isURL</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>) === <span class="hljs-string">'http://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>) === <span class="hljs-string">'https://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>说明：</p>
<ul>
<li><code>import copyFile from './copy'</code>用于载入模块，相当于<code>var copyFile = require('./copy')</code>。</li>
<li><code>download(...args)</code>函数中的<code>...args</code>相当于<code>var args = Array.prototype.call(arguments);</code>。</li>
<li>程序使用<code>mkdirp</code>模块来创建目标文件的上级目录，使用时执行命令<code>$ npm i mkdirp --save</code>安装该模块。</li>
<li><code>getTmpDir()</code>函数用于取得当前系统的临时目录，通过<code>os.tmpDir()</code>获得。</li>
<li><code>randomString(size)</code>函数用于生成指定长度的随机字符串。</li>
<li><code>randomFilename(tmpDir)</code>用于生成临时文件名，默认存储在系统临时目录下，可通过<code>tmpDir</code>参数指定。</li>
<li><code>isURL(url)</code>函数用于判断参数是否为一个 URL。</li>
</ul>
<p>为了验证程序是否正确，我们可以将上文的<code>src/copy.js</code>和<code>src/download.js</code>中的测试程序放到<code>src/index.js</code>文件的末尾并执行（需要将旧的程序程序删除），比如：</p>
<pre><code class="language-javascript">download(__filename, <span class="hljs-string">'/tmp/copy.js'</span>, (size, total) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`进度<span class="hljs-subst">${size}</span>/<span class="hljs-subst">${total}</span>`</span>))
  .then(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`已保存到<span class="hljs-subst">${filename}</span>`</span>))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出错：<span class="hljs-subst">${err}</span>`</span>));
</code></pre>
<p>正常情况下，其执行结果应该跟上文中的结果是一致的。</p>
<h3><a id="3_419"></a>3、模块系统</h3>
<p>Node.js 使用的是 CommonJS 模块系统，模块的输出我们一般通过给<code>exports</code>对象设置属性来做：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 输出变量或函数</span>
exports.x = <span class="hljs-number">123</span>;
exports.y = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
};
</code></pre>
<p>可以通过以下方式来操作：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./my_module'</span>);

<span class="hljs-built_in">console</span>.log(mod.x);
mod.y();
</code></pre>
<p>也可以通过覆盖<code>module.exports</code>来输出一个函数或者其他数据类型：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
};
</code></pre>
<p>通过以下方式来操作：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./my_module'</span>);

fn();
</code></pre>
<p>而在 ES2015 中，模块通过<code>export</code>语句来输出：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 普通输出，相当于 exports.x = y;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">123</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{ }
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">d</span> </span>{ }

<span class="hljs-comment">// 默认输出，相当于 module.exports = z;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>通过<code>import</code>语句来引入模块，不同的引入方式其含义是不一样的，比如：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 操作 export var x = y 方式的输出</span>
<span class="hljs-keyword">import</span> {a, b, c, d} <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-comment">// 通过相应的变量名称 a, b, c, d 来操作</span>

<span class="hljs-comment">// 或者将所有输出指向一个对象</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-comment">// 通过 mod.a, mod.b, mod.c, mod.d 来操作</span>

<span class="hljs-comment">// 操作 export default x 方式的输出</span>
<span class="hljs-keyword">import</span> y <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
</code></pre>
<p>对于非 ES2015 程序输出的模块，<code>import * as mod</code>和<code>import mod</code>其结果是一样的，比如：</p>
<pre><code>import * as fs1 from 'fs';
import fs2 from 'fs';

// fs1.readFile() 和 fs2.readFile() 是一样的
</code></pre>
<p>为了更容易理解 ES2015 的模块系统原理，我们可以通过阅读编译后的 JavaScript 程序来了解。访问<a href="http://babeljs.io/repl/">babel 的在线 REPL</a>或将程序保存到本地，并执行<code>babel file.js</code>来查看编译后的程序。</p>
<p>以下 ES2015 代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">123</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{ }
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">d</span> </span>{ }

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>编译后结果如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">"__esModule"</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>
});
exports.c = c;
exports[<span class="hljs-string">"default"</span>] = y;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) </span>{
  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot call a class as a function"</span>);
  }
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;
exports.a = a;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">456</span>;
exports.b = b;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span>(<span class="hljs-params"></span>) </span>{
  _classCallCheck(<span class="hljs-keyword">this</span>, d);
};

exports.d = d;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{}
</code></pre>
<p>由上面的代码可以看出，<code>export var b = 456</code>这样的输出方式，实际上相当于<code>var b = exports.b = 456</code>，即直接设置<code>exports</code>对象的属性来完成。而<code>export default y</code>则是设置<code>exports</code>对象的<code>default</code>属性。</p>
<p>另外，还设置了<code>exports.__esModule = true</code>来标记这是一个 ES2015 输出的模块，在通过<code>import</code>来引入模块时会判断此属性来执行相应的规则，下文将详细介绍。</p>
<p>再看看以下的 ES2015 代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {a, b, c, d} <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;
<span class="hljs-keyword">import</span> y <span class="hljs-keyword">from</span> <span class="hljs-string">'./my_module'</span>;

a;
mod.a;
y;
</code></pre>
<p>其编译后的 JavaScript 代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : {
    <span class="hljs-string">'default'</span>: obj
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireWildcard</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (obj &amp;&amp; obj.__esModule) {
    <span class="hljs-keyword">return</span> obj;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> newObj = {};
    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj[<span class="hljs-string">'default'</span>] = obj;
    <span class="hljs-keyword">return</span> newObj;
  }
}

<span class="hljs-keyword">var</span> _my_module = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./my_module'</span>);

<span class="hljs-keyword">var</span> mod = _interopRequireWildcard(_my_module);

<span class="hljs-keyword">var</span> _my_module2 = _interopRequireDefault(_my_module);

_my_module.a;
mod.a;
_my_module2[<span class="hljs-string">'default'</span>];
</code></pre>
<p>首先，<code>a</code>是通过<code>import {a} from './my_module'</code>来引入的，编译后的代码中访问<code>a</code>使用的是<code>_my_module.a</code>，而<code>_my_module = require('./my_module')</code>，所以其对应的是<code>export var a = 123</code>这样的输出。</p>
<p><code>mod</code>是通过<code>import * as mod from './my_module'</code>来引入的，其编译后的代码为<code>_interopRequireWildcard(require('./my_module'))</code>。在<code>_interopRequireWildcard()</code>函数中，如果载入的模块是由 ES2015 输出的，那么不做任何处理，否则会生成一个输入模块的拷贝，并且设置其<code>default</code>属性为自身。</p>
<p><code>y</code>是通过<code>import y from './my_module'</code>来引入的，对<code>y</code>的访问被编译成了<code>_my_module2['default']</code>，所以<code>y</code>实际上是<code>export default</code>的输出。而<code>_my_module2 = _interopRequireDefault(require('./my_module'))</code>，函数<code>_interopRequireDefault()</code>对载入的非 ES2015 模块做了处理，会返回一个<code>default</code>属性指向该模块的新对象。</p>
<p>当然模块系统的还有更复杂的语法规则，详细说明可参考：<a href="http://www.ruanyifeng.com">阮一峰</a>所著的<a href="http://es6.ruanyifeng.com/">「ECMAScript 6 入门」</a>中<a href="http://es6.ruanyifeng.com/#docs/module">「Module」</a>一章。</p>
<h3><a id="4_600"></a>4、封装模块</h3>
<p>上文例子中的<code>download()</code>函数所在的文件<code>src/index.js</code>中用到<code>randomFilename()</code>和<code>isURL()</code>这两个函数，为了使得代码结构更清晰，我们尝试把这些工具函数转移到<code>src/utils.js</code>中。</p>
<p>新建文件<code>src/utils.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> os <span class="hljs-keyword">from</span> <span class="hljs-string">'os'</span>;

<span class="hljs-keyword">let</span> getTmpDir = os.tmpdir || os.tmpDir;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomString</span>(<span class="hljs-params">size = <span class="hljs-number">6</span>, chars = <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz0123456789'</span></span>) </span>{
  <span class="hljs-keyword">let</span> max = chars.length + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) {
    str += chars.charAt(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * max));
    size--;
  }
  <span class="hljs-keyword">return</span> str;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomFilename</span>(<span class="hljs-params">tmpDir = getTmpDir(</span>)) </span>{
  <span class="hljs-keyword">return</span> path.resolve(tmpDir, randomString(<span class="hljs-number">20</span>));
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isURL</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>) === <span class="hljs-string">'http://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (url.substr(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>) === <span class="hljs-string">'https://'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p>说明：<code>getTmpDir()</code>和<code>randomString()</code>仅在函数<code>randomFilename()</code>函数中用到，所以不需要使用<code>export</code>输出。</p>
<p>修改文件<code>src/index.js</code>，将相应的代码删掉，并在文件首部<code>import</code>语句后面增加以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {randomFilename, isURL, noop} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;
</code></pre>
<h2><a id="_644"></a>单元测试</h2>
<p>本文将以<code>mocha</code>测试框架为例，单元测试程序也将使用 ES2015 来写。</p>
<p>首先执行以下命令安装<code>mocha</code>：</p>
<pre><code class="language-bash">$ npm i -g mocha
</code></pre>
<p>安装完成后可执行以下命令验证是否安装成功：</p>
<pre><code>$ mocha --version

2.3.4
</code></pre>
<p>通过阅读<code>babel</code>的官方文档（访问 <a href="http://babeljs.io/docs/setup/#mocha">http://babeljs.io/docs/setup/#mocha</a> ）可知，为了让 Node.js 中的<code>require()</code>函数能直接载入 ES2015 程序，需要依赖<code>babel-core</code>模块，执行以下命令安装：</p>
<pre><code class="language-bash">$ npm i babel-core mocha --save-dev
</code></pre>
<p>运行<code>mocha</code>命令的时候，需要增加额外的参数<code>--compilers js:babel-core/register</code>让其使用<code>babel</code>来载入 JavaScript 程序。为了方便，我们可以修改<code>package.json</code>文件，增加以下内容：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"mocha --compilers js:babel-core/register"</span>
  }
}
</code></pre>
<p>说明：我们通过<code>npm init</code>命令生成<code>package.json</code>文件时，已经自动生成了<code>test</code>命令，其默认值为<code>echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1</code>，直接将其改为<code>mocha --compilers js:babel-core/register</code>即可。</p>
<p>以上准备工作完成后，便可以开始写单元测试程序了。新建文件<code>test/test.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> download <span class="hljs-keyword">from</span> <span class="hljs-string">'../src'</span>;
<span class="hljs-keyword">import</span> {randomFilename} <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/utils'</span>;

<span class="hljs-keyword">let</span> readFile = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> fs.readFileSync(f).toString();
<span class="hljs-keyword">let</span> getFileSize = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> fs.statSync(f).size;

describe(<span class="hljs-string">'es2015_demo'</span>, () =&gt; {

  it(<span class="hljs-string">'复制本地文件成功'</span>, done =&gt; {

    <span class="hljs-keyword">let</span> source = __filename;
    <span class="hljs-keyword">let</span> target = randomFilename();
    <span class="hljs-keyword">let</span> onProgress = <span class="hljs-literal">false</span>;

    download(source, target, (size, total) =&gt; {

      onProgress = <span class="hljs-literal">true</span>;
      assert.equal(size, total);
      assert.equal(total, getFileSize(source));

    }).then(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> {

      assert.equal(onProgress, <span class="hljs-literal">true</span>);
      assert.equal(target, filename);
      assert.equal(readFile(source), readFile(target));

      done();

    }).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> err;
    });
  });

});
</code></pre>
<p>说明：本文只为了演示如何配置<code>mocha</code>和编写单元测试程序，所以没有给<code>download()</code>函数编写完整的单元测试，仅编写一个测试用例作为演示。</p>
<p>好了，现在执行<code>$ npm test</code>命令看看：</p>
<pre><code class="language-bash">$ npm <span class="hljs-built_in">test</span>

&gt; es2015_demo@1.0.0 <span class="hljs-built_in">test</span> /private/tmp/es2015_demo
&gt; mocha --compilers js:babel-core/register



  es2015_demo
    ✓ 复制本地文件成功


  1 passing (51ms)

</code></pre>
<p>至此，我们已经完成了使用 ES2015 编写模块，并使用<code>mocha</code>来进行单元测试，下文将介绍如何通过<code>babel</code>编译程序，并发布模块。</p>
<h2><a id="_745"></a>发布模块</h2>
<h3><a id="1_747"></a>1、编译</h3>
<p>上文已提到，为了让使用 ES2015 编写的代码能在 Node.js 上正常运行，需要先将其编译成 ES5 标准的代码，然后还需要在程序入口载入<code>babel-polyfill</code>模块。</p>
<p>我们可以修改文件<code>package.json</code>，为其增加<code>compile</code>命令：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"compile"</span>: <span class="hljs-string">"babel src -d lib"</span>
  }
}
</code></pre>
<p>说明：<code>$ babel src -d lib</code>命令表示<code>lib</code>目录下的所有文件，并保存到<code>src</code>目录下。</p>
<p>配置完成后，可以执行<code>$ npm run compile</code>命令编译试试：</p>
<pre><code class="language-bash">$ npm run compile

&gt; @isnc/es2015_demo@1.0.0 compile /Users/glen/work/tmp/es2015_demo
&gt; babel src <span class="hljs-_">-d</span> lib

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js
</code></pre>
<p>此时，我们还不能直接载入<code>lib/index.js</code>文件，因为在此之前需要载入<code>babel-polyfill</code>模块。编辑文件<code>package.json</code>，设置模块入口文件：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>
}
</code></pre>
<p>说明：使用<code>$ npm init</code>生成<code>package.json</code>文件时，<code>main</code>的默认值即为<code>index.js</code>，可无需修改。</p>
<p>新建文件<code>index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-polyfill'</span>);
<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib'</span>).default;
</code></pre>
<p>说明：在<code>src/index.js</code>中<code>download()</code>函数使用的是<code>export default</code>输出，所以在 Node.js 中需要读取模块输出的<code>default</code>属性。</p>
<p>上文中我们的测试程序是直接载入<code>src</code>目录下的程序，但模块最终发布的却是编译后的程序，为了避免因 babel 的 Bug 而导致编译后的程序与源程序功能有差异，我们的单元测试需要改用编译后的代码。</p>
<p>编辑文件<code>test/test.js</code>，将引入<code>src</code>目录的模块：</p>
<pre><code>import download from '../src';
import {randomFilename} from '../src/utils';
</code></pre>
<p>改为：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> download <span class="hljs-keyword">from</span> <span class="hljs-string">'../'</span>;
<span class="hljs-keyword">import</span> {randomFilename} <span class="hljs-keyword">from</span> <span class="hljs-string">'../lib/utils'</span>;
</code></pre>
<p>在编辑<code>package.json</code>文件，将<code>test</code>命令改为先执行<code>compile</code>编译代码后再执行<code>mocha</code>测试：</p>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;npm run compile &amp;&amp; mocha --compilers js:babel-core/register&quot;
  }
}
</code></pre>
<p>重新执行<code>$ npm test</code>可看到如下结果：</p>
<pre><code>$ npm test

&gt; es2015_demo@1.0.0 test /private/tmp/es2015_demo
&gt; npm run compile &amp;&amp; mocha --compilers js:babel-core/register


&gt; es2015_demo@1.0.0 compile /private/tmp/es2015_demo
&gt; babel src -d lib

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js


  es2015_demo
    ✓ 复制本地文件成功


  1 passing (42ms)

</code></pre>
<h3><a id="2_848"></a>2、发布</h3>
<p>在开发项目时，一般都会使用 Git 这样的源代码版本管理工具。上文例子中，<code>lib</code>目录的文件是编译生成的，可以不需要纳入到版本管理中。Node.js 项目在安装模块时会将其保存到<code>node_modules</code>目录下，这些内容也是不应该纳入版本管理的。可以添加文件<code>.gitignore</code>来将其排除：</p>
<pre><code>*.log
node_modules
lib
</code></pre>
<p>如果要将模块发布到 NPM 上，ES2015 编写的源程序也是不需要的，可以添加文件<code>.npmignore</code>来将其排除：</p>
<pre><code>src
</code></pre>
<p>在使用<code>$ npm publish</code>命令发布模块时，可以设置<code>prepublish</code>命令来让其自动执行编译。编辑文件<code>package.json</code>，增加以下内容：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"prepublish"</span>: <span class="hljs-string">"npm run compile"</span>
  }
}
</code></pre>
<p>现在我们执行<code>$ npm publish</code>就可以发布模块了：</p>
<pre><code>$ npm publish

&gt; @leizongmin/es2015_demo@1.0.0 prepublish /Users/glen/work/tmp/es2015_demo
&gt; npm run compile


&gt; @leizongmin/es2015_demo@1.0.0 compile /Users/glen/work/tmp/es2015_demo
&gt; babel src -d lib

src/copy.js -&gt; lib/copy.js
src/download.js -&gt; lib/download.js
src/index.js -&gt; lib/index.js
src/utils.js -&gt; lib/utils.js
+ @leizongmin/es2015_demo@1.0.0
</code></pre>
<h3><a id="3_893"></a>3、善后</h3>
<p>上文例子中需要依赖<code>mocha</code>和<code>babel</code>两个工具，当我们开发多个项目或将其作为开源项目发布出去时，可能不同的项目所依赖<code>babel</code>的版本是不一样的，为了开发环境一致，一般我们需要在当前项目中执行其开发时所指定的<code>babel</code>版本。</p>
<p>首先执行以下命令安装<code>babel-cli</code>和<code>mocha</code>：</p>
<pre><code class="language-bash">$ npm i babel-cli mocha --save-dev
</code></pre>
<p>安装完成后，对于上文中使用的<code>babel</code>和<code>mocha</code>命令，可以使用<code>./node_modules/.bin/babel</code>和<code>./node_modules/.bin/mocha</code>来执行。编辑<code>package.json</code>文件，更改<code>compile</code>和<code>test</code>命令：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"compile"</span>: <span class="hljs-string">"babel src -d lib"</span>,
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"npm run compile &amp;&amp; mocha --compilers js:babel-core/register"</span>
  }
}
</code></pre>
<p>说明：在<code>package.json</code>文件的<code>scripts</code>里面，要执行的命令如果是在<code>./node_modules/.bin</code>目录内，可以省略<code>./node_modules/.bin/</code>前缀，比如<code>./node_modules/.bin/mocha</code>可以简写为
<code>mocha</code>。</p>
<p>本文示例模块输出的<code>download()</code>函数使用的是 Promise 的异步模式，对于习惯使用 callback 模式的用户，我们也可以通过简单的修改来使其支持 callback 模式。</p>
<p>编辑文件<code>src/utils.js</code>，增加<code>callbackify()</code>函数：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackify</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">let</span> argc = fn.length;
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> callback = args[argc];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) callback = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> fn(...args)
      .then(<span class="hljs-function"><span class="hljs-params">ret</span> =&gt;</span> {
        callback &amp;&amp; callback(<span class="hljs-literal">null</span>, ret);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(ret);
      })
      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        callback &amp;&amp; callback(err);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err);
      });
  }
}
</code></pre>
<p>编辑文件<code>src/index.js</code>，将其改为以下内容：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> mkdirp <span class="hljs-keyword">from</span> <span class="hljs-string">'mkdirp'</span>;
<span class="hljs-keyword">import</span> copyFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./copy'</span>;
<span class="hljs-keyword">import</span> downloadFile <span class="hljs-keyword">from</span> <span class="hljs-string">'./download'</span>;
<span class="hljs-keyword">import</span> {randomFilename, isURL, noop, callbackify} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> callbackify(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params">source, target, progress</span>) </span>{
  target = target || randomFilename(download.tmpDir);
  progress = progress || noop;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

    mkdirp(path.dirname(target), err =&gt; {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> callback(err);

      resolve((isURL(source) ? downloadFile : copyFile)
        (source, target, progress));
    });

  });
});
</code></pre>
<p>说明：<code>callbackify()</code>函数的作用是返回一个新的函数，这个函数可以支持原函数的 Promise 模式，同时支持 callback 模式。</p>
<p>现在再给<code>test/test.js</code>增加一个测试用例：</p>
<pre><code class="language-javascript">  it(<span class="hljs-string">'复制本地文件成功 callback'</span>, done =&gt; {

    <span class="hljs-keyword">let</span> source = __filename;
    <span class="hljs-keyword">let</span> target = randomFilename();
    <span class="hljs-keyword">let</span> onProgress = <span class="hljs-literal">false</span>;

    download(source, target, (size, total) =&gt; {

      onProgress = <span class="hljs-literal">true</span>;
      assert.equal(size, total);
      assert.equal(total, getFileSize(source));

    }, (err, filename) =&gt; {

      assert.equal(err, <span class="hljs-literal">null</span>);
      assert.equal(onProgress, <span class="hljs-literal">true</span>);
      assert.equal(target, filename);
      assert.equal(readFile(source), readFile(target));

      done();

    });
  });
</code></pre>
<p>如无意外，重新执行<code>$ npm test</code>是可以测试通过的。</p>
<h2><a id="_998"></a>后记</h2>
<p>本文的初稿在一个星期之前已经完成，一开始看到 ES2015 的新语法特性时眼前一亮，接着又觉得使用的时候有点繁琐，比如每次运行程序都有先使用 babel 编译，程序运行出错时定位的位置跟 ES2015 源码的位置不同等等。后来经过几天的摸索，发觉新的语法特性确实可以少打了很多代码，而且程序的表现力也更强了，与 babel 编译所耗的那几秒时间相比还是很值得的。</p>
<p>本文的示例代码可通过 <a href="https://github.com/leizongmin/morning.work/blob/gh-pages/demo/es2015_npm_package">https://github.com/leizongmin/morning.work/blob/gh-pages/demo/es2015_npm_package</a> 获得。</p>
<h2><a id="_1005"></a>扩展阅读</h2>
<ul>
<li><a href="http://gank.io/post/564151c1f1df1210001c9161">给 JavaScript 初心者的 ES2015 实战</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li>
<li><a href="https://blog.leancloud.cn/3910/">「大概可能也许是」目前最好的 JavaScript 异步方案 async/await</a></li>
<li><a href="http://babeljs.io/docs/learn-es2015/">Learn ES2015 - A detailed overview of ECMAScript 6 features</a></li>
<li><a href="http://mammal.io/articles/using-es6-today/">Using ES6 with npm today</a></li>
<li><a href="http://jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/">Using ES6 and ES7 in the Browser, with Babel 6 and Webpack</a></li>
<li><a href="http://jamesknelson.com/writing-npm-packages-with-es6-using-the-babel-6-cli/">Writing NPM packages with ES6 using the Babel 6 CLI</a></li>
<li><a href="http://info.meteor.com/blog/set-up-sublime-text-for-meteor-es6-es2015-and-jsx-syntax-and-linting">Set up Sublime Text for Meteor ES6 (ES2015) and JSX Syntax and Linting</a></li>
<li><a href="http://exploringjs.com/es6/ch_modules.html">Exploring ES6 - Modules</a></li>
<li><a href="https://www.zybuluo.com/yangfch3/note/249328">npm scripts 入门</a></li>
<li><a href="http://www.qcyoung.com/2016/02/28/%E4%BD%BF%E7%94%A8npm%20scripts%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/">使用 npm scripts 构建项目</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-11/es6-es7-develop-npm-module-using-babel.html</link><guid isPermaLink="true">http://morning.work/page/2015-11/es6-es7-develop-npm-module-using-babel.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Fri, 24 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 Sublime Text 上配置 ES2015 开发环境]]></title><description><![CDATA[<h2><a id="_2"></a>安装</h2>
<p>首先访问 Sublime Text 的官网 <a href="https://www.sublimetext.com/3">https://www.sublimetext.com/3</a> 下载对应系统版本的安装包：</p>
<p><img src="../../images/2016-03/1-1.png" alt="图 1-1"></p>
<p>安装提示安装完毕之后，启动 Sublime Text ，其界面如下：</p>
<p><img src="../../images/2016-03/1-2.png" alt="图 1-2"></p>
<p>其中右下角的 <strong>「Tab Size: 4」</strong> 表示当前缩进的长度，默认为 4 个空格。大多数的 JavaScript 编程风格都是使用 2 个空格长度的，点击该处可以在弹出的菜单中选择长度，并勾选 <strong>「Indent Using Spaces」</strong> 来使用空格代替 Tab 缩进，这样就能保证在不同平台下显示一致。</p>
<h2><a id="_14"></a>配置</h2>
<p>Sublime Text 的配置通过改配置文件来完成，选择菜单 <strong>Preferences &gt; Settings - User</strong>（OSX 系统下是 <strong>Sublime Text &gt; Preferences &gt; Settings - User</strong>） 即可打开配置文件，然后在打开默认的配置文件 <strong>Preferences &gt; Settings - Default</strong> 作为对照，把需要更改的项目复制到「User」配置文件并修改其值。</p>
<p>比如以下配置用来修改缩进长度和方式：</p>
<pre><code class="language-javascript">{

  <span class="hljs-comment">// The number of spaces a tab is considered equal to</span>
  <span class="hljs-string">"tab_size"</span>: <span class="hljs-number">2</span>,

  <span class="hljs-comment">// Set to true to insert spaces when tab is pressed</span>
  <span class="hljs-string">"translate_tabs_to_spaces"</span>: <span class="hljs-literal">true</span>,

}
</code></pre>
<p>详细使用方法可参考本章末尾的「相关链接」。</p>
<h2><a id="_Package_Control_34"></a>安装 Package Control</h2>
<p>使用 Sublime Text 的一大乐趣就是可以为其安装各种各样的插件，但是 Sublime Text 并没有内置插件管理器，我们需要自己去安装。</p>
<p>首先打开 Sublime Text 的包管理器安装页面 <a href="https://packagecontrol.io/installation">https://packagecontrol.io/installation</a></p>
<p><img src="../../images/2016-03/1-3.png" alt="图 1-3"></p>
<p>由于上文中我们安装的是 Sublime Text 3，所以先复制页面中 <strong>SUBLIME TEXT 3</strong> 下面对应的代码，然后转到 Sublime Text 窗口，选择菜单 <strong>View &gt; Show Console</strong>，这时编辑器窗口下面会显示一个新的窗口，在输入栏中粘贴刚才复制的代码，并按回车执行，稍等片刻即可安装完成（主要取决于当前网络环境）。</p>
<p>安装完 Package Control 之后，我们就可以随心所欲地安装需要的插件了。下面我们来介绍 Package Control 的一些基本命令：</p>
<ul>
<li><strong>Install Package</strong> - 安装插件</li>
<li><strong>Remove Package</strong> - 删除插件</li>
<li><strong>Enable Package</strong> - 启用插件</li>
<li><strong>Disable Package</strong> - 禁用插件</li>
</ul>
<p>一般常用的就是 <strong>Install Package</strong> 和 <strong>Remove Package</strong>，要执行以上命令可以在 Sublime Text 界面下按 <strong>Ctrl + Shift + P</strong> 键（在 OSX 系统下是 <strong>Command + Shift + P</strong>），这时会弹出一个下面这样的窗口：</p>
<p><img src="../../images/2016-03/1-4.png" alt="图 1-4"></p>
<p>在窗口中输入命令 <strong>Install Package</strong> 并按回车，稍等几秒，便会弹出以下窗口：</p>
<p><img src="../../images/2016-03/1-5.png" alt="图 1-5"></p>
<p>可以直接在输入框中输入插件名称来搜索插件，并通过方向键来选择要安装的插件，按回车即可安装。</p>
<h2><a id="_Sublime_Text__62"></a>常用的 Sublime Text 插件</h2>
<h3><a id="JavaScriptNext__ES6_Syntax_64"></a>JavaScriptNext - ES6 Syntax</h3>
<p>默认情况下 Sublime Text 并不支持高亮显示 ES6 语法，由于本书的示例代码主要使用 ES6 来编写，因此需要先安装此插件。</p>
<p>安装完此插件之后，需要执行以下操作将其设置为 <code>*.js</code> 文件默认的样式：</p>
<ul>
<li>打开一个 <code>.js</code> 后缀的 JavaScript 文件</li>
<li>选择菜单 <strong>View &gt; Syntax &gt; Open all with current extension as... &gt; JavascriptNext - ES6 Syntax &gt; JavascriptNext</strong>。具体使用方法可访问插件的主页查看。</li>
</ul>
<p>项目主页：<a href="https://github.com/Benvie/JavaScriptNext.tmLanguage">https://github.com/Benvie/JavaScriptNext.tmLanguage</a></p>
<h3><a id="GitGutter_75"></a>Git​Gutter</h3>
<p>如果当前编辑的文件是在一个 Git 项目下面的，安装了 GitGutter 之后可以直接在编辑器中查看到当前文件的改动情况，比如：</p>
<p><img src="../../images/2016-03/1-6.png" alt="图 1-6"></p>
<p>项目主页：<a href="https://github.com/jisaacks/GitGutter">https://github.com/jisaacks/GitGutter</a></p>
<h3><a id="SublimeLinter_83"></a>SublimeLinter</h3>
<p>SublimeLinter 主要用于在 Sublime Text 下对代码进行语法检查，这个插件安装配置会稍微复杂一些。</p>
<p>首先执行以下命令安装用于 JavaScript 语法检查的 eslint 和 babel-eslint ：</p>
<pre><code class="language-bash">$ npm install -g eslint babel-eslint
</code></pre>
<p>由于 babel-eslint 依赖的模块比较多，在国内的网络环境下可能会安装失败，可以在安装时指定使用淘宝的 NPM 镜像：</p>
<pre><code class="language-bash">$ npm install -g eslint babel-eslint --registry=http://registry.npm.taobao.org
</code></pre>
<p>安装完成后，我们再通过 Package Control 来安装 SublimeLinter 和 SublimeLinter-contrib-eslint 这两个插件。</p>
<p>现在我们来打开一个 JavaScript 文件：</p>
<p><img src="../../images/2016-03/1-7.png" alt="图 1-7"></p>
<p>如上图所示，由于 <code>hello world</code> 这一行有语法错误，该行前面会有一个红色的圆圈，并且编辑器底部会显示具体的出错信息**「Error: Parsing error: Unexpeced token, line 5, Column 9」**</p>
<p>要让 SublimeLinter 支持其他编程语言，可以搜索 <code>SublimeLinter-</code> 开头的插件并安装。</p>
<p>项目主页：<a href="http://www.sublimelinter.com/">http://www.sublimelinter.com/</a></p>
<h2><a id="_111"></a>相关链接</h2>
<ul>
<li><a href="http://blog.jobbole.com/79326/">推荐！Sublime Text 最佳插件列表</a></li>
<li><a href="http://dengo.org/archives/923">Sublime Text 3 能用支持的插件推荐</a></li>
<li><a href="http://blog.jobbole.com/82527/">Gif 多图：我常用的 16 个 Sublime Text 快捷键</a></li>
<li><a href="http://tutorial.jingwentian.com/Sublime-Text-3-Documentation/index.html">Sublime Text 3 文档</a></li>
<li><a href="https://www.zybuluo.com/king/note/47271">Sublime Text 3 配置和使用方法</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-03/sublime-text-for-nodejs-es2015-development.html</link><guid isPermaLink="true">http://morning.work/page/2016-03/sublime-text-for-nodejs-es2015-development.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 08 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[利用阿里云 OSS 搭建私有 Docker 仓库]]></title><description><![CDATA[<h2><a id="_2"></a>前言</h2>
<p>最近开始研究 Docker 的应用，于是打算 <strong>搭建一个私有的 Docker 仓库，并使用阿里云的 OSS 作为存储引擎</strong> 。从网上搜索到的资料大都是比较旧的，新版本的 Registry 服务与旧版本的差别比较大，瞎折腾了一天，踩坑无数。突然有感， <strong>网上的过时资料（或者说得不清不楚的）真是坑死人不偿命</strong> ，还是得把这两天摸索出来的门道记录下来，一是好让自己过一段时间后再部署 Docker 仓库时不用重踩一次坑，二来也顺便给后来者提个醒。</p>
<h2><a id="_7"></a>系统环境</h2>
<h3><a id="_docker__9"></a>客户端 docker 版本</h3>
<pre><code>docker version
Client:
 Version:      1.9.1
 API version:  1.21
 Go version:   go1.4.3
 Git commit:   a34a1d5
 Built:        Fri Nov 20 17:56:04 UTC 2015
 OS/Arch:      darwin/amd64

Server:
 Version:      1.9.1
 API version:  1.21
 Go version:   go1.4.3
 Git commit:   a34a1d5
 Built:        Fri Nov 20 17:56:04 UTC 2015
 OS/Arch:      linux/amd64
</code></pre>
<h3><a id="_docker__30"></a>服务器端 docker 版本</h3>
<pre><code>Boot2Docker version 1.9.1, build master : cef800b - Fri Nov 20 19:33:59 UTC 2015
Docker version 1.9.1, build a34a1d5
</code></pre>
<h3><a id="_dockercompose__37"></a>客户端 docker-compose 版本</h3>
<pre><code>docker-compose version 1.5.2, build 7240ff3
docker-py version: 1.5.0
CPython version: 2.7.9
OpenSSL version: OpenSSL 1.0.1j 15 Oct 2014
</code></pre>
<p>如果系统没有<code>docker-compose</code>命令，可以执行以下命令安装：</p>
<pre><code class="language-bash">$ curl -L https://github.com/docker/compose/releases/download/1.5.2/docker-compose-`uname <span class="hljs-_">-s</span>`-`uname -m` &gt; /usr/<span class="hljs-built_in">local</span>/bin/docker-compose
$ chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose
</code></pre>
<h2><a id="_Registry__54"></a>启动 Registry 服务</h2>
<h3><a id="_56"></a>安装</h3>
<p>为了发挥 Docker 容器技术的优势，我们直接使用 Docker 镜像来部署服务。</p>
<p>首先在 <strong>服务器端</strong> 新建工作目录并进入该目录：</p>
<pre><code class="language-bash">$ mkdir my_registry &amp;&amp; <span class="hljs-built_in">cd</span> my_registry
</code></pre>
<p>在当前目录下新建文件<code>docker-compose.yml</code>：</p>
<pre><code>registry:
  restart: always
  image: &quot;registry:2&quot;
  ports:
    - 127.0.0.1:5000:5000
  volumes:
    - ./auth:/auth
    - ./data:/var/lib/registry
  environment:
    - REGISTRY_AUTH=htpasswd
    - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
    - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
</code></pre>
<p>在启动 Registry 服务时，需要用到以下两个目录：</p>
<ul>
<li><code>auth</code>目录用于存放<code>docker login</code>时的账号和密码</li>
<li><code>data</code>目录用于存放<code>docker push</code>时上传上来的文件</li>
</ul>
<p>执行以下命令新建这两个目录：</p>
<pre><code class="language-bash">$ mkdir auth &amp;&amp; mkdir data
</code></pre>
<p>接着，创建一个测试账号（用户名：<code>test</code>，密码：<code>123456</code>）并保存到<code>auth/htpasswd</code>中：</p>
<pre><code class="language-bash">$ htpasswd -Bbn <span class="hljs-built_in">test</span> 123456 &gt; auth/htpasswd
</code></pre>
<p>现在我们来启动 Registry 服务：</p>
<pre><code class="language-bash">$ docker-compose up <span class="hljs-_">-d</span>
</code></pre>
<p>由于本地没有名为<code>registry:2</code>的镜像，控制台可能会打印出如下信息然后暂停一阵：</p>
<pre><code>Pulling registry (registry:2)...
</code></pre>
<p>稍等一两分钟，可以看到控制台打印出如下信息则说明已经启动成功了：</p>
<pre><code>Creating dockertest_registry_1
Attaching to dockertest_registry_1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=warning msg=&quot;No HTTP secret provided - generated random secret. This may cause problems with uploads if multiple registries are behind a load-balancer. To provide a shared secret, fill in http.secret in the configuration file or set the REGISTRY_HTTP_SECRET environment variable.&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;redis not configured&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;using inmemory blob descriptor cache&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;Starting upload purge in 11m0s&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
registry_1 | time=&quot;2016-01-13T21:57:14Z&quot; level=info msg=&quot;listening on [::]:5000&quot; go.version=go1.5.2 instance.id=25aa4d1d-0510-4cb6-9006-1083bff5fc15 version=v2.2.1
</code></pre>
<h3><a id="_124"></a>测试</h3>
<p>现在再打开一个命令行窗口，并进入<code>my_registry</code>目录。</p>
<p>执行以下命令创建一个新镜像：</p>
<pre><code class="language-bash">$ docker tag registry:2 127.0.0.1:5000/<span class="hljs-built_in">test</span>/registry
</code></pre>
<p>说明：镜像名为<code>127.0.0.1:5000/test/registry</code>，其中<code>127.0.0.1:5000</code>表示服务器地址，<code>test/registry</code>表示镜像名。</p>
<p>上传之前要先登录：</p>
<pre><code class="language-bash">$ docker login 127.0.0.1:5000
</code></pre>
<p>说明：按提示输入上文创建的用户名和密码，邮箱可以不用填写。</p>
<p>登陆成功后，执行以下命令即可上传：</p>
<pre><code class="language-bash">$ docker push 127.0.0.1:5000/<span class="hljs-built_in">test</span>/registry
</code></pre>
<h2><a id="_OSS_151"></a>配置阿里云 OSS</h2>
<p>首先在刚才执行<code>docker-compose up</code>的命令行窗口中按<code>CTRL + C</code>退出服务。</p>
<p>将文件<code>docker-compose.yml</code>改为以下内容：</p>
<pre><code>registry:
  restart: always
  image: &quot;registry:2&quot;
  ports:
    - 127.0.0.1:5000:5000
  volumes:
    - ./auth:/auth
  environment:
    - REGISTRY_AUTH=htpasswd
    - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
    - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
    - REGISTRY_STORAGE=oss
    - REGISTRY_STORAGE_OSS_ACCESSKEYID=your_oss_accesskey_id
    - REGISTRY_STORAGE_OSS_ACCESSKEYSECRET=your_oss_accesskey_secret
    - REGISTRY_STORAGE_OSS_REGION=your_oss_region
    - REGISTRY_STORAGE_OSS_BUCKET=your_oss_bucket
    - REGISTRY_STORAGE_OSS_ENDPOINT=your_oss_bucket.your_oss_region.aliyuncs.com
</code></pre>
<p>说明：由于使用阿里云 OSS 作为存储引擎，所以不需要再将文件存储到本地，因此将<code>volumes</code>中的<code>data</code>目录配置去掉；<code>environment</code>新增了<code>REGISTRY_STORAGE</code>系列的环境变量配置，需要将该部分的值替换为对应的<code>accesskey_id</code>、<code>accesskey_secret</code>、<code>region</code>、<code>bucket</code>和<code>endpoint</code>等信息。</p>
<p>删除<code>data</code>目录并重新启动服务：</p>
<pre><code class="language-bash">$ rm -Rf data &amp;&amp; docker-compose up
</code></pre>
<p>再执行刚才的命令上传镜像：</p>
<pre><code class="language-bash">$ docker push 127.0.0.1:5000/<span class="hljs-built_in">test</span>/registry
</code></pre>
<p>可以感觉到这次的上传速度没有第一次的快，因为它还需要上传到阿里云 OSS。待上传完毕，可以打开阿里云 OSS 的控制台界面检查文件是否被正确上传上去了。</p>
<h2><a id="_SSL__194"></a>配置 SSL 证书</h2>
<p>如果我们要在客户端（不是在服务器端测试）<code>pull</code>或<code>push</code>镜像时，<code>docker</code>使用的是<code>https</code>协议，因此会报<code>unable to ping registry endpoint</code>错误：</p>
<pre><code>The push refers to a repository [registry.example.com:5000/test] (len: 1)
unable to ping registry endpoint https://registry.example.com:5000/v0/
v2 ping attempt failed with error: Get https://registry.example.com:5000/v2/: dial tcp registry.example.com:5000: i/o timeout
 v1 ping attempt failed with error: Get https://registry.example.com:5000/v1/_ping: dial tcp 199.99.99.9:9000: i/o timeout
</code></pre>
<p>所以必须要配置 SSL 证书。</p>
<h3><a id="_207"></a>安装</h3>
<p>首先需要准备证书文件，分别保存到<code>auth/domain.crt</code>和<code>auth/domain.key</code>中。</p>
<p>新建 Nginx 的配置文件<code>auth/nginx.conf</code>：</p>
<pre><code>upstream docker-registry {
  server registry:5000;
}

## Set a variable to help us decide if we need to add the
## 'Docker-Distribution-Api-Version' header.
## The registry always sets this header.
## In the case of nginx performing auth, the header will be unset
## since nginx is auth-ing before proxying.
map $upstream_http_docker_distribution_api_version $docker_distribution_api_version {
  'registry/2.0' '';
  default registry/2.0;
}

server {
  listen 443 ssl;
  server_name myregistrydomain.com;

  # SSL
  ssl_certificate /etc/nginx/conf.d/domain.crt;
  ssl_certificate_key /etc/nginx/conf.d/domain.key;

  # Recommendations from https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html
  ssl_protocols TLSv1.1 TLSv1.2;
  ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
  ssl_prefer_server_ciphers on;
  ssl_session_cache shared:SSL:10m;

  # disable any limits to avoid HTTP 413 for large image uploads
  client_max_body_size 0;

  # required to avoid HTTP 411: see Issue #1486 (https://github.com/docker/docker/issues/1486)
  chunked_transfer_encoding on;

  location /v2/ {
    # Do not allow connections from docker 1.5 and earlier
    # docker pre-1.6.0 did not properly set the user agent on ping, catch &quot;Go *&quot; user agents
    if ($http_user_agent ~ &quot;^(docker\/1\.(3|4|5(?!\.[0-9]-dev))|Go ).*\$&quot; ) {
      return 404;
    }

    # To add basic authentication to v2 use auth_basic setting.
    auth_basic &quot;Registry realm&quot;;
    auth_basic_user_file /etc/nginx/conf.d/nginx.htpasswd;

    ## If $docker_distribution_api_version is empty, the header will not be added.
    ## See the map directive above where this variable is defined.
    add_header 'Docker-Distribution-Api-Version' $docker_distribution_api_version always;

    proxy_pass                          http://docker-registry;
    proxy_set_header  Host              \$http_host;   # required for docker client's sake
    proxy_set_header  X-Real-IP         \$remote_addr; # pass on real client's IP
    proxy_set_header  X-Forwarded-For   \$proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto \$scheme;
    proxy_read_timeout                  900;
  }
}
</code></pre>
<p>将文件<code>docker-compose.yml</code>改为如下内容：</p>
<pre><code>nginx:
  image: &quot;nginx:1.9&quot;
  ports:
    - 443:443
  links:
    - registry:registry
  volumes:
    - ./auth/:/etc/nginx/conf.d

registry:
  restart: always
  image: &quot;registry:2&quot;
  ports:
    - 127.0.0.1:5000:5000
  environment:
    - REGISTRY_STORAGE=oss
    - REGISTRY_STORAGE_OSS_ACCESSKEYID=your_oss_accesskey_id
    - REGISTRY_STORAGE_OSS_ACCESSKEYSECRET=your_oss_accesskey_secret
    - REGISTRY_STORAGE_OSS_REGION=your_oss_region
    - REGISTRY_STORAGE_OSS_BUCKET=your_oss_bucket
    - REGISTRY_STORAGE_OSS_ENDPOINT=your_oss_bucket.your_oss_region.aliyuncs.com
</code></pre>
<p>说明：删除<code>registry</code>项目的<code>environment</code>中<code>REGISTRY_AUTH</code>开头的变量以及<code>volumes</code>项，因为<code>auth</code>认证已经在 Nginx 中配置了。</p>
<p>执行以下命令启动服务：</p>
<pre><code>$ docker-compose up
</code></pre>
<p>说明：如果本地不存在名为<code>nginx:1.9</code>的镜像，控制台可能会打印出<code>Pulling nginx (nginx:1.9)...</code>并先下载该镜像。</p>
<h3><a id="_309"></a>测试</h3>
<p>假设刚才配置的证书域名为<code>docker.ucdok.com</code>，现在我们 <strong>在客户端执行以下命令</strong> 登录：</p>
<pre><code class="language-bash">$ docker login docker.ucdok.com
</code></pre>
<p>生成新的镜像：</p>
<pre><code class="language-bash">$ docker pull ubuntu
$ docker tag ubuntu docker.ucdok.com/<span class="hljs-built_in">test</span>/ubuntu
</code></pre>
<p>上传新的镜像：</p>
<pre><code class="language-bash">$ docker push docker.ucdok.com/<span class="hljs-built_in">test</span>/ubuntu
</code></pre>
<h2><a id="_331"></a>其他问题</h2>
<h3><a id="_333"></a>增加用户</h3>
<p>可以执行<code>htpasswd</code>命令来创建，并将其保存到<code>auth/htpasswd</code>文件中：</p>
<pre><code>$ htpasswd -Bbn username password &gt;&gt; auth/htpasswd
</code></pre>
<h3><a id="_341"></a>在后台启动服务</h3>
<p>启动服务时增加<code>-d</code>参数：</p>
<pre><code class="language-bash">$ docker-compose up <span class="hljs-_">-d</span>
</code></pre>
<h3><a id="_349"></a>停止后台服务</h3>
<p>在<code>docker-compose.yml</code>文件所在目录执行以下命令：</p>
<pre><code>$ docker-compose stop
</code></pre>
<h2><a id="_358"></a>相关链接</h2>
<ul>
<li><a href="https://hub.docker.com/_/registry/">Containerized docker registry</a></li>
<li><a href="https://github.com/docker/compose/releases">docker-compose releases</a></li>
<li><a href="https://docs.docker.com/registry/deploying/">Deploying a registry server</a></li>
<li><a href="https://docs.docker.com/registry/nginx/#gotchas">Authenticating proxy with nginx</a></li>
<li><a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a></li>
<li><a href="https://imququ.com/post/letsencrypt-certificate.html">Let's Encrypt，免费好用的 HTTPS 证书</a></li>
<li><a href="https://buy.wosign.com/free/">沃通免费 SSL 证书申请</a></li>
<li><a href="https://cnodejs.org/topic/5629c84ee6a3804c5815918d">Using Docker Compose in Node.js Project 中文翻译</a></li>
<li><a href="https://www.genedock.com/blog/2015/09/28/docker_private_registry/">在公有云上搭建负载均衡的 Docker 私有仓库</a></li>
</ul>
]]></description><link>http://morning.work/page/2016-01/deploying-your-own-private-docker-registry.html</link><guid isPermaLink="true">http://morning.work/page/2016-01/deploying-your-own-private-docker-registry.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 14 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 CentOS 7 下安装配置 shadowsocks]]></title><description><![CDATA[<p>CentOS 7 开始默认使用<a href="https://en.wikipedia.org/wiki/Systemd">Systemd</a>作为开启启动脚本的管理工具，<a href="https://github.com/shadowsocks/">Shadowsocks</a>则是当前比较受欢迎的科学上网工具，本文将介绍如何在 CentOS 下安装和配置 Shadowsocks 服务。</p>
<h2><a id="_pip_4"></a>安装 pip</h2>
<p><a href="https://pip.pypa.io/en/stable/installing/">pip</a>是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。</p>
<p>在控制台执行以下命令安装 pip：</p>
<pre><code class="language-bash">$ curl <span class="hljs-string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="hljs-string">"get-pip.py"</span>
$ python get-pip.py
</code></pre>
<h2><a id="_shadowsocks_15"></a>安装配置 shadowsocks</h2>
<p>在控制台执行以下命令安装 shadowsocks：</p>
<pre><code class="language-bash">$ pip install --upgrade pip
$ pip install shadowsocks
</code></pre>
<p>安装完成后，需要创建配置文件<code>/etc/shadowsocks.json</code>，内容如下：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"server"</span>: <span class="hljs-string">"0.0.0.0"</span>,
  <span class="hljs-attr">"server_port"</span>: <span class="hljs-number">8388</span>,
  <span class="hljs-attr">"password"</span>: <span class="hljs-string">"uzon57jd0v869t7w"</span>,
  <span class="hljs-attr">"method"</span>: <span class="hljs-string">"aes-256-cfb"</span>
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>method</code>为加密方法，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></li>
<li><code>server_port</code>为服务监听端口</li>
<li><code>password</code>为密码，可使用<a href="http://ucdok.com/project/generate_password.html">密码生成工具</a>生成一个随机密码</li>
</ul>
<p>以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。</p>
<h2><a id="_43"></a>配置自启动</h2>
<p>新建启动脚本文件<code>/etc/systemd/system/shadowsocks.service</code>，内容如下：</p>
<pre><code>[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json

[Install]
WantedBy=multi-user.target
</code></pre>
<p>执行以下命令启动 shadowsocks 服务：</p>
<pre><code class="language-bash">$ systemctl <span class="hljs-built_in">enable</span> shadowsocks
$ systemctl start shadowsocks
</code></pre>
<p>为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：</p>
<pre><code class="language-bash">$ systemctl status shadowsocks <span class="hljs-_">-l</span>
</code></pre>
<p>如果服务启动成功，则控制台显示的信息可能类似这样：</p>
<pre><code>● shadowsocks.service - Shadowsocks
   Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)
   Active: active (running) since Mon 2015-12-21 23:51:48 CST; 11min ago
 Main PID: 19334 (ssserver)
   CGroup: /system.slice/shadowsocks.service
           └─19334 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.json

Dec 21 23:51:48 morning.work systemd[1]: Started Shadowsocks.
Dec 21 23:51:48 morning.work systemd[1]: Starting Shadowsocks...
Dec 21 23:51:48 morning.work ssserver[19334]: INFO: loading config from /etc/shadowsocks.json
Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     loading libcrypto from libcrypto.so.10
Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     starting server at 0.0.0.0:8388
</code></pre>
<h2><a id="_89"></a>一键安装脚本</h2>
<p>新建文件<code>install-shadowsocks.sh</code>，内容如下：</p>
<pre><code class="language-bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># Install Shadowsocks on CentOS 7</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Installing Shadowsocks..."</span>

random-<span class="hljs-function"><span class="hljs-title">string</span></span>()
{
    cat /dev/urandom | tr -dc <span class="hljs-string">'a-zA-Z0-9'</span> | fold -w <span class="hljs-variable">${1:-32}</span> | head -n 1
}

CONFIG_FILE=/etc/shadowsocks.json
SERVICE_FILE=/etc/systemd/system/shadowsocks.service
SS_PASSWORD=$(random-string 32)
SS_PORT=8388
SS_METHOD=aes-256-cfb
SS_IP=`ip route get 1 | awk <span class="hljs-string">'{print $NF;exit}'</span>`
GET_PIP_FILE=/tmp/get-pip.py

<span class="hljs-comment"># install pip</span>
curl <span class="hljs-string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="hljs-string">"<span class="hljs-variable">${GET_PIP_FILE}</span>"</span>
python <span class="hljs-variable">${GET_PIP_FILE}</span>

<span class="hljs-comment"># install shadowsocks</span>
pip install --upgrade pip
pip install shadowsocks

<span class="hljs-comment"># create shadowsocls config</span>
cat &lt;&lt;EOF | sudo tee <span class="hljs-variable">${CONFIG_FILE}</span>
{
  <span class="hljs-string">"server"</span>: <span class="hljs-string">"0.0.0.0"</span>,
  <span class="hljs-string">"server_port"</span>: <span class="hljs-variable">${SS_PORT}</span>,
  <span class="hljs-string">"password"</span>: <span class="hljs-string">"<span class="hljs-variable">${SS_PASSWORD}</span>"</span>,
  <span class="hljs-string">"method"</span>: <span class="hljs-string">"<span class="hljs-variable">${SS_METHOD}</span>"</span>
}
EOF

<span class="hljs-comment"># create service</span>
cat &lt;&lt;EOF | sudo tee <span class="hljs-variable">${SERVICE_FILE}</span>
[Unit]
Description=Shadowsocks

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/ssserver -c <span class="hljs-variable">${CONFIG_FILE}</span>

[Install]
WantedBy=multi-user.target
EOF

<span class="hljs-comment"># start service</span>
systemctl <span class="hljs-built_in">enable</span> shadowsocks
systemctl start shadowsocks

<span class="hljs-comment"># view service status</span>
sleep 5
systemctl status shadowsocks <span class="hljs-_">-l</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"================================"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">""</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Congratulations! Shadowsocks has been installed on your system."</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"You shadowsocks connection info:"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"--------------------------------"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"server:      <span class="hljs-variable">${SS_IP}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"server_port: <span class="hljs-variable">${SS_PORT}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"password:    <span class="hljs-variable">${SS_PASSWORD}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"method:      <span class="hljs-variable">${SS_METHOD}</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"--------------------------------"</span>
</code></pre>
<p>执行以下命令一键安装：</p>
<pre><code class="language-bash">$ chmod +x install-shadowsocks.sh
$ ./install-shadowsocks.sh
</code></pre>
<p>也可以直接执行以下命令从 GitHub 下载安装脚本并执行：</p>
<pre><code class="language-bash">$ bash &lt;(curl <span class="hljs-_">-s</span> http://morning.work/examples/2015-12/install-shadowsocks.sh)
</code></pre>
<p>安装完成后会自动打印出 Shadowsocks 的连接配置信息。比如：</p>
<pre><code>Congratulations! Shadowsocks has been installed on your system.
You shadowsocks connection info:
--------------------------------
server:      10.0.2.15
server_port: 8388
password:    RaskAAcW0IQrVcA7n0QLCEphhng7K4Yc
method:      aes-256-cfb
--------------------------------
</code></pre>
<h2><a id="_189"></a>扩展阅读</h2>
<ul>
<li><a href="https://blog.linuxeye.com/400.html">systemd 详解</a></li>
<li><a href="https://pip.pypa.io/en/stable/installing/">Install pip</a></li>
<li><a href="http://www.liquidweb.com/kb/how-to-install-pip-on-centos-7/">How to Install Pip on CentOS 7</a></li>
<li><a href="https://scottlinux.com/2014/12/08/how-to-create-a-systemd-service-in-linux-centos-7/">How To Create a systemd Service in Linux (CentOS 7)</a></li>
<li><a href="https://coreos.com/docs/launching-containers/launching/getting-started-with-systemd/">Getting Started with systemd</a></li>
<li><a href="http://stackoverflow.com/questions/13322485/how-to-i-get-the-primary-ip-address-of-the-local-machine-on-linux-and-os-x">How to I get the primary IP address of the local machine on Linux and OS X?</a></li>
<li><a href="http://stackoverflow.com/questions/5735666/execute-bash-script-from-url">Execute bash script from URL</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html</link><guid isPermaLink="true">http://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 22 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 的 Buffer 那些你可能不知道的用法]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#_5">前言</a></li><li><a href="#_114">操作结构化数据</a></li><li><a href="#leiproto__214">lei-proto 模块介绍</a></li><li><a href="#_267">扩展阅读</a></li></ul></ul></p>
<h2><a id="_5"></a>前言</h2>
<p>在大多数介绍 Buffer 的文章中，主要是围绕数据拼接和内存分配这两方面的。比如我们使用<code>fs</code>模块来读取文件内容的时候，返回的就是一个 Buffer：</p>
<pre><code class="language-javascript">fs.readFile(<span class="hljs-string">'filename'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, buf</span>) </span>{
  <span class="hljs-comment">// &lt;Buffer 2f 2a 2a 0a 20 2a 20 53 75 ... &gt;</span>
});
</code></pre>
<p>在使用<code>net</code>或<code>http</code>模块来接收网络数据时，<code>data</code>事件的参数也是一个 Buffer，这时我们还需要使用<code>Buffer.concat()</code>来做数据拼接：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> bufs = [];
conn.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">buf</span>) </span>{
  bufs.push(buf);
});
conn.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 接收数据结束后，拼接所有收到的 Buffer 对象</span>
  <span class="hljs-keyword">var</span> buf = Buffer.concat(bufs);
});
</code></pre>
<p>还可以利用<code>Buffer.toString()</code>来做转换<code>base64</code>或十六进制字符的转换，比如：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'hello, world!'</span>).toString(<span class="hljs-string">'base64'</span>));
<span class="hljs-comment">// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ==</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'aGVsbG8sIHdvcmxkIQ=='</span>, <span class="hljs-string">'base64'</span>).toString());
<span class="hljs-comment">// 还原 base64 字符串：hello, world!</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'hello, world!'</span>).toString(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 转换成十六进制字符串：68656c6c6f2c20776f726c6421</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'68656c6c6f2c20776f726c6421'</span>, <span class="hljs-string">'hex'</span>).toString());
<span class="hljs-comment">// 还原十六进制字符串：hello, world!</span>
</code></pre>
<p>一般情况下，单个 Node.js 进程是有最大内存限制的，以下是来自官方文档中的说明：</p>
<blockquote>
<p><a href="https://github.com/nodejs/node-v0.x-archive/wiki/FAQ#what-is-the-memory-limit-on-a-node-process">What is the memory limit on a node process?</a></p>
<p>Currently, by default v8 has a memory limit of 512MB on 32-bit systems, and 1.4GB on 64-bit systems. The limit can be raised by setting --max_old_space_size to a maximum of ~1024 (~1 GB) (32-bit) and ~4096 (~4GB) (64-bit), but it is recommended that you split your single process into several workers if you are hitting memory limits.</p>
</blockquote>
<p>由于 Buffer 对象占用的内存空间是不计算在 Node.js 进程内存空间限制上的，因此，我们也常常会使用 Buffer 来存储需要占用大量内存的数据：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 分配一个 2G-1 字节的数据</span>
<span class="hljs-comment">// 单次分配内存超过此值会抛出异常 RangeError: Invalid typed array length</span>
<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> - <span class="hljs-number">1</span>);
</code></pre>
<p>以上便是 Buffer 的几种常见用法。然而，阅读 Buffer 的 API 文档时，我们会发现更多的是<code>readXXX()</code>和<code>writeXXX()</code>开头的 API，具体如下：</p>
<ul>
<li>buf.readUIntLE(offset, byteLength[, noAssert])</li>
<li>buf.readUIntBE(offset, byteLength[, noAssert])</li>
<li>buf.readIntLE(offset, byteLength[, noAssert])</li>
<li>buf.readIntBE(offset, byteLength[, noAssert])</li>
<li>buf.readUInt8(offset[, noAssert])</li>
<li>buf.readUInt16LE(offset[, noAssert])</li>
<li>buf.readUInt16BE(offset[, noAssert])</li>
<li>buf.readUInt32LE(offset[, noAssert])</li>
<li>buf.readUInt32BE(offset[, noAssert])</li>
<li>buf.readInt8(offset[, noAssert])</li>
<li>buf.readInt16LE(offset[, noAssert])</li>
<li>buf.readInt16BE(offset[, noAssert])</li>
<li>buf.readInt32LE(offset[, noAssert])</li>
<li>buf.readInt32BE(offset[, noAssert])</li>
<li>buf.readFloatLE(offset[, noAssert])</li>
<li>buf.readFloatBE(offset[, noAssert])</li>
<li>buf.readDoubleLE(offset[, noAssert])</li>
<li>buf.readDoubleBE(offset[, noAssert])</li>
<li>buf.write(string[, offset][, length][, encoding])</li>
<li>buf.writeUIntLE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeUIntBE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeIntLE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeIntBE(value, offset, byteLength[, noAssert])</li>
<li>buf.writeUInt8(value, offset[, noAssert])</li>
<li>buf.writeUInt16LE(value, offset[, noAssert])</li>
<li>buf.writeUInt16BE(value, offset[, noAssert])</li>
<li>buf.writeUInt32LE(value, offset[, noAssert])</li>
<li>buf.writeUInt32BE(value, offset[, noAssert])</li>
<li>buf.writeInt8(value, offset[, noAssert])</li>
<li>buf.writeInt16LE(value, offset[, noAssert])</li>
<li>buf.writeInt16BE(value, offset[, noAssert])</li>
<li>buf.writeInt32LE(value, offset[, noAssert])</li>
<li>buf.writeInt32BE(value, offset[, noAssert])</li>
<li>buf.writeFloatLE(value, offset[, noAssert])</li>
<li>buf.writeFloatBE(value, offset[, noAssert])</li>
<li>buf.writeDoubleLE(value, offset[, noAssert])</li>
<li>buf.writeDoubleBE(value, offset[, noAssert])</li>
</ul>
<p>这些 API 为在 Node.js 中操作数据提供了极大的便利。假设我们要将一个整形数值存储到文件中，比如当前时间戳为<code>1447656645380</code>，如果将其当作一个字符串存储时，需要占用 11 字节的空间，而将其转换为二进制存储时仅需 6 字节空间即可：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">6</span>);

buf.writeUIntBE(<span class="hljs-number">1447656645380</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
<span class="hljs-comment">// &lt;Buffer 01 51 0f 0f 63 04&gt;</span>

buf.readUIntBE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
<span class="hljs-comment">// 1447656645380</span>
</code></pre>
<p>在使用 Node.js 编写一些底层功能时，比如一个网络通信模块、某个数据库的客户端模块，或者需要从文件中操作大量结构化数据时，以上 Buffer 对象提供的 API 都是必不可少的。</p>
<p>接下来将演示一个使用 Buffer 对象操作结构化数据的例子。</p>
<h2><a id="_114"></a>操作结构化数据</h2>
<p>假设有一个学生考试成绩数据库，每条记录结构如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程代码</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>XXXXXX</td>
<td>XXXX</td>
<td>XX</td>
</tr>
</tbody>
</table>
<p>其中学号是一个 6 位的数字，课程代码是一个 4 位数字，分数最高分为 100 分。</p>
<p>在使用文本来存储这些数据时，比如使用 CSV 格式存储可能是这样的：</p>
<pre><code>100001,1001,99
100002,1001,67
100003,1001,88
</code></pre>
<p>其中每条记录占用 15 字节的空间，而使用二进制存储时其结构将会是这样：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程代码</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 字节</td>
<td>2 字节</td>
<td>1 字节</td>
</tr>
</tbody>
</table>
<p>每一条记录仅需要 6 字节的空间即可，仅仅是使用文本存储的 40%！下面是用来操作这些记录的程序：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 读取一条记录</span>
<span class="hljs-comment">// buf    Buffer 对象</span>
<span class="hljs-comment">// offset 本条记录在 Buffer 对象的开始位置</span>
<span class="hljs-comment">// data   {number, lesson, score}</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeRecord</span> (<span class="hljs-params">buf, offset, data</span>) </span>{
  buf.writeUIntBE(data.number, offset, <span class="hljs-number">3</span>);
  buf.writeUInt16BE(data.lesson, offset + <span class="hljs-number">3</span>);
  buf.writeInt8(data.score, offset + <span class="hljs-number">5</span>);
}

<span class="hljs-comment">// 写入一条记录</span>
<span class="hljs-comment">// buf    Buffer 对象</span>
<span class="hljs-comment">// offset 本条记录在 Buffer 对象的开始位置</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readRecord</span> (<span class="hljs-params">buf, offset</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">number</span>: buf.readUIntBE(offset, <span class="hljs-number">3</span>),
    <span class="hljs-attr">lesson</span>: buf.readUInt16BE(offset + <span class="hljs-number">3</span>),
    <span class="hljs-attr">score</span>: buf.readInt8(offset + <span class="hljs-number">5</span>)
  };
}

<span class="hljs-comment">// 写入记录列表</span>
<span class="hljs-comment">// list  记录列表，每一条包含 {number, lesson, score}</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeList</span> (<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(list.length * <span class="hljs-number">6</span>);
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
    writeRecord(buf, offset, list[i]);
    offset += <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">return</span> buf;
}

<span class="hljs-comment">// 读取记录列表</span>
<span class="hljs-comment">// buf  Buffer 对象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readList</span> (<span class="hljs-params">buf</span>) </span>{
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> list = [];
  <span class="hljs-keyword">while</span> (offset &lt; buf.length) {
    list.push(readRecord(buf, offset));
    offset += <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">return</span> list;
}
</code></pre>
<p>我们可以再编写一段程序来看看效果：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> list = [
  {<span class="hljs-attr">number</span>: <span class="hljs-number">100001</span>, <span class="hljs-attr">lesson</span>: <span class="hljs-number">1001</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">99</span>},
  {<span class="hljs-attr">number</span>: <span class="hljs-number">100002</span>, <span class="hljs-attr">lesson</span>: <span class="hljs-number">1001</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">88</span>},
  {<span class="hljs-attr">number</span>: <span class="hljs-number">100003</span>, <span class="hljs-attr">lesson</span>: <span class="hljs-number">1001</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">77</span>},
  {<span class="hljs-attr">number</span>: <span class="hljs-number">100004</span>, <span class="hljs-attr">lesson</span>: <span class="hljs-number">1001</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">66</span>},
  {<span class="hljs-attr">number</span>: <span class="hljs-number">100005</span>, <span class="hljs-attr">lesson</span>: <span class="hljs-number">1001</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">55</span>},
];
<span class="hljs-built_in">console</span>.log(list);

<span class="hljs-keyword">var</span> buf = writeList(list);
<span class="hljs-built_in">console</span>.log(buf);
<span class="hljs-comment">// 输出 &lt;Buffer 01 86 a1 03 e9 63 01 86 a2 03 e9 58 01 86 a3 03 e9 4d 01 86 a4 03 e9 42 01 86 a5 03 e9 37&gt;</span>

<span class="hljs-keyword">var</span> ret = readList(buf);
<span class="hljs-built_in">console</span>.log(ret);
<span class="hljs-comment">/* 输出
[ { number: 100001, lesson: 1001, score: 99 },
  { number: 100002, lesson: 1001, score: 88 },
  { number: 100003, lesson: 1001, score: 77 },
  { number: 100004, lesson: 1001, score: 66 },
  { number: 100005, lesson: 1001, score: 55 } ]
*/</span>
</code></pre>
<h2><a id="leiproto__214"></a>lei-proto 模块介绍</h2>
<p>上面的例子中，当每一条记录的结构有变化时，我们需要修改<code>readRecord()</code>和<code>writeRecord()</code>，重新计算每一个字段在 Buffer 中的偏移量，当记录的字段比较复杂时很容易出错。为此我编写了<code>lei-proto</code>模块，它允许你通过简单定义每条记录的结构即可生成对应的<code>readRecord()</code>和`writeRecord()函数。</p>
<p>首先执行以下命令安装此模块：</p>
<pre><code class="language-bash">$ npm install lei-proto --save
</code></pre>
<p>使用<code>lei-proto</code>模块后，前文的例子可以改为这样：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> parsePorto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-proto'</span>);

<span class="hljs-comment">// 生成指定记录结构的数据编码/解码器</span>
<span class="hljs-keyword">var</span> record = parsePorto([
  [<span class="hljs-string">'number'</span>, <span class="hljs-string">'uint'</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-string">'lesson'</span>, <span class="hljs-string">'uint'</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-string">'score'</span>, <span class="hljs-string">'uint'</span>, <span class="hljs-number">1</span>]
]);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readList</span> (<span class="hljs-params">buf</span>) </span>{
  <span class="hljs-keyword">var</span> list = [];
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (offset &lt; buf.length) {
    list.push(record.decode(buf.slice(offset, offset + <span class="hljs-number">6</span>)));
    offset += <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">return</span> list;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeList</span> (<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">return</span> Buffer.concat(list.map(record.encodeEx));
}
</code></pre>
<p>运行与上文同样的测试程序，可看到其结果是一样的：</p>
<pre><code>&lt;Buffer 01 86 a1 03 e9 63 01 86 a2 03 e9 58 01 86 a3 03 e9 4d 01 86 a4 03 e9 42 01 86 a5 03 e9 37&gt;
[ { number: 100001, lesson: 1001, score: 99 },
  { number: 100002, lesson: 1001, score: 88 },
  { number: 100003, lesson: 1001, score: 77 },
  { number: 100004, lesson: 1001, score: 66 },
  { number: 100005, lesson: 1001, score: 55 } ]
</code></pre>
<p>关于<code>lei-proto</code>模块的详细使用方法可访问该模块的主页浏览：<a href="https://github.com/leizongmin/node-lei-proto">https://github.com/leizongmin/node-lei-proto</a></p>
<p>对此感兴趣的读者也可研究一下其实现原理。</p>
<h2><a id="_267"></a>扩展阅读</h2>
<ul>
<li><a href="http://www.infoq.com/cn/articles/nodejs-about-buffer">Buffer 那些事儿</a></li>
<li><a href="https://cnodejs.org/topic/5189ff4f63e9f8a54207f60c">浅析 nodejs 的 buffer 类</a></li>
<li><a href="https://cnodejs.org/topic/4faf65852e8fb5bc65113403">小心 buffer 的拼接问题</a></li>
<li><a href="http://blog.fens.me/nodejs-buffer/">Node.js 缓冲模块 Buffer</a></li>
<li><a href="http://www.tutorialspoint.com/nodejs/nodejs_buffers.htm">Node.js - Buffers</a></li>
<li><a href="https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers">How to Use Buffers in Node.js</a></li>
<li><a href="https://nodejs.org/api/buffer.html">Node.js API Documentation - Buffer</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-11/nodejs_buffer.html</link><guid isPermaLink="true">http://morning.work/page/2015-11/nodejs_buffer.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Mon, 16 Nov 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 定制 REPL 的妙用]]></title><description><![CDATA[<p>相信在学习 Node.js 的时候，对 Node.js 的 REPL 并不陌生。我们可以在 REPL 里面输入 JavaScript 代码并立刻看到效果，常常用来试用一些新的模块，甚至直接把 REPL 当计算器来用。</p>
<p>最近在修改以前使用 Node.js 写的<a href="https://github.com/leizongmin/node-segment">中文分词模块</a>时，想要看到代码修改后的效果，但是又不方便马上写测试代码，自然想到使用 REPL 来测试。比如执行以下命令启动 Node.js 的 REPL 界面：</p>
<pre><code class="language-bash">$ node
</code></pre>
<p>然后在控制台界面中输入要测试的代码（其中<code>&gt;</code>开头的行是手工输入并按回车的代码，其他部分为 REPL 的输出结果）：</p>
<pre><code>&gt; var Segment = require('./')
undefined
&gt; var s = new Segment()
undefined
&gt; s.useDefault(); 1
1
&gt; s.doSegment('神奇的 REPL')
[ { w: '神奇的', p: 1073741824 }, { w: 'REPL', p: 16 } ]
&gt;
</code></pre>
<p>但当我修改了模块的代码后，要看效果时又要重复输入上面的代码，这种<strong>做重复无意义工作的行为绝非是一名有理想的程序员想要的</strong>。于是，我决定自己<strong>定制一个 REPL</strong>，这样就可以预先执行一些初始化代码，一启动程序就可以进入主题了。</p>
<p>看了一下<a href="https://nodejs.org/api/repl.html">REPL 模块的文档</a>之后，大概搞清了怎么个用法，接下来开始写代码了。</p>
<p>首先在项目的根目录下新建名为<code>repl</code>的文件，代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">var</span> repl = <span class="hljs-built_in">require</span>(<span class="hljs-string">'repl'</span>);

<span class="hljs-comment">// 创建一个 REPL</span>
<span class="hljs-keyword">var</span> r = repl.start(<span class="hljs-string">'&gt; '</span>);
<span class="hljs-comment">// context 即为 REPL 中的上下文环境</span>
<span class="hljs-keyword">var</span> c = r.context;

<span class="hljs-comment">// 测试用的初始化代码</span>
<span class="hljs-comment">// 在 REPL 中可以通过 Segment 和 segment 来访问以下两个变量</span>
c.Segment = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>);
c.segment = <span class="hljs-keyword">new</span> c.Segment();
c.segment.useDefault();

<span class="hljs-comment">// 精简函数名，方便手工输入，在 REPL 中可以通过 s 来访问此函数</span>
c.s = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> c.segment.doSegment.apply(c.segment, <span class="hljs-built_in">arguments</span>);
};
</code></pre>
<p>文件第一行的<code>#!/usr/bin/env node</code>表示这是一个脚本文件，使用<code>node</code>命令来执行它，所以还要给这个文件加上可执行权限：</p>
<pre><code class="language-bash">$ chmod +x repl
</code></pre>
<p>现在就可以试试这个定制的 REPL 了：</p>
<pre><code>$ ./repl
&gt; s('神奇的 REPL')
[ { w: '神奇的', p: 1073741824 }, { w: 'REPL', p: 16 } ]
&gt;
</code></pre>
<p>之后每次更改了代码，只要按两下<code>CTRL+C</code>来退出当前 REPL，再执行<code>./repl</code>来启动程序，然后输入<code>s('神奇的 REPL')</code>就可以看到分词的效果了，如果要执行其他函数，也可以直接操作<code>segment</code>变量来做。</p>
<p><strong>但是，一名有理想的程序员绝不会满足于此的。</strong></p>
<p>当我修改了模块代码，为什么要重启 REPL 呢，难道不能重新加载一次这个模块，然后该干嘛还干嘛？</p>
<p>从<a href="https://nodejs.org/api/modules.html#modules_caching">Node.js 的模块系统文档</a>可知，在使用<code>require()</code>来加载模块后，相关的文件内容会被缓存到<code>require.cache[filename]</code>中，当再次<code>require()</code>此文件的时候并不会重新加载。所以要想在不重启进程的情况下重新加载模块，我们就要清理这个模块相关的所有缓存。</p>
<p>把<code>repl</code>文件改成以下代码：</p>
<pre><code class="language-javascript"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> repl = <span class="hljs-built_in">require</span>(<span class="hljs-string">'repl'</span>);


<span class="hljs-keyword">var</span> r = repl.start(<span class="hljs-string">'&gt; '</span>);
<span class="hljs-keyword">var</span> c = r.context;

<span class="hljs-comment">// 原来的初始化代码放到此函数内</span>
c._load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  c.Segment = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>);
  c.segment = <span class="hljs-keyword">new</span> c.Segment();
  c.segment.useDefault();
  c.s = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> c.segment.doSegment.apply(c.segment, <span class="hljs-built_in">arguments</span>);
  };
};

<span class="hljs-comment">// 在 REPL 中执行 reload()可重新加载模块</span>
c.reload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Date</span>.now();

  <span class="hljs-comment">// 清空当前项目根目录下所有文件的缓存</span>
  <span class="hljs-keyword">var</span> dir = path.resolve(__dirname) + path.sep;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">require</span>.cache) {
    <span class="hljs-keyword">if</span> (i.indexOf(dir) === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">delete</span> <span class="hljs-built_in">require</span>.cache[i];
    }
  }

  <span class="hljs-comment">// 重新执行初始化</span>
  c._load();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK. (spent %sms)'</span>, <span class="hljs-built_in">Date</span>.now() - t);
}

c._load();
</code></pre>
<p>好了，在修改了模块的代码后，只要在 REPL 中执行<code>reload()</code>函数就能重新载入最新的代码了：</p>
<pre><code>&gt; reload()
OK. (spent 458ms)
undefined
&gt; s('神奇的 REPL')
[ { w: '神奇的', p: 1073741824 }, { w: 'REPL', p: 16 } ]
&gt;
</code></pre>
<h2><a id="_131"></a>总结</h2>
<p>本文所介绍的定制 REPL 的方法并不高深，如果在合适的场景中使用，却也能省不少事情。我目前能想到的应用场景有以下几个：</p>
<ul>
<li>开发时需要在交互界面下查看测试结果</li>
<li>在演示代码时不需要录入一系列初始化代码而快速进入演示环境</li>
<li>开发基于 Node.js 的 Shell 程序</li>
</ul>
<h2><a id="_140"></a>相关链接</h2>
<ul>
<li><a href="http://segmentfault.com/a/1190000002673137">Node.js 之 REPL</a></li>
<li><a href="http://derickbailey.com/2014/07/02/build-your-own-app-specific-repl-for-your-nodejs-app/">Build Your Own App Specific REPL For Your NodeJS App</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html">Node.js 命令行程序开发教程</a></li>
<li><a href="https://cnodejs.org/topic/55c2ba865965fe2c74f478ac">Node.js 里的 REPL</a></li>
</ul>
]]></description><link>http://morning.work/page/2015-10/node_repl_module.html</link><guid isPermaLink="true">http://morning.work/page/2015-10/node_repl_module.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Sat, 31 Oct 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Node.js 项目的配置文件]]></title><description><![CDATA[<p>在使用 Node.js 编写一个完整的项目时，程序中往往需要用到一些可配置的变量，从而使得程序能在不同的环境中运行。本文将介绍几种常见的方法。</p>
<p><h3>目录</h3><ul><ul><li><a href="#_7">通过环境变量指定配置</a></li><ul><li><a href="#_42">设置环境变量</a></li><li><a href="#_Nodejs__58">在 Node.js 中读取环境变量</a></li></ul><li><a href="#_75">通过配置文件指定配置</a></li><ul><li><a href="#_124">其他配置文件格式</a></li><ul><li><a href="#JSON__141">JSON 格式</a></li><li><a href="#YAML__196">YAML 格式</a></li></ul></ul><li><a href="#_251">根据运行环境选择不同的配置</a></li><ul><li><a href="#_255">使用单一配置文件名</a></li><li><a href="#_261">通过环境变量指定配置文件名</a></li></ul><li><a href="#_config__291">使用 config 模块来读取配置</a></li><li><a href="#_394">相关链接</a></li><li><a href="#_403">相关模块</a></li></ul></ul></p>
<h2><a id="_7"></a>通过环境变量指定配置</h2>
<p><a href="http://baike.baidu.com/view/95930.htm">环境变量（environment variables）</a> 一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。比如<code>HOME</code>表示当前用户的根目录，<code>TMPDIR</code>表示系统临时目录等，我们可以通过设置一些特定的环境变量，程序在启动时可以读取这些环境变量并做相应的初始化动作。</p>
<p>在 Node.js 中可以通过<code>process.env</code>来访问当前的环境变量信息，比如：</p>
<pre><code class="language-javascript">{ <span class="hljs-attr">PATH</span>: <span class="hljs-string">'/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin'</span>,
  <span class="hljs-attr">TMPDIR</span>: <span class="hljs-string">'/var/folders/rs/g4wqpvvj7bj08t35dxvfm0rr0000gn/T/'</span>,
  <span class="hljs-attr">LOGNAME</span>: <span class="hljs-string">'glen'</span>,
  <span class="hljs-attr">XPC_FLAGS</span>: <span class="hljs-string">'0x0'</span>,
  <span class="hljs-attr">HOME</span>: <span class="hljs-string">'/Users/glen'</span>,
  <span class="hljs-attr">TERM</span>: <span class="hljs-string">'xterm-256color'</span>,
  <span class="hljs-attr">COLORFGBG</span>: <span class="hljs-string">'7;0'</span>,
  <span class="hljs-attr">USER</span>: <span class="hljs-string">'glen'</span>,
  <span class="hljs-attr">ITERM_PROFILE</span>: <span class="hljs-string">'Glen'</span>,
  <span class="hljs-attr">TERM_PROGRAM</span>: <span class="hljs-string">'iTerm.app'</span>,
  <span class="hljs-attr">XPC_SERVICE_NAME</span>: <span class="hljs-string">'0'</span>,
  <span class="hljs-attr">SHELL</span>: <span class="hljs-string">'/bin/zsh'</span>,
  <span class="hljs-attr">ITERM_SESSION_ID</span>: <span class="hljs-string">'w0t4p0'</span>,
  <span class="hljs-attr">PWD</span>: <span class="hljs-string">'/Users/glen/work'</span>,
  <span class="hljs-attr">__CF_USER_TEXT_ENCODING</span>: <span class="hljs-string">'0x1F5:0x0:0x0'</span>,
  <span class="hljs-attr">LC_CTYPE</span>: <span class="hljs-string">'UTF-8'</span>,
  <span class="hljs-attr">SHLVL</span>: <span class="hljs-string">'1'</span>,
  <span class="hljs-attr">OLDPWD</span>: <span class="hljs-string">'/Users/glen/work'</span>,
  <span class="hljs-attr">ZSH</span>: <span class="hljs-string">'/Users/glen/.oh-my-zsh'</span>,
  <span class="hljs-attr">PAGER</span>: <span class="hljs-string">'less'</span>,
  <span class="hljs-attr">LESS</span>: <span class="hljs-string">'-R'</span>,
  <span class="hljs-attr">LSCOLORS</span>: <span class="hljs-string">'Gxfxcxdxbxegedabagacad'</span>,
  <span class="hljs-attr">AUTOJUMP_SOURCED</span>: <span class="hljs-string">'1'</span>,
  <span class="hljs-attr">AUTOJUMP_ERROR_PATH</span>: <span class="hljs-string">'/Users/glen/Library/autojump/errors.log'</span>,
  <span class="hljs-attr">RUST_SRC_PATH</span>: <span class="hljs-string">'/Users/glen/work/source/rust/src'</span>,
  <span class="hljs-attr">_</span>: <span class="hljs-string">'/usr/local/bin/node'</span> }
</code></pre>
<h3><a id="_42"></a>设置环境变量</h3>
<p>环境变量的名字一般为大写，多个单词之间可通过下划线来连接。</p>
<p>Windows 系统下可通过<code>set</code>命令来设置环境变量，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">set</span> HELLO_MSG=<span class="hljs-string">"Hello, world!"</span>
</code></pre>
<p>Linux 系统下可通过<code>export</code>命令来设置，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> HELLO_MSG=<span class="hljs-string">"Hello, world!"</span>
</code></pre>
<h3><a id="_Nodejs__58"></a>在 Node.js 中读取环境变量</h3>
<p>创建文件<code>1.js</code>，代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(process.env.HELLO_MSG);
</code></pre>
<p>然后在命令行中执行：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> HELLO_MSG=<span class="hljs-string">"Hello, world"</span> &amp;&amp; node 1.js
</code></pre>
<p>控制台将输出<code>Hello, world</code>，即我们启动程序时给环境变量<code>HELLO_MSG</code>设置的值。</p>
<h2><a id="_75"></a>通过配置文件指定配置</h2>
<p>一些规模较小的项目往往会通过单一的配置文件来存储其配置，比如 CNode 中文社区的开源项目 <a href="https://github.com/cnodejs/nodeclub">nodeclub</a> 在启动时会载入文件<code>config.js</code>，该文件的大概结构如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-comment">// debug 为 true 时，用于本地调试</span>
  debug: <span class="hljs-literal">true</span>,

  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nodeclub'</span>, <span class="hljs-comment">// 社区名字</span>
  description: <span class="hljs-string">'CNode：Node.js 专业中文社区'</span>, <span class="hljs-comment">// 社区的描述</span>
  keywords: <span class="hljs-string">'nodejs, node, express, connect, socket.io'</span>,

  <span class="hljs-comment">// 其他配置项...</span>
};
<span class="hljs-built_in">module</span>.exports = config;
</code></pre>
<p>在程序启动的时候，可以使用<code>require()</code>来载入此文件，得到一个对象，然后通过此对象的属性来读取相应的配置信息：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 载入配置文件</span>
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>);

<span class="hljs-comment">// 以下为使用到配置的部分代码：</span>
<span class="hljs-keyword">if</span> (!config.debug &amp;&amp; config.oneapm_key) {
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'oneapm'</span>);
}

app.use(session({
  <span class="hljs-attr">secret</span>: config.session_secret,
  <span class="hljs-attr">store</span>: <span class="hljs-keyword">new</span> RedisStore({
    <span class="hljs-attr">port</span>: config.redis_port,
    <span class="hljs-attr">host</span>: config.redis_host,
  }),
  <span class="hljs-attr">resave</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>,
}))

app.listen(config.port, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  logger.log(<span class="hljs-string">'NodeClub listening on port'</span>, config.port);
  logger.log(<span class="hljs-string">'God bless love....'</span>);
  logger.log(<span class="hljs-string">'You can debug your app with http://'</span> + config.hostname + <span class="hljs-string">':'</span> + config.port);
  logger.log(<span class="hljs-string">''</span>);
});
</code></pre>
<p>使用配置文件与使用环境变量来指定配置相比，配置文件的可读性更强，可以表示一些更复杂的结构，而使用环境变量一般只限于<code>key=value</code>的形式。但在配置项数量较少时，使用环境变量会更简单，比如项目中只需要配置一个监听端口，可以简单使用<code>export PORT=3000 &amp;&amp; node app.js</code>命令来启动程序，而不需要单独创建一个配置文件。大多数时候往往会结合这两种方式来进行，下文讲详细讲解。</p>
<h3><a id="_124"></a>其他配置文件格式</h3>
<p>一般为了方便，在 Node.js 项目中会习惯使用<code>.js</code>文件格式，它的好处是可以使用通过程序来动态生成一些配置项，比如 nodeclub 的其中一个配置项：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-comment">// 文件上传配置</span>
  <span class="hljs-comment">// 注：如果填写 qn_access，则会上传到 7 牛，以下配置无效</span>
  upload: {
    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'public/upload/'</span>),
    <span class="hljs-attr">url</span>: <span class="hljs-string">'/public/upload/'</span>
  },
}
</code></pre>
<p>其中使用到了<code>path.join()</code>和<code>__dirname</code>来生成<code>upload.path</code>。</p>
<h4><a id="JSON__141"></a>JSON 格式</h4>
<p>另外，我们也可以使用 <a href="http://json.org/">JSON</a> 格式的配置文件，比如文件<code>config.json</code>：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"debug"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Nodeclub"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"CNode：Node.js 专业中文社区"</span>,
  <span class="hljs-attr">"keywords"</span>: <span class="hljs-string">"nodejs, node, express, connect, socket.io"</span>
}
</code></pre>
<p>在程序中可以通过以下方式来载入 JSON 文件配置：</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 通过 require()函数</span>
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config.json'</span>);

<span class="hljs-comment">// 读取文件并使用 JSON.parse()解析</span>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">JSON</span>.parse(fs.readFileSync(<span class="hljs-string">'./config.json'</span>).toString());
</code></pre>
<p>大多数时候，我们往往需要添加一些备注信息来说明某个配置项的使用方法及用途，在标准 JSON 文件中是不允许添加备注的，我们可以使用<code>strip-json-comments</code>模块来去掉配置文件中的备注，再将其当作标准的 JSON 来解析。</p>
<p>比如以下是带备注信息的 JSON 配置文件：</p>
<pre><code class="language-javascript">{
  <span class="hljs-comment">// debug 为 true 时，用于本地调试</span>
  <span class="hljs-string">"debug"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// 社区名字</span>
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"Nodeclub"</span>,
  <span class="hljs-comment">// 社区的描述</span>
  <span class="hljs-string">"description"</span>: <span class="hljs-string">"CNode：Node.js 专业中文社区"</span>,
  <span class="hljs-string">"keywords"</span>: <span class="hljs-string">"nodejs, node, express, connect, socket.io"</span>
}
</code></pre>
<p>我们可以编写一个<code>loadJSONFile()</code>函数来载入带有备注的 JSON 文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> stripJsonComments = <span class="hljs-built_in">require</span>(<span class="hljs-string">'strip-json-comments'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJSONFile</span> (<span class="hljs-params">file</span>) </span>{
  <span class="hljs-keyword">var</span> json = fs.readFileSync(file).toString();
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(stripJsonComments(json));
}

<span class="hljs-keyword">var</span> config = loadJSONFile(<span class="hljs-string">'./config.json'</span>);
<span class="hljs-built_in">console</span>.log(config);
</code></pre>
<h4><a id="YAML__196"></a>YAML 格式</h4>
<p><a href="http://yaml.org/">YAML</a> 是面向所有编程语言的对人类友好的数据序列化标准。其最大的优点是可读性较好，比如以下 YAML 格式的配置：</p>
<pre><code class="language-yaml"><span class="hljs-attr">name:</span> John Smith
<span class="hljs-attr">age:</span> <span class="hljs-number">37</span>
<span class="hljs-attr">spouse:</span>
<span class="hljs-attr">  name:</span> Jane Smith
<span class="hljs-attr">  age:</span> <span class="hljs-number">25</span>
<span class="hljs-attr">children:</span>
<span class="hljs-attr">  - name:</span> Jimmy Smith
<span class="hljs-attr">    age:</span> <span class="hljs-number">15</span>
<span class="hljs-attr">  - name:</span> Jenny Smith
<span class="hljs-attr">    age:</span> <span class="hljs-number">12</span>
</code></pre>
<p>其对应的 JSON 结构如下：</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">37</span>,
  <span class="hljs-attr">"spouse"</span>: {
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jane Smith"</span>
  },
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John Smith"</span>,
  <span class="hljs-attr">"children"</span>: [
    {
      <span class="hljs-attr">"age"</span>: <span class="hljs-number">15</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jimmy Smith"</span>
    },
    {
      <span class="hljs-attr">"age"</span>: <span class="hljs-number">12</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jenny Smith"</span>
    }
  ]
}
</code></pre>
<p>在 Node.js 中可以通过<code>yamljs</code>模块来解析 YAML 格式，比如可以编写一个<code>loadYAMLFile()</code>函数来载入 YAML 格式的配置文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> YAML = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yamljs'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadYAMLFile</span> (<span class="hljs-params">file</span>) </span>{
  <span class="hljs-keyword">return</span> YAML.parse(fs.readFileSync(file).toString());
}

<span class="hljs-keyword">var</span> config = loadYAMLFile(<span class="hljs-string">'./config.yaml'</span>);
<span class="hljs-built_in">console</span>.log(config);
</code></pre>
<h2><a id="_251"></a>根据运行环境选择不同的配置</h2>
<p>大多数情况下，程序在本地开发环境和生产环境中的配置信息是不一样的，比如开发时连接到的数据库里面的数据是模拟出来的，而生产环境要连接到实际的数据库上，因此我们需要让程序能根据不同的运行环境来载入不同的配置文件。</p>
<h3><a id="_255"></a>使用单一配置文件名</h3>
<p>以 nodeclub 项目为例，其载入的配置文件名为<code>./config.js</code>，项目中有一个默认配置文件<code>./config.default.js</code>。要运行程序，首先需要复制一份默认配置文件，并保存为<code>./config.js</code>，再根据当前运行环境来修改<code>./config.js</code>。</p>
<p>由于<code>./config.js</code>文件已经被添加到<code>.gitignore</code>文件中，因此我们<code>./config.js</code>文件的修改不会被纳入到项目的版本管理中，所以不同机器中的<code>./config.js</code>不会产生冲突，可以使用各自的配置来启动程序。</p>
<h3><a id="_261"></a>通过环境变量指定配置文件名</h3>
<p>我们可以通过环境变量来指定配置文件，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> CONFIG_FILE=<span class="hljs-string">"./config/production.js"</span>
</code></pre>
<p>然后可以通过以下方式来载入配置文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(path.resolve(process.env.CONFIG_FILE));
</code></pre>
<p>另外，也可以通过环境变量来指定当前运行环境的名称，然后在指定目录下载入相应的配置，比如：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> NODE_ENV=<span class="hljs-string">"production"</span>
</code></pre>
<p>然后可以通过以下方式来载入配置文件：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> configFile = path.resolve(<span class="hljs-string">'./config'</span>, process.env.NODE_ENV + <span class="hljs-string">'.js'</span>);
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(configFile);
</code></pre>
<h2><a id="_config__291"></a>使用 config 模块来读取配置</h2>
<p><a href="https://www.npmjs.com/package/config">config</a> 模块是 NPM 上下载量最高的 Node.js 配置文件管理模块，其实现原理与上文中介绍的方法大同小异，在实际开发中我们可以考虑使用这个现成的模块。下面将介绍此模块的简单使用方法。</p>
<p><code>config</code>模块通过环境变量<code>NODE_CONFIG_DIR</code>来指定配置文件所在的目录，默认为<code>./config</code>（即当前运行目录下的<code>config</code>目录），通过环境变量<code>NODE_ENV</code>来指定当前的运行环境版本。</p>
<p>配置文件使用 JSON 格式，模块加载后，会首先载入默认的配置文件<code>${NODE_CONFIG_DIR}/default.json</code>，再载入文件<code>${NODE_CONFIG_DIR}/${NODE_ENV}.json</code>，如果配置项有冲突则覆盖默认的配置。</p>
<p>比如我们新建默认配置文件<code>config/default.json</code>：</p>
<pre><code class="language-javascript">{
  <span class="hljs-comment">// Customer module configs</span>
  <span class="hljs-string">"Customer"</span>: {
    <span class="hljs-string">"dbConfig"</span>: {
      <span class="hljs-string">"host"</span>: <span class="hljs-string">"localhost"</span>,
      <span class="hljs-string">"port"</span>: <span class="hljs-number">5984</span>,
      <span class="hljs-string">"dbName"</span>: <span class="hljs-string">"customers"</span>
    },
    <span class="hljs-string">"credit"</span>: {
      <span class="hljs-string">"initialLimit"</span>: <span class="hljs-number">100</span>,
      <span class="hljs-comment">// Set low for development</span>
      <span class="hljs-string">"initialDays"</span>: <span class="hljs-number">1</span>
    }
  }
}
</code></pre>
<p>再新建<code>production</code>环境配置文件<code>config/production.json</code>：</p>
<pre><code class="language-javascript">{
  <span class="hljs-string">"Customer"</span>: {
    <span class="hljs-string">"dbConfig"</span>: {
      <span class="hljs-string">"host"</span>: <span class="hljs-string">"prod-db-server"</span>
    },
    <span class="hljs-string">"credit"</span>: {
      <span class="hljs-string">"initialDays"</span>: <span class="hljs-number">30</span>
    }
  }
}
</code></pre>
<p>再新建测试文件<code>1.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'config'</span>);
<span class="hljs-built_in">console</span>.log(config);
</code></pre>
<p>执行程序，可看到其输出的结果为默认的配置：</p>
<pre><code class="language-javascript">{ <span class="hljs-attr">Customer</span>:
   { <span class="hljs-attr">dbConfig</span>: { <span class="hljs-attr">host</span>: <span class="hljs-string">'localhost'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">5984</span>, <span class="hljs-attr">dbName</span>: <span class="hljs-string">'customers'</span> },
     <span class="hljs-attr">credit</span>: { <span class="hljs-attr">initialLimit</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">initialDays</span>: <span class="hljs-number">1</span> } } }
</code></pre>
<p>假如要使用<code>production</code>的配置，则使用以下命令启动：</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">export</span> NODE_ENV=production &amp;&amp; node 1.js
</code></pre>
<p>则其输出将是如下结果：</p>
<pre><code class="language-json">{ Customer:
   { dbConfig: { host: 'prod-db-server', port: 5984, dbName: 'customers' },
     credit: { initialLimit: 100, initialDays: 30 } } }
</code></pre>
<p>在<code>production.json</code>文件中，重新定义了<code>Customer.dbConfig.host</code>和<code>Customer.credit.initialDays</code>这两个配置项，所以在<code>production</code>环境中仅这两项被覆盖为新的值，而其他配置项则使用<code>default.json</code>中指定的值。</p>
<p>载入<code>config</code>模块后，其返回的对象实际上就是当前的配置信息，同时提供了两个方法<code>get()</code>和<code>has()</code>来操作配置项。比如：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'config'</span>);
<span class="hljs-built_in">console</span>.log(config);
<span class="hljs-built_in">console</span>.log(config.get(<span class="hljs-string">'Customer'</span>));
<span class="hljs-built_in">console</span>.log(config.get(<span class="hljs-string">'Customer.dbConfig'</span>));
<span class="hljs-built_in">console</span>.log(config.has(<span class="hljs-string">'Customer.dbConfig.host'</span>));
<span class="hljs-built_in">console</span>.log(config.has(<span class="hljs-string">'Customer.dbConfig.host2'</span>));
</code></pre>
<p>执行程序后输出结果如下：</p>
<pre><code>{ Customer:
   { dbConfig: { host: 'localhost', port: 5984, dbName: 'customers' },
     credit: { initialLimit: 100, initialDays: 1 } } }
{ dbConfig: { host: 'localhost', port: 5984, dbName: 'customers' },
  credit: { initialLimit: 100, initialDays: 1 } }
{ host: 'localhost', port: 5984, dbName: 'customers' }
true
false
</code></pre>
<p>其中<code>get()</code>用来获取指定配置，可以使用诸如<code>Customer.dbConfig</code>这样的格式，如果配置项不存在则会抛出异常。<code>has()</code>用来检测指定配置项是否存在，如果存在则返回<code>true</code>。</p>
<p>关于<code>config</code>模块的详细使用方法可阅读其帮助文档。</p>
<h2><a id="_394"></a>相关链接</h2>
<ul>
<li><a href="http://baike.baidu.com/view/95930.htm">百度百科：环境变量</a></li>
<li><a href="http://yijiebuyi.com/blog/1bfcf43248a873b39a3471901e764b68.html">ENV 定制开发，测试，发布环境变量</a></li>
<li><a href="http://yijiebuyi.com/blog/ad84da0f2d945dd77cf9631c8548e02c.html">node-config 模块根据 ENV 环境变量不同加载响应的配置文件</a></li>
<li><a href="http://aicode.cc/article/413.html">YAML 格式</a></li>
<li><a href="http://segmentfault.com/a/1190000000522997">.gitignore 文件使用说明</a></li>
</ul>
<h2><a id="_403"></a>相关模块</h2>
<ul>
<li><a href="https://www.npmjs.com/package/strip-json-comments">strip-json-comments</a> - 去掉 JSON 字符串中的备注</li>
<li><a href="https://www.npmjs.com/package/yamljs">yamljs</a> - 解析 YAML</li>
<li><a href="https://www.npmjs.com/package/config">config</a> - 配置文件管理</li>
</ul>
]]></description><link>http://morning.work/page/2015-09/nodejs_project_config_loader.html</link><guid isPermaLink="true">http://morning.work/page/2015-09/nodejs_project_config_loader.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 17 Sep 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[在 Node.js 中读写大文件]]></title><description><![CDATA[<p>前段时间偶然需要整理一个几百 MB 的文本文件，内容大概 370W 行，我要将每一行的数据简单格式化一下，并转存到一个新的文件中。</p>
<p>在 Node.js 中，我们可以通过两种方式来读取文件：</p>
<ul>
<li>使用<code>fs.readFile()</code>一次性将文件内容全部读取出来，考虑到可能将来会操作几 G 大的文件，所以放弃了这种方式；</li>
<li>使用<code>fs.createReadStream()</code>创建一个读文件流，这种方式可不受限于文件的大小；</li>
</ul>
<p>因此，我很顺理成章地选用了<code>fs.createReadStream()</code>来读取文件，自然在写文件时也使用对应的<code>fs.createWriteStream()</code>来做。</p>
<p><h3>目录</h3><ul><ul><li><a href="#_15">按行读写流</a></li><ul><li><a href="#_19">安装模块</a></li><li><a href="#_27">按行读取流</a></li><li><a href="#_88">按行写流</a></li></ul><li><a href="#_127">控制读写速度</a></li><ul><li><a href="#_129">实验</a></li><li><a href="#_245">原理</a></li></ul><li><a href="#_365">优化写文件性能</a></li><ul><li><a href="#_367">实验</a></li><li><a href="#_516">原理</a></li></ul><li><a href="#_550">总结</a></li></ul></ul></p>
<h2><a id="_15"></a>按行读写流</h2>
<p>由于要操作的是文本文件，并且文件中的内容每一行记录均使用换行符<code>\n</code>来分隔，我编写了一个模块用来按行从一个<code>stream</code>中读取内容，以及按行往一个<code>stream</code>中写入内容，下面将介绍这个模块的简单使用方法。</p>
<h3><a id="_19"></a>安装模块</h3>
<p>执行以下命令安装</p>
<pre><code class="language-bash">$ npm install lei-stream --save
</code></pre>
<h3><a id="_27"></a>按行读取流</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;

readLine(<span class="hljs-string">'./myfile.txt'</span>).go(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, next</span>) </span>{
  <span class="hljs-built_in">console</span>.log(data);
  next();
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
});
</code></pre>
<p>说明：</p>
<ul>
<li><code>readLine()</code>的第一个参数应该传入一个<code>ReadStream</code>实例，当传入的是一个字符串时，会把它当作一个文件，自动调用<code>fs.createReadStream()</code>来创建一个<code>ReadStream</code></li>
<li><code>readLine()</code>的第二个参数为读取到一行内容时的回调函数，为了便于控制读取速度，需要在回调函数中执行<code>next()</code>来继续读取下一行</li>
<li><code>readLine()</code>的第三个参数为整个流读取完毕后的回调函数</li>
</ul>
<p>另外，我们也可以指定各个选项来达到更个性化的控制：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;

<span class="hljs-comment">// readLineStream 第一个参数为 ReadStream 实例，也可以为文件名</span>
<span class="hljs-keyword">var</span> s = readLine(fs.createReadStream(<span class="hljs-string">'./myfile.txt'</span>), {
  <span class="hljs-comment">// 换行符，默认\n</span>
  newline: <span class="hljs-string">'\n'</span>,
  <span class="hljs-comment">// 是否自动读取下一行，默认 false</span>
  autoNext: <span class="hljs-literal">false</span>,
  <span class="hljs-comment">// 编码器，可以为函数或字符串（内置编码器：json，base64），默认 null</span>
  encoding: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(data);
  }
});

<span class="hljs-comment">// 读取到一行数据时触发 data 事件</span>
s.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
  <span class="hljs-built_in">console</span>.log(data);
  s.next();
});

<span class="hljs-comment">// 流结束时触发 end 事件</span>
s.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
});
</code></pre>
<p>以下是关于<code>readLine()</code>的第二个参数的说明：</p>
<ul>
<li><code>newLine</code>表示换行符，默认为<code>\n</code>，当然也可以设置为任意字符，当读取到该字符时程序会认为该行数据已结束，并触发<code>data</code>事件</li>
<li><code>autoNext</code>表示是否自动读取下一行的内容，默认为<code>false</code>，如果设置为<code>true</code>，则不需要手动执行<code>next()</code>函数来继续读取</li>
<li><code>encoding</code>为编码器函数，默认为<code>null</code>，表示不对内容编码，我们可以自己指定一个编码器（要求该函数返回的是一个字符串），这样在每次<code>write()</code>一行数据时会自动调用该函数进行预处理</li>
</ul>
<p>以下是读取数据过程中的一些说明：</p>
<ul>
<li>当读取到一行数据时，会触发<code>data</code>事件</li>
<li>调用<code>s.next()</code>来读取下一行数据，如果在初始化<code>readLine()</code>时指定了<code>autoNext=true</code>，则可省略</li>
<li>当到达流末尾时，所有数据已读取完毕，会触发<code>end</code>事件</li>
</ul>
<h3><a id="_88"></a>按行写流</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> writeLineStream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).writeLine;

<span class="hljs-comment">// writeLineStream 第一个参数为 ReadStream 实例，也可以为文件名</span>
<span class="hljs-keyword">var</span> s = writeLineStream(fs.createWriteStream(<span class="hljs-string">'./myfile.txt'</span>), {
  <span class="hljs-comment">// 换行符，默认\n</span>
  newline: <span class="hljs-string">'\n'</span>,
  <span class="hljs-comment">// 编码器，可以为函数或字符串（内置编码器：json，base64），默认 null</span>
  encoding: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(data);
  },
  <span class="hljs-comment">// 缓存的行数，默认为 0（表示不缓存），此选项主要用于优化写文件性能，当数量缓存的内容超过该数量时再一次性写入到流中，可以提高写速度</span>
  cacheLines: <span class="hljs-number">0</span>
});

<span class="hljs-comment">// 写一行</span>
s.write(data, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 回调函数可选</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'wrote'</span>);
});

<span class="hljs-comment">// 结束</span>
s.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 回调函数可选</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
});
</code></pre>
<p>说明：</p>
<ul>
<li>与<code>readLine()</code>相类似，调用<code>writeLine()</code>时的第一个参数也可以是一个字符串，此时程序会自动调用<code>fs.createWriteStream()</code>来创建一个<code>WriteStream</code></li>
<li><code>writeLine()</code>的第二个参数为一些选项，其中<code>newLine</code>选项要保持与<code>readLine()</code>时 的<code>newLine</code>一致；<code>encoding</code>选项则刚好跟<code>readLine()</code>的相反；<code>cacheLines</code>选项表示缓存的数据行数，设置一个较大的值时可以一定程度提高写入性能，但也会增加写入延时，在下文将详细介绍</li>
<li>执行<code>s.write()</code>来写入一行数据</li>
<li>执行<code>s.end()</code>来结束写入</li>
</ul>
<h2><a id="_127"></a>控制读写速度</h2>
<h3><a id="_129"></a>实验</h3>
<p>我们在使用<code>fs.createReadStream()</code>创建一个读文件流后，文件内容便源源不断地被读取出来，不断地触发<code>data</code>事件。然后在<code>ReadStream</code>的<code>data</code>事件里面处理，并写入到<code>WriteStream</code>中。然而，大多数情况下读文件的速度总比写文件的速度快，这样便导致大量的数据被积压在内存中，当要读取的文件很大时，甚至会导致因占用内存太多而导致整个 Node.js 进程崩溃。</p>
<p>以下是我通过<code>lei-stream</code>编写的一个例子，按行读取数据并写入到另一个文件中（在写入文件时不等待写入完成即刻执行<code>next()</code>来读取下一行，用于模拟不限制读取速度）：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> readLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).readLine;
<span class="hljs-keyword">var</span> writeLine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lei-stream'</span>).writeLine;

<span class="hljs-comment">// 一个几百 M 的文本文件</span>
<span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'/Volumes/Works/data/xh.txt'</span>;
<span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'/Volumes/Works/tmp/output.txt'</span>;

<span class="hljs-keyword">var</span> output = writeLine(outputFile);
<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> startTime = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msToS</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(v / <span class="hljs-number">1000</span>, <span class="hljs-number">10</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSpentTime</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now() - startTime;
}

readLine(inputFile).go(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, next</span>) </span>{
  counter++;
  output.write(data);
  <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">10000</span> === <span class="hljs-number">0</span>) {
    printSpeedInfo();
  }
  next();
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
  output.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done. total %s lines, spent %sS'</span>, counter, msToS(getSpentTime()));
    printMemoryUsage();
    process.exit();
  });
});

<span class="hljs-comment">// 打印进度</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printSpeedInfo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> t = msToS(getSpentTime());
  <span class="hljs-keyword">var</span> s = counter / t;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFinite</span>(s)) s = counter;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read %s lines, speed: %sL/S'</span>, counter, s.toFixed(<span class="hljs-number">0</span>));
}

<span class="hljs-comment">// 打印内存占用情况</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMemoryUsage</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> info = process.memoryUsage();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mb</span> (<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">return</span> (v / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>) + <span class="hljs-string">'MB'</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rss=%s, heapTotal=%s, heapUsed=%s'</span>, mb(info.rss), mb(info.heapTotal), mb(info.heapUsed));
}
setInterval(printMemoryUsage, <span class="hljs-number">1000</span>);
</code></pre>
<p>执行这个程序后，打印出来的结果如下：</p>
<pre><code>read 210000 lines, speed: 210000L/S
rss=102.86MB, heapTotal=77.64MB, heapUsed=58.09MB

...

rss=739.00MB, heapTotal=726.18MB, heapUsed=695.31MB
rss=719.15MB, heapTotal=726.18MB, heapUsed=692.25MB
rss=713.75MB, heapTotal=726.18MB, heapUsed=704.64MB
done. total 3722040 lines, spent 80S
rss=709.11MB, heapTotal=726.18MB, heapUsed=695.46MB
</code></pre>
<p>从输出的结果中可以看出，程序启动一秒后内存占用即达到<code>77.64MB</code>，而在程序结束时内存占用已达到<code>726.18MB</code>，如果文件体积再增加一倍，估计整个程序是无法执行完成的。</p>
<p>为了验证限制读取速度是否有效，我将读取内容部分的程序改为这样：</p>
<pre><code class="language-javascript">readLine(inputFile).go(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, next</span>) </span>{
  counter++;
  output.write(data, next);
  <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">10000</span> === <span class="hljs-number">0</span>) {
    printSpeedInfo();
  }
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
  output.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done. total %s lines, spent %sS'</span>, counter, msToS(getSpentTime()));
    printMemoryUsage();
    process.exit();
  });
});
</code></pre>
<p>说明：在执行<code>output.write()</code>时，可以传入一个回调函数，当写入成功后执行此回调函数，再继续读取下一行数据。</p>
<p>重新运行程序，看到的结果如下：</p>
<pre><code>read 30000 lines, speed: 30000L/S
rss=45.11MB, heapTotal=28.18MB, heapUsed=11.11MB
read 40000 lines, speed: 40000L/S

...

read 3720000 lines, speed: 41333L/S
end
done. total 3722040 lines, spent 90S
rss=62.54MB, heapTotal=45.16MB, heapUsed=16.80MB
</code></pre>
<p>虽然程序的执行时间由原来的 80 秒增加到 90 秒，但整个进程的内存占用稳定保持在<code>45MB</code>，因此即使要读取一个超大文件功能也不会受到影响。</p>
<h3><a id="_245"></a>原理</h3>
<p><code>ReadAStream</code>提供了两个函数用于控制流：</p>
<ul>
<li><code>ReadStream.pause()</code>暂停读取 <a href="https://nodejs.org/api/stream.html#stream_readable_pause">参考文档</a></li>
<li><code>ReadStream.resume()</code>重新开始读取 <a href="https://nodejs.org/api/stream.html#stream_readable_resume">参考文档</a></li>
</ul>
<p>当读取速度超出我们期望的值时，可以执行<code>pause()</code>先暂停，待时机符合时再执行<code>resume()</code>重新开始。以下是用来限制读取速度的实例：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 一个几百 M 的文本文件</span>
<span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'/Volumes/Works/data/xh.txt'</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReadStreamThrottle</span> (<span class="hljs-params">stream, speed</span>) </span>{
  <span class="hljs-keyword">this</span>._stream = stream;
  <span class="hljs-keyword">this</span>._readBytes = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>._speed = speed;
  <span class="hljs-keyword">this</span>._ended = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>._readBytesSecond = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>._lastTimestamp = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">this</span>._paused = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

  <span class="hljs-comment">// 检查速度是否太快</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTooFast</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> t = (<span class="hljs-built_in">Date</span>.now() - self._lastTimestamp) / <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">var</span> bps = self._readBytesSecond / t;
    <span class="hljs-keyword">return</span> bps &gt; speed;
  }

  <span class="hljs-comment">// 每隔一段时间检查速度</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSpeed</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (isTooFast()) {
      self.pause();
      <span class="hljs-comment">// 直到平均速度放缓到预设的值时继续读流</span>
      <span class="hljs-keyword">var</span> tid = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!isTooFast()) {
          clearInterval(tid);
          self.resume();
        }
      }, <span class="hljs-number">100</span>);
    } <span class="hljs-keyword">else</span> {
      self.resume();
    }
  }

  stream.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
    self._readBytes += chunk.length;
    self._readBytesSecond += chunk.length;
    self.emit(<span class="hljs-string">'data'</span>, chunk);
    checkSpeed();
  });

  stream.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    self._ended = <span class="hljs-literal">true</span>;
    self.emit(<span class="hljs-string">'end'</span>);
  });
}

util.inherits(ReadStreamThrottle, events.EventEmitter);

ReadStreamThrottle.prototype.pause = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._paused = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>._stream.pause();
};

ReadStreamThrottle.prototype.resume = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>._paused = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>._stream.resume();
};


<span class="hljs-comment">// 读取文件，限制速度不大于 10MB/S</span>
<span class="hljs-keyword">var</span> MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> ReadStreamThrottle(fs.createReadStream(inputFile), MB * <span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> bytes = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Date</span>.now();
s.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>{
  bytes += c.length;
  <span class="hljs-keyword">var</span> spent = (<span class="hljs-built_in">Date</span>.now() - t) / <span class="hljs-number">1000</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'read %s bytes, speed: %sMB/S'</span>, bytes, (bytes / MB / spent).toFixed(<span class="hljs-number">2</span>));
});
s.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end. total %s bytes'</span>, bytes);
});
</code></pre>
<p>运行程序可以看到打印出以下结果：</p>
<pre><code>read 133627904 bytes, speed: 10.00MB/S
read 133693440 bytes, speed: 10.00MB/S
read 133758976 bytes, speed: 9.92MB/S
read 133824512 bytes, speed: 9.93MB/S
read 133890048 bytes, speed: 9.93MB/S
read 133955584 bytes, speed: 9.94MB/S
read 134021120 bytes, speed: 9.94MB/S
read 134086656 bytes, speed: 9.95MB/S
read 134152192 bytes, speed: 9.95MB/S
read 134217728 bytes, speed: 9.96MB/S
read 134283264 bytes, speed: 9.96MB/S
read 134348800 bytes, speed: 9.97MB/S
read 134414336 bytes, speed: 9.97MB/S
read 134479872 bytes, speed: 9.98MB/S
read 134545408 bytes, speed: 9.98MB/S
read 134610944 bytes, speed: 9.98MB/S
read 134676480 bytes, speed: 9.99MB/S
read 134742016 bytes, speed: 9.99MB/S
end. total 134742016 bytes
</code></pre>
<p>从结果中可以看出，读取速度并不是固定的 10MB/S，而是在这个范围内不断变化。其原因是程序在读取文件时，每次都会读取一定长度的内容（比如 64KB，
这个与系统设置的缓冲区大小有关），因此我们采用一种简单的方法来控制读取速度：每次触发<code>data</code>事件时，计算每秒的读取速度，如果超过预设的值则暂停读取，并每隔 100ms 检查一次，直到平均速度在预设的范围内再重新读取。</p>
<h2><a id="_365"></a>优化写文件性能</h2>
<h3><a id="_367"></a>实验</h3>
<p>前文中提到，『大多数情况下读文件的速度总比写文件的速度快，这样便导致大量的数据被积压在内存中，当要读取的文件很大时，甚至会导致因占用内存太多而导致整个 Node.js 进程崩溃』，那为什么我们在复制超大文件时程序又没问题呢？</p>
<p>于是我编写了以下程序：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> inputFile = <span class="hljs-string">'/Volumes/Works/data/xh.txt'</span>;
<span class="hljs-keyword">var</span> outputFile = <span class="hljs-string">'/Volumes/Works/tmp/output.txt'</span>;

<span class="hljs-keyword">var</span> input = fs.createReadStream(inputFile);
<span class="hljs-keyword">var</span> output = fs.createWriteStream(outputFile);

input.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
  output.write(chunk);
});

input.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);
  output.end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    printMemoryUsage();
    process.exit();
  });
});

<span class="hljs-comment">// 打印内存占用情况</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMemoryUsage</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> info = process.memoryUsage();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mb</span> (<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">return</span> (v / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>) + <span class="hljs-string">'MB'</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rss=%s, heapTotal=%s, heapUsed=%s'</span>, mb(info.rss), mb(info.heapTotal), mb(info.heapUsed));
}
setInterval(printMemoryUsage, <span class="hljs-number">1000</span>);
</code></pre>
<p>说明：在读取文件的<code>data</code>事件中，直接将数据原样写入到另一个文件中，用于模拟简单的复制文件操作。</p>
<p>程序执行结果如下：</p>
<pre><code>rss=64.89MB, heapTotal=10.28MB, heapUsed=3.78MB
rss=82.43MB, heapTotal=11.26MB, heapUsed=3.97MB
end
rss=83.86MB, heapTotal=11.26MB, heapUsed=5.21MB
</code></pre>
<p>从结果中可以看出，在读取文件结束后，写文件操作也很快完成，而内存占用并没有太大起伏。</p>
<p>于是我将<code>data</code>事件部分改为以下代码：</p>
<pre><code class="language-javascript">input.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
  chunk = chunk.toString();
  <span class="hljs-keyword">var</span> lines = chunk.split(<span class="hljs-string">'\n'</span>);
  lines.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
    output.write(line + <span class="hljs-string">'\n'</span>);
  });
});
</code></pre>
<p>说明：将读取出来的数据拆分成多行，并按行调用<code>write()</code>写入到文件中，用于模拟前文转换数据的例子。</p>
<p>程序运行结果如下：</p>
<pre><code>rss=117.18MB, heapTotal=91.43MB, heapUsed=62.23MB
rss=194.33MB, heapTotal=157.35MB, heapUsed=130.03MB
rss=262.67MB, heapTotal=213.45MB, heapUsed=193.70MB
rss=330.55MB, heapTotal=267.58MB, heapUsed=238.85MB
rss=408.13MB, heapTotal=329.58MB, heapUsed=300.90MB
rss=482.32MB, heapTotal=391.58MB, heapUsed=367.01MB
rss=529.28MB, heapTotal=455.54MB, heapUsed=424.50MB
rss=484.03MB, heapTotal=509.67MB, heapUsed=480.32MB
rss=460.43MB, heapTotal=565.77MB, heapUsed=539.37MB
rss=490.33MB, heapTotal=620.88MB, heapUsed=590.47MB
rss=502.39MB, heapTotal=675.99MB, heapUsed=649.05MB
rss=479.86MB, heapTotal=726.18MB, heapUsed=699.68MB
rss=829.57MB, heapTotal=734.05MB, heapUsed=698.78MB
end
rss=850.25MB, heapTotal=749.80MB, heapUsed=720.01MB
rss=851.16MB, heapTotal=749.80MB, heapUsed=720.41MB
rss=851.98MB, heapTotal=749.80MB, heapUsed=720.07MB
rss=852.92MB, heapTotal=749.80MB, heapUsed=720.56MB

...

rss=754.59MB, heapTotal=749.80MB, heapUsed=716.82MB
rss=764.16MB, heapTotal=749.80MB, heapUsed=714.73MB
rss=763.31MB, heapTotal=749.80MB, heapUsed=721.34MB
rss=762.20MB, heapTotal=749.80MB, heapUsed=725.75MB
</code></pre>
<p>由结果可以看出，在读取文件结束后，程序还运行了很长时间才完成了写文件操作，在此过程中内存占用不断地增加，并且很明显感觉到打印内存占用的速度越来越慢（本来应该是 1 秒作用的时间打印一次）。</p>
<p>是不是因为频繁的<code>write()</code>操作导致的呢？于是我又将<code>data</code>事件部分的代码改为这样：</p>
<pre><code class="language-javascript">input.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>{
  chunk = chunk.toString();
  <span class="hljs-keyword">var</span> lines = chunk.split(<span class="hljs-string">'\n'</span>);
  output.write(lines.join(<span class="hljs-string">'\n'</span>) + <span class="hljs-string">'\n'</span>);
});
</code></pre>
<p>说明：考虑到有可能是因为<code>data</code>事件中对数据的处理导致写入缓慢，于是同样将读取出来的数据拆分成多行，但是写入时又将这些数据合并起来，只执行一次<code>write()</code>。</p>
<p>程序运行结果如下：</p>
<pre><code>rss=37.27MB, heapTotal=22.28MB, heapUsed=5.30MB
rss=78.17MB, heapTotal=39.26MB, heapUsed=14.64MB
rss=98.62MB, heapTotal=39.26MB, heapUsed=14.61MB
end
rss=100.35MB, heapTotal=39.26MB, heapUsed=15.00MB
</code></pre>
<p>由结果可以看出，在<code>data</code>事件中对数据的处理确实影响到了读文件的性能（全部读取完毕的时间由原来的 2 秒增加到 3 秒），另外内存占用也增加了，到结果与第一个例子中的简单复制文件相差不大。</p>
<p>由此可以确定，减少<code>write()</code>的次数确实能提高写文件的速度。</p>
<p>于是，在<code>lei-stream</code>模块中，增加了一个新的选项<code>cacheLines</code>用于指定缓存的行数，当执行<code>write()</code>时并不会马上将结果写入到流中，仅当达到这个数量时再一次性写入。</p>
<p>我们将『控制读写速度』章节实验例子中的<code>writeLine()</code>改为以下代码（增加<code>cacheLines</code>选项）：</p>
<pre><code>var output = writeLine(outputFile, {
  cacheLines: 10000
});
</code></pre>
<p>重新运行程序，其结果如下：</p>
<pre><code>read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
read 3720000 lines, speed: 286154L/S
end
done. total 3722040 lines, spent 13S
rss=64.83MB, heapTotal=45.16MB, heapUsed=15.29MB
</code></pre>
<p>由结果可以看出，程序执行时间从原来的 90S 下降到 13S，并且内存占用仍然保持在 45.16MB。</p>
<h3><a id="_516"></a>原理</h3>
<p>首先看看 Node.js 源码中<code>fs.ReadStream</code>的<code>write()</code>里面是怎样的（<a href="https://github.com/joyent/node/blob/master/lib/fs.js#L1789">源码</a>）：</p>
<pre><code class="language-javascript">WriteStream.prototype._write = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, encoding, cb</span>) </span>{
  <span class="hljs-keyword">if</span> (!util.isBuffer(data))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid data'</span>));

  <span class="hljs-keyword">if</span> (!util.isNumber(<span class="hljs-keyword">this</span>.fd))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'open'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>._write(data, encoding, cb);
    });

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  fs.write(<span class="hljs-keyword">this</span>.fd, data, <span class="hljs-number">0</span>, data.length, <span class="hljs-keyword">this</span>.pos, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">er, bytes</span>) </span>{
    <span class="hljs-keyword">if</span> (er) {
      self.destroy();
      <span class="hljs-keyword">return</span> cb(er);
    }
    self.bytesWritten += bytes;
    cb();
  });

  <span class="hljs-keyword">if</span> (!util.isUndefined(<span class="hljs-keyword">this</span>.pos))
    <span class="hljs-keyword">this</span>.pos += data.length;
};
</code></pre>
<p>由源码可以看出，每一次的<code>write()</code>实际上是直接调用<code>fs.write()</code>来写入文件的（<code>WriteStream</code>记录了当前文件的偏移量），当频繁调用<code>write()</code>来写入数据时，每一次都会创建用于<code>fs.write()</code>的回调函数，因此内存占用急剧升高和性能下降也就很合情合理了。</p>
<p><strong>注意：<code>lei-stream</code>本身的设计是用于读写流，并不仅限于文件流，因此<code>cacheLines</code>选项并不总是能起到提升性能的作用，所以把<code>cacheLines</code>设计为需要手动开启</strong></p>
<h2><a id="_550"></a>总结</h2>
<p>前几天在 CNode 论坛看到有人提问<a href="https://cnodejs.org/topic/55a4b5213ecc81b621bba8d0">『nodejs 如何加载大数据 json 文件比如 2g ，3g，10g』</a>，其实这里的问题除了文件很大之外，重点还是在『读取 JSON 字符串里面的某部分内容』。</p>
<p>一般情况下，在 Node.js 中读写大文件并没有什么高深的技术，主要注意以下几点：</p>
<ul>
<li>数据可被拆分成小块处理（比如一些日志文件，按行读写）</li>
<li>控制读取速度，保持读写速度同步</li>
</ul>
<p>本文中提到的<code>lei-stream</code>模块源码可从这里获得：<a href="https://github.com/leizongmin/node-lei-stream">https://github.com/leizongmin/node-lei-stream</a></p>
]]></description><link>http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html</link><guid isPermaLink="true">http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 16 Jul 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[一种简单的生产环境部署 Node.js 程序方法]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#_9">配置文件</a></li><li><a href="#_67">本地开发测试</a></li><li><a href="#_78">部署应用</a></li><li><a href="#_121">扩展阅读</a></li></ul></ul></p>
<p><img src="../../images/2014-08/girl.jpg" alt="我的梦想是成为一名画家"></p>
<p>最近在部署 Node.js 程序时，写了段简单的脚本，发觉还挺简单的，忍不住想与大家分享。</p>
<h2><a id="_9"></a>配置文件</h2>
<p>首先，本地测试环境和生产环境的数据库连接这些配置信息是不一样的，需要将其分开为两个文件存储
到<code>config</code>目录下，比如：</p>
<p>开发环境配置文件<code>config/development.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">port</span>:  <span class="hljs-number">3001</span>,
  <span class="hljs-attr">mysql</span>: {
    <span class="hljs-attr">user</span>: <span class="hljs-string">'root'</span>
  }
};
</code></pre>
<p>生产环境配置文件<code>config/production.js</code>:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">port</span>: <span class="hljs-number">80</span>,
  <span class="hljs-attr">mysql</span>: {
    <span class="hljs-attr">user</span>: <span class="hljs-string">'myapp'</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-string">'2zbonsjzl305vkh3'</span>
  }
};
</code></pre>
<p>另外还要建立一个程序自动载入相应环境的配置，文件<code>config/index.js</code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-comment">// 通过 NODE_ENV 来设置环境变量，如果没有指定则默认为生产环境</span>
<span class="hljs-keyword">var</span> env = process.env.NODE_ENV || <span class="hljs-string">'production'</span>;
env = env.toLowerCase();

<span class="hljs-comment">// 载入配置文件</span>
<span class="hljs-keyword">var</span> file = path.resolve(__dirname, env);
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">var</span> config = <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(file);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Load config: [%s] %s'</span>, env, file);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Cannot load config: [%s] %s'</span>, env, file);
  <span class="hljs-keyword">throw</span> err;
}
</code></pre>
<p>假设应用的入口文件是<code>app.js</code>，可通过以下方法载入配置：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'listen on port %s'</span>, config.port);
<span class="hljs-comment">// 如果是开发环境，将输出 listen on port 3001</span>
<span class="hljs-comment">// 如果是生产环境，将输出 listen on port 80</span>
</code></pre>
<h2><a id="_67"></a>本地开发测试</h2>
<p>为了方便，我新建一个脚本文件<code>run</code>，代码如下：</p>
<pre><code class="language-bash"><span class="hljs-built_in">export</span> NODE_ENV=development
node app
</code></pre>
<p>要启动程序，直接在命令行下执行<code>./run</code>即可。</p>
<h2><a id="_78"></a>部署应用</h2>
<p>新建部署脚本文件<code>deploy</code>，代码如下：</p>
<pre><code class="language-bash">git reset --hard
git pull origin HEAD
npm install
pm2 stop myapp <span class="hljs-_">-f</span>
pm2 start app.js -n myapp
</code></pre>
<p>此段代码会自动拉去 git 仓库中最新的一次提交的代码，并使用 npm 来安装 package.json 中列出的模块，
然后先停止之前已启动的应用实例，再启动。</p>
<p>为了方便传输代码到服务器端，需要将程序代码提交到一个私有的 git 仓库，首次在服务器端部署时，
需要先将代码 clone 到服务器端，比如：</p>
<pre><code class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:leizongmin/node-uc-server.git ~/myapp
</code></pre>
<p>应用在服务器端运行时使用<code>pm2</code>工具来管理进程，所以还需要先在服务器上安装此工具：</p>
<pre><code class="language-bash">npm install pm2 -g
</code></pre>
<p>完成以上准备工作后，我们就可以通过<code>deploy</code>脚本来实现自动更新代码：</p>
<ul>
<li>将本地修改提交到远程 git 仓库</li>
<li>登录服务器，进入<code>~/myapp</code>目录</li>
<li>执行<code>./deploy</code></li>
</ul>
<hr>
<p>以上程序执行的环境为 Linux，如果开发环境是 Windows，需要将<code>run</code>文件改为以下代码：</p>
<pre><code class="language-bash"><span class="hljs-built_in">set</span> NODE_ENV=development
node app
</code></pre>
<h2><a id="_121"></a>扩展阅读</h2>
<ul>
<li><a href="http://www.oschina.net/translate/goodbye-node-forever-hello-pm2">告别 node-forever,拥抱 PM2</a></li>
<li><a href="http://blog.segmentfault.com/pengedy/1190000000514886">Git 入门指引</a></li>
</ul>
]]></description><link>http://morning.work/page/2014-08/deploy-nodejs-production-app.html</link><guid isPermaLink="true">http://morning.work/page/2014-08/deploy-nodejs-production-app.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 28 Aug 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[《Node.js 入门系列》—— 一些简单的排错方法（一）]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#TypeError_undefined_is_not_a_function_64">TypeError: undefined is not a function</a></li><li><a href="#TypeError_Cannot_read_property_xxx_of_undefined__TypeError_Cannot_read_property_xxx_of_null_112">TypeError: Cannot read property 'xxx' of undefined 或者 TypeError: Cannot read property 'xxx' of null</a></li><ul><li><a href="#_135">检查变量是未赋值</a></li><li><a href="#_142">检查函数是否有返回值</a></li><li><a href="#_153">检查变量是否引用了某个对象不存在的属性</a></li><li><a href="#_161">检查调用函数时是否未该传递参数</a></li></ul></ul></ul></p>
<p>俗话说“常在河边走，哪能不湿鞋”，只要动手写程序，总会时不时的冒出点问题来，
很难一下子就写出完全正确运行的程序。哪怕只是拿别人的程序来运行，也不能保证其能
适应各种各样的系统环境，不作任何修改就能使用。因此，学会一些简单的排错方法是很
有必要的。</p>
<p>在 Node.js 程序运行过程中，当出现没有被捕捉到的异常时，程序会打印出相应的出错
信息，并终止运行。比如以下出错信息：</p>
<pre><code>f:\tmp\2013-10-7\t.js:3
proceess.nextTick(function () {
^
ReferenceError: proceess is not defined
    at Object.&lt;anonymous&gt; (f:\tmp\2013-10-7\t.js:3:1)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:901:3
</code></pre>
<p>出错信息的第 1 行 <code>f:\tmp\2013-10-7\t.js:3</code> 指明了在文件 <code>f:\tmp\2013-10-7\t.js</code>
的第 3 行出错了；</p>
<p>出错信息的第 2 行是相应的源程序 <code>proceess.nextTick(function () {</code> ；</p>
<p>出错信息的第 3 行的 <code>^</code> 指明了在该行的具体位置 <code>proceess</code> ；</p>
<p>出错信息的第 4 行是具体的出错信息 <code>ReferenceError: proceess is not defined</code> ，后面
还有几行以 <code>at</code> 开头的内容是详细的调用堆栈信息，可以以此来追踪到整个程序的
执行流程。</p>
<p>当遇到这样的出错信息时，我们首先应该看第 4 行的
<code>ReferenceError: proceess is not defined</code> ，前面的 <code>ReferenceError</code> 是错误对象，
表示这是一个“非法引用”错误，其后便相应的提示信息，大概意思是“ <code>proceess</code> 未定义”
（看不懂可以用软件翻译一下，比如 <a href="http://dict.youdao.com/">有道词典</a>），
这时候我们再往上看原来的程序是怎么写的：<code>proceess.nextTick(function () {</code> 。
从这个程序可以看出来，要调用的应该是 <code>process.nextTick()</code> ，
此处不小心把 <code>process</code> 写成了 <code>proceess</code> ，程序自然就报错“ <code>proceess</code> 未定义”了。</p>
<p>常见的错误对象有以下这些：</p>
<ul>
<li>
<p><strong>EvalError</strong> : 错误发生在 <code>eval()</code> 函数中，一般是要使用 <code>eval()</code> 执行的代码有语法错误</p>
</li>
<li>
<p><strong>RangeError</strong> : 数字的值超过 javascript 可表示的范围</p>
</li>
<li>
<p><strong>ReferenceError</strong> : 使用了非法的引用，一般是引用了一个未定义的变量或者函数</p>
</li>
<li>
<p><strong>SyntaxError</strong> : 在 eval()函数调用中发生了语法错误</p>
</li>
<li>
<p><strong>TypeError</strong> : 变量的类型不是预期所需的</p>
</li>
<li>
<p><strong>URIError</strong> : 在 encodeURI()或者 decodeURI()函数中发生的错误</p>
</li>
</ul>
<p>记住这些常见的错误对象有助于更快速地理解出错信息。</p>
<h2><a id="TypeError_undefined_is_not_a_function_64"></a>TypeError: undefined is not a function</h2>
<p>出现这种错误的原因是某个变量不是 <code>Function</code> 类型，却把它当函数来调用了。例如：</p>
<p>帖子： <a href="http://cnodejs.org/topic/516acc466d38277306395c93">《node 连接 mysql 出错》</a></p>
<p>Node.js 代码：</p>
<pre><code>var Client = require('mysql').Client;
var client = new Client();
client.host = 'localhost';
client.port = 3306;
client.user = 'root';
client.password = '123456';
client.database='test1';

query(client);

function query (client) {
  client.query('select * from user', function (err, res, fields) {
    console.log(res);
    client.end();
  });
}
</code></pre>
<p>出错信息：</p>
<pre><code>/home/king/node/mysql.js:2
var client = new Client();
             ^
TypeError: undefined is not a function
    at Object.&lt;anonymous&gt; (/home/king/node/mysql.js:2:14)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)
    at startup (node.js:119:16)
    at node.js:901:3
</code></pre>
<p>由出错信息可以看出，在执行 <code>new Client()</code> 时出错了，
<code>TypeError: undefined is not a function</code> ，也就是说，此时 <code>Client</code> 的值是
<code>undefined</code> 。我们再往上看，可以看到 <code>var Client = require('mysql').Client</code>
那么，应该是 <code>mysql</code> 这个模块并没有输出 <code>Client</code> 这个函数，我们可以执行
<code>console.log(require('mysql'))</code> 来打印 <code>mysql</code> 模块的输出，也确定并没有 <code>Client</code>
这一项，这时候就应该详细看一下 mysql 模块帮助文档以及其正确的使用方法了。</p>
<h2><a id="TypeError_Cannot_read_property_xxx_of_undefined__TypeError_Cannot_read_property_xxx_of_null_112"></a>TypeError: Cannot read property 'xxx' of undefined 或者 TypeError: Cannot read property 'xxx' of null</h2>
<p>出现这种错误的原因是尝试读取一个值为 <code>undefined</code> 或 <code>null</code> 的变量的属性。比如如下代码：</p>
<pre><code>var a = undefined;
console.log(a.b);
</code></pre>
<p>执行该程序将会抛出异常：</p>
<pre><code>TypeError: Cannot read property 'b' of undefined
    at repl:1:15
    at REPLServer.self.eval (repl.js:110:21)
    at Interface.&lt;anonymous&gt; (repl.js:239:12)
    at Interface.EventEmitter.emit (events.js:95:17)
    at Interface._onLine (readline.js:202:10)
    at Interface._line (readline.js:531:8)
    at Interface._ttyWrite (readline.js:760:14)
    at ReadStream.onkeypress (readline.js:99:10)
    at ReadStream.EventEmitter.emit (events.js:98:17)
    at emitKey (readline.js:1095:12)
</code></pre>
<p>当出现这种情况时，我们可以通过以下方法来排查：</p>
<h3><a id="_135"></a>检查变量是未赋值</h3>
<p>假如只通过 <code>var a</code> 来声明了变量，但未赋值，此时变量的值为 <code>undefined</code> ，示例：</p>
<pre><code>var a; // 没有赋值
console.log(a.b);
</code></pre>
<h3><a id="_142"></a>检查函数是否有返回值</h3>
<p>当函数没有用 <code>return</code> 来返回一个值时，那么这个函数的返回值就是 <code>undefined</code> ，
示例：</p>
<pre><code>function f () {
  // 没有返回值
}
var a = f();
console.log(a.b);
</code></pre>
<h3><a id="_153"></a>检查变量是否引用了某个对象不存在的属性</h3>
<p>当引用了某个对象一个不存在的属性时，其值就是 <code>undefined</code> ，示例：</p>
<pre><code>var obj = {};
var a = obj.c; // 引用了一个不存在的属性
console.log(a.b);
</code></pre>
<h3><a id="_161"></a>检查调用函数时是否未该传递参数</h3>
<p>当调用某个函数时没有按要求传递足够的参数，则在函数体内该参数的值是 <code>undefined</code> ，
示例：</p>
<pre><code>function f (a) {
  console.log(a.b);
}
f(); // 本来该函数需要 1 个参数
</code></pre>
<hr>
<p>扩展阅读：</p>
<ul>
<li><a href="http://www.cnblogs.com/aqbyygyyga/archive/2011/10/29/2228824.html">javascript 异常处理</a></li>
</ul>
]]></description><link>http://morning.work/page/2013-10/nodejs-simple-debug-1.html</link><guid isPermaLink="true">http://morning.work/page/2013-10/nodejs-simple-debug-1.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Wed, 09 Oct 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[《Node.js 入门系列》—— NPM 安装第三方模块常见问题]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#_npm_install_xxx__5">断网的机器，没法直接 npm install xxx 怎么办？</a></li><ul><li><a href="#_github_31">模块源码没有托管到 github</a></li><li><a href="#_C__41">不需要 C++ 编译的模块还有更简便的安装方法</a></li></ul><li><a href="#_48">如何使用私有的模块</a></li><ul><li><a href="#1_NPM__50">1、搭建私有 NPM 库</a></li><li><a href="#2_js__57">2、通过一个 js 文件来链接</a></li></ul><li><a href="#npm_install__69">npm install 时出错</a></li><ul><li><a href="#_71">域名解析出错</a></li><li><a href="#_103">其他问题</a></li></ul></ul></ul></p>
<h2><a id="_npm_install_xxx__5"></a>断网的机器，没法直接 npm install xxx 怎么办？</h2>
<p>在部署 Node.js 写的应用时，我们都会在应用的根目录下执行 <code>npm install</code> 来安装所有
的依赖模块，安装第三方模块也一样，你只要找到这个模块的源码，执行 <code>npm install</code>
即可。</p>
<p>假如我们要安装一个叫 <code>xss</code> 的模块，因为不能直接用 <code>npm install xss</code> 来安装，
首先我们得想办法获取到这个这个模块的源码。</p>
<p>先在浏览器中打开模块的主页： <a href="https://npmjs.org/package/xss">https://npmjs.org/package/xss</a>
（如果不明白这个网址是怎么来的，
请阅读 <a href="http://f2e.html-js.com/article/1378">《寻找第三方模块》</a>）</p>
<p>这时候我们可以知道 xss 这个模块的源码托管在 github 上，我们可以通过 git 命令
把源码拉下来： <code>git clone git://github.com/leizongmin/js-xss.git</code></p>
<p>为了能让应用访问到这个模块，我们需要把源码放在应用的 <code>node_modules</code> 目录里面，
比如这个模块叫 <code>xss</code> ，那么它的源码就应该在 <code>node_modules/xss</code> 目录里面。</p>
<p>然后进入 <code>node_modules/xss</code> 目录，打开这个模块的 <code>package.json</code> 文件，看看
<code>dependencies</code> 这一项中是否有指定依赖模块，如果有的话，按照相同的方法把其依赖
模块也安装到这个模块的 <code>node_modules</code> 目录里。</p>
<p>（如果不明白为什么要放到 <code>node_modules</code> 目录，
请阅读 <a href="http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders">《Node.js API - Modules》</a>）</p>
<h3><a id="_github_31"></a>模块源码没有托管到 github</h3>
<p>假如某个模块没有将源码托管到 github 这样的开源平台上，我们照样有办法获取到它的
源码：把 <code>https://registry.npmjs.org/模块名/-/模块名-版本号.tgz</code> 这个压缩包下载
下来即可。</p>
<p>比如要下载 <code>xss</code> 模块 <code>0.0.6</code> 版本的源码，其对应的网址就是
<code>https://registry.npmjs.org/xss/-/xss-0.0.6.tgz</code> 。把压缩包下载下来后，先解压，
其里面的 <code>package</code> 目录即是这个模块的源码，这时候就可以按照上面说的那样安装了。</p>
<h3><a id="_C__41"></a>不需要 C++ 编译的模块还有更简便的安装方法</h3>
<p>大多数的第三方模块都是纯 JavaScript 写的，不需要进行 C++ 编译，我们只要在一台
能使用 <code>npm install xxx</code> 安装模块的机器上把模块安装好，直接复制到应用的
<code>node_modules</code> 目录即可。</p>
<h2><a id="_48"></a>如何使用私有的模块</h2>
<h3><a id="1_NPM__50"></a>1、搭建私有 NPM 库</h3>
<p>一般一些大的公司，有自己内部的 Node.js 模块库时，会尝试这种搭建私有的 NPM 库，
搭建好之后，直接使用 <code>npm install xxxx</code> 来安装模块，但是操作难度较大，有兴趣的
可以参考
<a href="https://github.com/isaacs/npmjs.org">The couchdb setup for registry.npmjs.org and search.npmjs.org</a>。</p>
<h3><a id="2_js__57"></a>2、通过一个 js 文件来链接</h3>
<p>假如有一个私有模块 <code>abc</code> ，其源码放在 <code>/npm/abc</code> 目录，我们可以直接在当前应用的
<code>node_modules</code> 目录下创建一个文件 <code>abc.js</code>，其内容如下：</p>
<pre><code>module.exports = require('/npm/abc');
</code></pre>
<p>然后就可以直接通过 <code>require('abc')</code> 来载入这个私有模块了。</p>
<p>当同时在开发几个模块，而这几个模块存在依赖关系时，使用这种方法也能方便调试。</p>
<h2><a id="npm_install__69"></a>npm install 时出错</h2>
<h3><a id="_71"></a>域名解析出错</h3>
<p>有时候网络不稳定会导致安装不成功，比如显示如下出错信息：</p>
<pre><code>npm http GET http://registry.npmjs.org/supervisor
npm ERR! Error: getaddrinfo EADDRINFO
npm ERR! at errnoException (dns.js:37:11)
npm ERR! at Object.onanswer [as oncomplete] (dns.js:124:16)
npm ERR! If you need help, you may report this log at:
npm ERR! http://github.com/isaacs/npm/issues
npm ERR! or email it to:
npm ERR! npm-@googlegroups.com

npm ERR! System Linux 3.2.0-23-generic-pae
npm ERR! command &quot;/usr/bin/node&quot; &quot;/usr/bin/npm&quot; &quot;install&quot; &quot;-g&quot; &quot;supervisor&quot;
npm ERR! cwd /home/lwj
npm ERR! node -v v0.10.18
npm ERR! npm -v 1.3.8
npm ERR! syscall getaddrinfo
npm ERR! code EADDRINFO
npm ERR! errno EADDRINFO
npm ERR!
npm ERR! Additional logging details can be found in:
npm ERR! /home/lwj/npm-debug.log
npm ERR! not ok code 0
</code></pre>
<p>从中可以找到 <code>syscall getaddrinfo</code> 和 <code>code EADDRINFO</code> 这两行，<code>EADDRINFO</code> 表示
在尝试解析域名的时候出错了，没法从 <code>registry.npmjs.org</code> 上下载模块的源码，
这时候我们只需要重新执行一遍命令即可。如果问题还没有解决，应该检查一下本地机器
域名解析服务是否正常，某些地区 <code>registry.npmjs.org</code> 这个域名会被屏蔽。如果实在
无法通过命令直接安装模块，可参考本文开头提到的方法来手动安装。</p>
<h3><a id="_103"></a>其他问题</h3>
<p>还有很多……</p>
]]></description><link>http://morning.work/page/2013-09/npm-install-problems.html</link><guid isPermaLink="true">http://morning.work/page/2013-09/npm-install-problems.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Thu, 26 Sep 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[《Node.js 入门系列》—— 寻找第三方模块]]></title><description><![CDATA[<p><h3>目录</h3><ul><ul><li><a href="#1_5">1、知道模块名，寻找模块的文档</a></li><li><a href="#2_20">2、不知道模块名，根据关键字搜索需要的模块</a></li></ul></ul></p>
<h2><a id="1_5"></a>1、知道模块名，寻找模块的文档</h2>
<p>在看别人的代码或者文章的时候，经常会遇到自己没用过的第三方模块，怎么办呢？
其实很简单，你只要在浏览器中输入网址 <code>https://npmjs.org/package/模块名称</code> ，即可
进入这个模块的介绍页面。比如，别人的源码中出现一行 <code>var xss = require('xss')</code> ，
说明这里使用到了 <code>xss</code> 这个模块，在浏览器中打开 <code>https://npmjs.org/package/xss</code>
，即可进入这个模块在 NPM 上的主页：</p>
<p><img src="http://htmljs.b0.upaiyun.com/uploads/1380023785392-1.png" alt="xss 模块的 NPM 主页"></p>
<p>模块主页中显示这个模块的简介、作者、当前版本号、最后更新时间、模块源码链接、
报告 Bug 的链接和 README 页面。一般 README 页面都会简要地写出了模块的用途、用法
等等信息，大多数模块也都是托管在 Github 上的，直接点模块源码链接（Repository）
即可跳到其在 Github 上的主页，可以通过这里获得更多的帮助。</p>
<h2><a id="2_20"></a>2、不知道模块名，根据关键字搜索需要的模块</h2>
<p>我们可以通过 NPM 来寻找自己需要的模块。打开 NPM 的首页 <code>https://npmjs.org/</code> ，
在 Logo 的右边，有一个搜索框，只要在上面输入关键字，即可搜索出相应的模块。比如
我们要搜索“模板”相关的模块，在搜索框输入 <code>template</code> 并按回车：</p>
<p><img src="http://htmljs.b0.upaiyun.com/uploads/1380024594836-2.png" alt="NPM 搜索结果"></p>
<p>页面中显示出了相应的模块名称、简介、作者和当前版本，直接点击模块名称即可进入这个
模块的主页。</p>
<p>但是， NPM 的搜索结果中，我们没法直接看到这个模块有多少人用，最后更新时间是什么
时候了（有些模块可能已经是几年前的了），怎么办？这就要用到我压箱底多年的工具了，
一般人我不告诉他的：</p>
<p>在浏览器中打开 <code>http://eirikb.github.io/nipster/</code> （由于要加载所模块的信息，可能
要等一阵才能完全显示出来）：</p>
<p><img src="http://htmljs.b0.upaiyun.com/uploads/1380025151549-3.png" alt="Nipster 首页"></p>
<p>在搜索栏中输入关键字，会自动筛选出相应的模块。模块信息包括了模块名称、简介、
作者、最后更新时间、Fork 数量和收藏数量。默认按照 Fork 数量降序排序，基本上
最前面的结果是最多人用的。</p>
<p>上面简单介绍了两种寻找 Node.js 模块的方法，学会了这两招之后，妈妈基本上再也不用
担心你找不到好模块了。</p>
]]></description><link>http://morning.work/page/2013-09/nodejs-find-modules.html</link><guid isPermaLink="true">http://morning.work/page/2013-09/nodejs-find-modules.html</guid><dc:creator><![CDATA[老雷]]></dc:creator><pubDate>Tue, 24 Sep 2013 00:00:00 GMT</pubDate></item></channel></rss>